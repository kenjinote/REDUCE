

         Installation of PSL and REDUCE for 
            UNIX systems based on 
              MC680xx and I80386
                 processors
 
           H. Melenk  Konrad-Zuse-Zentrum Berlin
                 27 Nov. 1989
 
 
1. Installation Prerequisits
----------------------------
 
This implementation of Portable Standard LISP (PSL) and REDUCE
was desigend for UNIX systems featuring the processors
        
        Motorola 68020 (68030) 
        Intel  80386 (80486)
 
For both processors REDUCE and PSL are compiled into genuine
machine code, which is loaded by a PSL loader written in C.
Allthough this loader is designed in a system independent
style, local modifications may be necessary, because delicate
features of the operating systems have to be used, e.g. the
memory management and the error recovery. So for an implementation
there are prerequisits:
 
    - a C compiler and library is available
    - the virtual memory is large enough
    - the data addresses assigned by the system are
      compatible with the PSL item model
       (680xx: addresses below 2**24
        386: addresses below 2**27)
    
In order to allow a test of these prerequisits, a test package
is available without fee. This test package consists of all
C parts and some compiled LISP objects. If these can be installed
with success, an installation of a full system is possible
without further difficulty.
 
The system interface routines provide for both, UNIX System V and 
BSD UNIX.  However, UNIX System V is the default for non-SUN computers. 
If needed for other environments, please modify the #ifdef statments
in the C-sources.

 
2. The PSL Loader
-----------------
 
The implementation is based on a C program, which provides for
all system contacts of PSL and REDUCE. For a successful installation,
this program has to be compiled and linked on the target system.
Its main purpose is to load the processor specific binaries and
to organize their linkage to the system. The C program is compiled
from the following set of source files:
 
   psll.c          main program
   echo.c          terminal control
   file-status.c   file control
   float.c         floating point arithmetic
   misc.c          embedding for some c library routines
   pslextras.c
   sigs.c          control o signal handling
   unix-io.c       input-output routines
 
As an additional file for the C compilation
 
   psll.h
 
is needed, which is generated by the PSL compiler at kernel
compile time; this file defines the interface
between LISP and C and is specific for the individual
kernel. The compatibility of this header and the kernel to be
loaded is controlled by a magic number. However, if that
file is modified by hand in an unappropriate manner, the
compatibility gets lost without control.
 
Once compiled and linked, the main programm psll is available. 
Its operation is controlled by the following parameters:
 
    psll [option...]
 
   The psll command invokes the PSL loader and accepts the following
   types of arguments:
    - arguemnts beginning with -i , -b, -h, -s, -v
      these are interpreted by psll directly
    - other arguments, which will be passed to the
      object to be loaded.
 
   OPTIONS
   -ixxx           xxx should be a legal file name. It is
                   interpreted as the binary to be loaded
                   by psll. So it mus be a file which contains
                   either a kernel (e.g. main.b) or a saved
                   system image (e.g. psl.img), which is 
                   compatible with the version of psll.
     
   -vn             n should be 0, 1 or 2; 0 is the default.
                   0 : no load map
                   1 : print map of memory allocation
                   2 : print full relocation tables
      
   -dqqq           qqq should be a directory (or expand to a
                   directory). If set, a "cd" to this
                   directory will take place AFTER loading
                   but BEFORE starting the image. This
                   is used during system generation
                   (qqq as directory of the non-kernel modules).

      the following options are interpreted only when a kernel
      is loaded; they overwrite the memory size values which
      the kernel inherited from his parent; the paraemters are
      decimal numbers;
  
   -bnnn           nnn new size of binary program space in bytes
                  
   -hmmm           mmm new size of heap space in bytes; note
                   that here the total space for both heaps
                   has to be given; so a "-h8000000" corresponds
                   to a system with two heaps of 1000000 LISP
                   items (each with 4 bytes).

   -skkk           kkk new size of the stack in bytes; each 
                   stack item needs four bytes. This value has
                   effect only for implementations where PSL
                   does not use the UNIX system stack.
                   It has no effect otherwise, e.g. for I80386
                   processors.
                   


The loader psll tries to check as much as possible and to give
readable comments in case of problems. At least during memory
initialization all problems should be detected. If an error
analysis for the execution of the started object is necessary,
the entry point "execute" in psll is an appropriate breakpoint
e.g. for adb or dbx; here the execution of the loaded program
starts.

There are two modes of operation:
 
  - kernel loading
  - image loading.
 
If the system is started from scratch, PSLL loads the PSL
kernel, which is a binary generated by the PSL compiler in a
specific mode. This kernel is a minimal environment with a
memory manager, a LISP specific loader, some untility
functions and the interface to the operating system in 
mapped to the LISP function protocol. The kernel then
loads a set of up to 80 LISP binaries, the "nonkerenl",
which then establish a complete LISP environment, the
so called "bare-psl". This complete environment can be used
for LISP execution (e.g. for loading additional modules).
Especially is it enabled, to conserve itself for later
reexecution. This operation is called "savesystem" and generates
an image file, which contains the complete environment in the
current state.
 
Once an image has been generated, it can be loaded and started
by PSLL direcly later on. E.g. the REDUCE program usually is
generated as an image in that style, but other PSL application
environments can be supported in the same style.

3. The Test Package
-------------------
 
Usually the test package is written in tar format to a 3.5 
minidisc.  In a full PSL or REDUCE UNIX installation tape, the test 
package should be a subdirectory "tests" in the directory "$pxk"; 
its source files then should be link entries to the corresponding 
sources in $pxk.


3.1 Test 1 and test 2
----------------------
 
These are minimal tests. There is a shell script
         test-1-2.cs

which performs all actions necessary. When started, the
first time, please ensure that all compilations and the
linkage are performed without problems. If there are problems,
it might be necessary to perform the steps of this script
one after the other by hand.
 
Test 1: The kernel is able to print some fixed messages to the 
terminal. The binary file is "testkern.b" and the corresponding header 
file is "psll.ht1".

If operating properly, it will print
    Hello World:
    32
    good luck when installing

However, the memory requirements of a full PSL are activated with 
this test already.
 
 
In test 2 test the actual PSL kernel "main.b" is loaded and the it 
then tries to load another module "load-psl.b", which tests some
of the kernel routines. On this level only a minimal environment
is available, but the system interface is fully present. The dynamic
operation of this test can be understood by looking to the
source file for this test "make-t2".
 
Please inform us about any modfications which are necessary to
get the packages run. We would like to incorporate them into 
the general distribution versions.

3.2 Test 3
----------

This test generates the bare PSL interpreter, which enables
a (limited) LISP program execution. For that test, PSLL has
to load the nonkernel modules, which reside in the subdirectory
"nonkern". 
 
Please stay in the tests directory all the time. If the machine
has no ARITHMETIC CORPOCESSOR, please move the module
     
     nonkern/arithwoco.b (arithmetic without coprocessor)
        to
     nonkern/arithmetic.b
 
The script "psl" invokes the PSL interpreter. During loading one 
message line from each of the 78 modules is generated. 


If the loading is successfull, the lines
 
   Portable Standard LISP
   1 lisp>
 
appear on the terminal and the LISP interpreter waits for
interactive input. Note that the current directory now points
to "nonkern". You can enter expressions in PSL syntax,
e.g. you can execute the file "source3.sl" by typing in
     
    (rds (open  "../source3.sl" 'input))
 
The .. is needed here, because the directory was changed to ./nonkern
during loading. The main purpose of this file is the testing of 
the error recovery. So several error messages will occur. Please 
reply 
     
     q
 
every time, which then will cause continuation of the file.
As one effect of this file an executable PSL interpreter image is 
saved to the file "sav.img". This image should be executable later
by calling
    
      psll -isav.img
 
A LISP session will be ended  executing of (quit) or with
a ctl-D character. The sript "psl" does this operation as well.

Please check, if the heap enlargement operates by starting psl
from the saved image and the executing
 
      (set-heap-size  nnnnnn)
 
where "nnnnn" is a number greater than the current heap size,
e.g. 1000000. Then two garbage collections take place. If the
enlargement is successfull, the new size is returned; otherwise
the value will be NIL. If not successfull, several reasons can
be responsible. If PSLL reports a problem in the SBRK management,
please try to adjust the sizes of the gaps incorporated in the
psll.c source and redo the installation steps.
 
The script "make-psl.cs" does all steps of compiling, linking and
image creating directly without invoking the tests.

3.3 Test 4
----------
 
This test creates a minimal REDUCE on top of PSL. Therefore change
the current directory to 

      cd rtest

and execute the script
 
      make-reduce.cs
 
which then produces a file "reduce.img". If this image is executed
via
      ../psll -ireduce.img
 
or by the script
 
      reduce
 
the mini REDUCE is started and expects interactive input. 
As usually with REDUCE, all statements have to be separated by
a semicolon and terminated by a return-key. In contrast to the
full REDUCE here only two types of statements are accepted:
 
      bye;       terminates the program
 
      <expr>;    evaluates the (polynomial) expression <expr>
 
where <expr> is limited to a (legal) combination of balanced
brackets, operators +,-,* and **, small integer numbers and
simple variables. E.g. type in
 
      (x + y) ** 10;
 
If all these tests were successfull, it is very probable that
the full REDUCE can be installed without further problems.


Please inform us about any modfications which are necessary to
get the packages run. We would like to incorporate them into
the general distribution versions.
 
4. Installing "bare-psl" and other LISP environments
----------------------------------------------------
 
When the tests are completed successfully, the final installation can
be started. Prerequisits:
 
  - the file tree has been installed
  - the variable MACHINE has been set to
        unix386  resp.  unix68000
  - the file /psl/dist/psl-names has been executed
 
So all necessary files and file names are defined and accessible.
 
Switch to the machine dependent kernel directory
 
      cd $pxk
 
Remove all .o files; the .o files on the distributtion tape were compiled
under SUN-OS and so will not be compatible with the target system.
 
      rm .o
 
Replace those .c files, which were modified during preparation of the test
series.
 
Ensure, that the following binary files have a younger date than their 
corresponding sources, e.g. by executing a touch command:

   binary:                 source:
      kernelout.b              kernelout.sl
      main.b                   all .sl files in $pk and $pxk
      $pl/fasl-decls.b         $pxk/fasl-decls.sl
      $pl/f-strings.b          $pu/f-strings.sl
      $pl/fast-vector.b        $pu/fast-vector.sl
      $pl/hash-decls.b         $pk/hash-decls.sl
      $pl/if-system.b          $pu/if-system.sl
      $pl/s-strings.b          $pu/s-strings.sl
      $pl/sys-consts.b         $pxc/sys-consts.sl
 
If the machine has no arithmetic coprocessor, move the file

      $pxnk/lap/arithwoco.b
   to $pxnk/lap/arithmetic.b

Generate the PSL loader by executing the command 
 
      make
 
Switch to the machine dependent distribution directory
 
      cd $pxdist
 
The script  make-bare-pslin this directory generates an executable LISP 
environment by calling psll, loading the modules in $pnkl and writing a 
SAVESYSTEM image for later restart. The memory layout of the executable
image is defined in this script as parameters to psll. When modirying 
the parameters, take into account, that the heap space should be enlargable
at runtime. For generating the bare psl execute
 
      make-bare-psl
 
Afterwards the bare PSL can be executed via
 
      $psys/bare-psl
 
The other files make-psl and make-pslcomp generate a full psl and a
psl compiler in the same way.
 
Other LISP environments can be installed in the same style. The standard
PSL is created by
 
      make-psl
 
while 
 
      make-pslcomp
 
generates the PSL compiler main program.
 
