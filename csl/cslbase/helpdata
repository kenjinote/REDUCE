\item[Contents]
Help is available on the following

Algebra                 Arithmetic              Booleans
Commands                Declarations            Functions
InputOutput             Library                 Matrix
Operators               Specfns                 Switches
Syntax                  Variables

There are help windows for each of these topics

To select a help page double click on the word in the help window or
use the Help Selection option on the menu.  A backspace/delete will
return to this Index window.

An alphabetical list of all topics follows

.
#
ABS                     ACOS                    ACOSH
ACOT                    ACOTH                   ACSC
ACSCH                   ADJPREC                 ALGEBRAIC
Algebraic mode          ALGINT                  ALGINT(Package)
ALLBRANCH               ALLFAC                  ANTISYMMETRIC
APPEND                  ARBCONST                ARGLENGTH
ARNUM                   ARRAY                   ASEC
ASECH                   ASIN                    ASINH
ATAN                    ATAN2                   ATANH
AVECTOR
BALANCED_MOD            BEGIN...END             BERNOULLI
BESSELI                 BESSELJ                 BESSELK
BESSELY                 BETA                    BFSPACE
BINOMIAL                BOUNDS                  BYE
CARD_NO                 CEILING                 CENTERED_MOD
CHEBYSHEV_FIT           CHEBYSHEVT              CHEBYSHEVU
CLEAR                   CLEARRULES              COEFF
COEFFICIENT             COEFFN                  COFACTOR
COLLECT                 COMBINEEXPT             COMBINELOGS
COMMENT                 COMP                    COMPACT
Compiler                COMPLEX                 CONJ
CONT                    COS                     COSH
COT                     COTH                    CRAMER
CREF                    CSC                     CSCH
DECOMPOSE               DEFINE                  DEFN
DEFPOLY                 DEG                     DEMO
DEN                     DEPEND                  DET
DF                      DFPRINT                 DILOG
DISPLAY                 DIV                     DOT
E                       ECHO                    ED
EDITDEF                 END                     EPS
Equation                ERF                     ERRCONT
EULER                   EULERP                  Euler Numbers
EVAL_MODE               EVALLHSEQP              EVEN
EVENP                   EXCALC                  EXP
EXPAND_CASES            EXPANDLOGS              EXPINT
exterior calc           exterior df             EZGCD
FACTOR                  FACTORIAL               Factorization
FACTORIZE               FAILHARD                FIRST
FIRSTROOT               FIX                     FIXP
FLOOR                   FOR                     FORALL
FOREACH                 FORT                    FORT_WIDTH
FORTRAN                 FREEOF                  FULLPREC
FULLROOTS
G                       GAMMA                   Gamma Function
GC                      GCD                     GEGENBAUERP
GENTRAN                 GosperAlg               
Hankel Functions        HANKEL1                 HANKEL2
HERMITEP                HIGH_POW                HORNER
HYPOT
I                       Identifier              IF
IFACTOR                 IMPART                  IN
Indefinite integration  INDEX                   INFINITY
INFIX                   INPUT                   INT
INTEGER                 INTERPOL                INTSTR
ISOLATER
JACOBIP
KERNEL                  KORDER                  Kummer Functions
KUMMERM                 KUMMERU
LAGUERREP               LCM                     LCOF
LEGENDREP               LENGTH                  LESSSPACE
LET                     LHS                     LIMIT
LIMITEDFACTORS          LINEAR                  LINELENGTH
LISP                    LIST                    List(operation)
LISTARGP                LISTARGS                LN
LOAD_PACKAGE            LOG                     LOGB
Lommel Functions        LOMMEL1                 LOMMEL2
LOW_POW                 LTERM
MAINVAR                 MASS                    MAT
MATCH                   MATEIGEN                MATRIX
MAX                     MCD                     MIN
MKID                    MODULAR                 MSG
MSHELL                  MULTIPLICITIES
NAT                     NERO                    NEXTPRIME
NOARG                   NODEPEND                NOLNR
NONCOM                  NONZERO                 NOSPLIT
NOSPUR                  NOXPND                  NULLSPACE
NUM                     NUMVAL                  NUMBERP
NUM_INT                 NUM_MIN                 NUM_ODESOLVE
NUM_SOLVE
ODD                     ODESOLVE                OFF
ON                      ONE_OF                  OPERATOR
ORDER                   ORDP                    ORTHOVEC
OUT                     OUTPUT                  OVERVIEW
PART                    PAUSE                   PERIOD
PF                      PI                      POCHHAMMER
POLYGAMMA               PRECEDENCE              PRECISE
PRECISION               PRET                    PRI
PRIMEP                  PRINT_PRECISION         PROCEDURE
PROD                    PRODUCT                 PSI
QUIT
RANK                    RAT                     RATARG
RATIONAL                RATIONALIZE             RATPRI
REAL                    REDUCT                  REMAINDER
REMFAC                  REMIND                  REPART
REPEAT                  REST                    RESULTANT
RETRY                   RETURN                  REVERSE
REVPRI                  RHS                     RLISP88
RLROOTNO                ROOT_OF                 ROOT_MULTIPLICITES
ROUND                   ROUNDALL                ROUNDBF
ROUNDED                 Rule_lists
SAVEAS                  SAVESTRUCTR             SCALAR
SCIENTIFIC_NOTATION     SCOPE                   SEC
SECH                    SECOND                  SET
SETMOD                  SHARE                   SHOWRULES
SHOWTIME                SHUT                    SIGN
SIN                     SINH                    SOLVE
SOLVESINGULAR           SPDE                    SPLIT_FIELD
SPUR                    SQRT                    STIRLING1
STIRLING2               String                  STRUCTR
STRUVEH                 STRUVEL                 SUB
SUM                     SYMBOLIC                SYMMETRIC
T                       TAN                     TANH
TAYLOR                  TAYLORAUTOCOMBINE       TAYLORAUTOEXPAND
TAYLORCOMBINE           TAYLORKEEPORIGINAL      TAYLORORIGINAL
TAYLORPRINTORDER        TAYLORPRINTTERMS        TAYLORREVERT
TAYLORSERIESP           TAYLORTEMPLATE          TAYLORTOSTANDARD
THIRD                   TIME                    TP
TPS                     TRACE                   TRALLFAC
TRFAC                   TRIGFORM                TRINT
TRNONLNR
VARNAME                 VECDIM                  VECTOR
WEIGHT                  WHEN                    WHERE
WHILE                   WHITTAKERW              WRITE
WS                      WTLEVEL
XPND
ZETA

\endsection
\item[Algebra]
Algebra Index

Algebraic operators about which there is help are:

APPEND                  ARBINT                  ARBCOMPLEX
ARGLENGTH               COEFF                   COEFFN
CONJ                    DECOMPOSE               DEG
DEN                     DF                      EXPAND_CASES
EXPREAD                 FACTORIZE               HYPOT
IMPART                  INT                     INTERPOL
LCOF                    LENGTH                  LHS
LTERM                   MAINVAR                 NPRIMITIVE
NUM                     PART                    PF
REDUCT                  REPART                  RESULTANT
RHS                     ROOT_OF                 SHOWRULES
SOLVE                   STRUCTR                 SUB
WS

\endsection
\item[Arithmetic]
Arithmetic Index

This section considers operations defined in REDUCE that concern numbers,
or operators that can operate on numbers in addition, in most cases, to
more general expressions.

Arithmetic operations about which there is help are:

ABS                     ADJPREC                 CEILING
DILOG                   FACTORIAL               FIX
FIXP                    FLOOR                   GCD
LN                      LOG                     LOGB
MAX                     MIN                     NEXTPRIME
REMAINDER               ROUND                   SIGN
SQRT

\endsection
\item[Booleans]
Booleans Index

Boolean operations about which there is help are:

EVENP                   FREEOF                  NUMBERP
ORDP                    PRIMEP

\endsection
\item[Commands]
Commands Index

Commands about which there is help are:

BYE                     CONT                    DISPLAY
LOAD_PACKAGE            PAUSE                   QUIT
RETRY                   SAVEAS                  SHOWTIME
WRITE

\endsection
\item[Concepts]
Concepts Index

There is help on the following basic concepts:

Identifier              Kernel                  String

Also there is a simple editor, described by

ED                      EDITDEF

\endsection
\item[Declarations]
Declarations Index

Declarations about which there is help are:

ALGEBRAIC               ANTISYMMETRIC           ARRAY                   
CLEAR                   CLEARRULES              DEFINE                          
DEPEND                  EVEN                    FACTOR                  
FORALL                  INFIX                   INTEGER                 
KORDER                  LET                     LINEAR                  
LINELENGTH              LISP                    LISTARGP                        
MATCH                   NODEPEND                NONCOM                  
NONZERO                 ODD                     OFF
ON                      OPERATOR                ORDER                   
PRECEDENCE              PRECISION               PRINT_PRECISION                 
REAL                    REMFAC                  SCALAR                  
SCIENTIFIC_NOTATION     SHARE                   SYMBOLIC                
SYMMETRIC               VARNAME                 WEIGHT
WHILE                   WTLEVEL                 

\endsection
\item[Functions]
Functions Index

Elementary functions about which there is help are:

ACOS                    ACOSH                   ACOT                    
ACOTH                   ACSC                    ACSCH                   
ASEC                    ASECH                   ASIN                    
ASINH                   ATAN                    ATANH                   
ATAN2                   COS                     COSH                    
COT                     COTH                    CSC                     
CSCH                    ERF                     EXP                     
EXPINT                  SEC                     SECH                    
SIN                     SINH                    TAN                     
TANH

\endsection
\item[HighEnergy]
High Energy Physics Index

The High-energy Physics package is historic for REDUCE, since REDUCE
originated as a program to aid in computations with Dirac expressions.
The commutation algebra of the gamma matrices is independent of their
representation, and is a natural subject for symbolic mathematics.
Dirac theory is applied to beta decay and the computation of
cross-sections and scattering.  The high-energy physics operators are
available in the REDUCE main program, rather than as a module which
must be loaded.

Arithmetic operations about which there is help are:

DOT                     EPS                     G
INDEX                   MASS                    MSHELL
NOSPUR                  REMIND                  SPUR
VECDIM                  VECTOR

\endsection
\item[InputOutput]
Input and Output Index

Input and Output actions about which there is help are:

IN                      INPUT                   OUT
SHUT

\endsection
\item[Library]
Library Index

The external modules that are included in your REDUCE system are the
first members of the REDUCE User's Library.  They have been
contributed by REDUCE users from various fields for the convenience
and pleasure of the REDUCE user community.  Future releases of REDUCE
will include other packages as they are developed.  The packages in
the User's Library are unsupported; any questions or problems should
be directed to their authors.

Each package comes with its own documentation, which you can find,
along with the source code, in the subdirectories lib of you REDUCE
directory (with suffix .txt, .tex and .red).  The LOAD_PACKAGE command
is used to load the files you wish into your system.  There will be a
short delay while the module is loaded.  A module cannot be unloaded.
Once it is in your system, it stays there until you end the session.
Each package also has a test file, which you will find under its name
in the lib directory with suffix .tst.

The following paragraphs, provided by the authors of each module,
briefly introduce packages which have not yet been described in more
detail in other sections of this document.  Please refer to the
documentation for each module for detailed information on its use.
Each of them have their own switches, commands, and operators, and
some redefine special characters to aid in their notation.

Libraries about which there is help are:

ALGINT                  ARNUM                   AVECTOR
COMPACT                 EXCALC                  GENTRAN
NUMERIC                 ODESOLVE                ORTHOVEC
SCOPE                   SPDE                    TPS

\endsection
\item[Matrix]
Matrix Index

Matrix operations about which there is help are:

COFACTOR                DET                     MAT
MATEIGEN                MATRIX                  NULLSPACE
RANK                    TP                      TRACE

\endsection
\item[Operators]
Operators Index

Operations about which there is help are:

LIMIT                   SUM                     PROD

\endsection
\item[Specfns]
Special Functions

The REDUCE Special Function Package supplies extended algebraic and
numeric support for a wide class of objects.  This package is released
together with REDUCE 3.5 (October 1993) for the first time, therefore
it is far from being complete.

The functions included in this package are in most cases (unless
otherwise stated) defined and named like in the book by Abramowitz and
Stegun: Handbook of Mathematical Functions, Dover Publications.

The aim is to collect as much information on the special functions and
simplification capabilities as possible, i.e. algebraic
simplifications and numeric (rounded mode) code, limits of the
functions together with the definitions of the functions, which are in
most cases a power series, a (definite) integral and/or a differential
equation.

What can be found:
  A variety of Bessel functions, special polynomials, the Gamma
function, the Zeta function and integral functions.

What is missing:
  Airy functions, Mathieu functions, LerchPhi, etc..  The information
about the special functions which solve certain differential equation
is very limited.  In several cases numerical approximation is
restricted to real arguments or is missing completely.

The implementation of this package uses REDUCE rule sets to a large
extent, which guarantees a high 'readability' of the functions
definitions in the source file directory. It makes extensions to the
special functions code easy in most cases too. To look at these rules
it may be convenient to use the showrules operator e.g.

        showrules Besseli;

Note: The special function package has to be loaded explicitly by calling
        load_package specfn;

Help is available on:

BERNOUILLI              BESSELI                 BESSELJ
BESSELK                 BESSELY                 BETA
CHEBYSHEVT              CHEBYSHEVU              EULER
EULERP                  GAMMA                   GEGENBAUERP
HANKEL1                 HANKEL2                 HERMITEP
JACOBIP                 KUMMERM                 KUMMERU
LAGUERREP               LEGENDREP               LOMMEL1
LOMMEL2                 POCHHAMMER              POLYGAMMA
PSI                     STIRLING1               STIRLING2
STRUVEH                 STRUVEL                 WHITTAKERW
ZETA

\endsection
\item[Switches]
Switches Index

Switches are set on or off using the commands ON or OFF, respectively.
The default setting of the switches described in this section is
OFF unless stated otherwise. 

Switches about which there is help are:

ALGINT                  ALLBRANCH               ALLFAC                  
BALANCED_MOD            BFSPACE                 COMBINEEXPT
COMBINELOGS             COMP                    COMPLEX                 
CREF                    CRAMER                  DEFN            
DEMO                    DFPRINT                 DIV                     
ECHO                    ERRCONT                 EVALLHSEQP                      
EXP                     EXPANDLOGS              EZGCD                   
FACTOR                  FAILHARD                FORT                    
FULLPREC                FULLROOTS               GC
GCD                     HORNER                  IFACTOR                 
INT                     INTSTR                  LCM                     
LESSSPACE               LIMITEDFACTORS          LIST                    
LISTARGS                MCD                     MODULAR                 
MSG                     MULTIPLICITIES          NAT                     
NERO                    NOARG                   NOLNR                   
NOSPLIT                 NUMVAL                  OUTPUT                  
OVERVIEW                PERIOD                  PRECISE                 
PRET                    PRI                     RAT                     
RATARG                  RATIONAL                RATIONALIZE             
RATPRI                  REVPRI                  RLISP88                 
ROUNDALL                ROUNDBF                 ROUNDED                 
SAVESTRUCTR             SOLVESINGULAR           TIME                    
TRALLFAC                TRFAC                   TRIGFORM        
TRINT                   TRNONLNR

\endsection
\item[Syntax]
Syntax Index

Syntax about which there is help are:

BEGIN...END             COMMENT                 CONS
END                     EQUATION                FIRST
FOR                     FOREACH                 GOTO
IF                      List                    PROCEDURE
REPEAT                  REST                    RETURN
REVERSE                 RuleSet                 SECOND
SET                     THIRD                   WHEN

\endsection
\item[Variables]
Variables Index

Variables about which there is help are:

CARD_NO                 E                       EVAL_MODE               
FORT_WIDTH              HIGH_POW                I
INFINITY                LOW_POW                 NIL
PI                      ROOT_MULTIPLICITIES     T

\endsection
\xitem[><]
>< 3-D vector and diphthong                             (page  356)

\endsection
\xitem[*]
*
      3-D vector, 356
      algebraic numbers, 224
      power series, 422
      vector, 232

\endsection
\xitem[**]
** 
      power series, 422

\endsection
\xitem[+]
+ 
      3-D vector, 356
      algebraic numbers, 223
      power series, 422
      vector, 232

\endsection
\xitem[-]
- 
      3-D vector, 356
      power series, 422
      vector, 232

\endsection
\item[.]
. (CONS)                                                (page  50)

The CONS operator adds a new element to the beginning of a LIST.  Its
operation is identical to the symbol DOT (dot).  It can be used
infix or prefix.

        CONS(item,list) or item CONS list

item can be any REDUCE scalar expression, including a list; list
must be a list.

Examples:

liss := cons(a,{b});                 {A,B}

liss := c cons liss;                 {C,A,B}

newliss := for each y in liss collect cons(y,list x);
                                     NEWLISS := {{C,X},{A,X},{B,X}}

for each y in newliss sum (first y)*(second y);
                                     X*(A + B + C)

If you want to use CONS to put together two elements into a new list,
you must make the second one into a list with curly brackets or the
LIST command.  You can also start with an empty list created by {}.

The CONS operator is right associative: A CONS B CONS C is valid if C
is a list; B need not be a list.  The list produced is {A,B,C}.

\endsection
\xitem[/]
/ 
      3-D vector, 356
      algebraic numbers, 224
      power series, 422
      vector, 232

\endsection
\xitem[@]
@ 
      partial differentiation, 271
      tangent vector, 271

\endsection
\xitem[@ operator]
@ operator, 251

\endsection
\item[#]
#                                                       (pages  256, 271)

# is the syntax for the Hodge-* operator in the EXCALC package.

\endsection
\xitem[^]
^
      3-D vector, 356
      exterior multiplication, 250, 271

\endsection
\item[ABS]
ABS                                                     (page 72)
The ABS operator returns the absolute value of its argument.

ABS(expression)

expression can be any REDUCE scalar expression.

Examples:
abs(-a);                           ABS(A) 
abs(-5);                            5 
a := -10;                           A := -10 
abs(a);                             10 
abs(-a);                            10

If the argument has had no numeric value assigned to it, such as an
identifier or polynomial, ABS returns an expression involving
ABS of its argument, doing as much simplification of the argument
as it can, such as dropping any preceding minus sign.

\endsection
\item[ACOS]
ACOS                                                    (pages 76, 78)

The ACOS operator returns the arccosine of its argument.

        ACOS(expression) or ACOS simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
acos(ab);                            ACOS(AB)
acos 15;                             ACOS(15)
                                               2  2
                                      SQRT( - X *Y  + 1)*Y
df(acos(x*y),x);                     ----------------------
                                            2  2
                                           X *Y  - 1
on rounded;
res := acos(sqrt(2)/2);              RES := 0.785398163397
res-pi/4;                            0

An explicit numeric value is not given unless the switch ROUNDED is
on and the argument has an absolute numeric value less than or equal to 1.

\endsection
\item[ACOSH]
ACOSH                                                   (pages 76, 78)

ACOSH represents the hyperbolic arccosine of its argument.  It takes
an arbitrary scalar expression as its argument. The derivative of
ACOSH is known to the system.  Numerical values may also be found by
turning on the switch ROUNDED.

        ACOSH(expression) or ACOSH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix or
vector expression.  simple_expression must be a single identifier or
begin with a prefix operator name.

Examples:
acosh a;                          ACOSH(A) 
acosh(0);                         ACOSH(0) 
                                                   4
                                   2*SQRT(A  - 1)*A
df(acosh(a**2),a);                ------------------
                                         4
                                        A  - 1

int(acosh(x),x);                  INT(ACOSH(X),X)

You may attach functionality by defining ACOSH to be the inverse of
COSH.  This is done by the commands
        put('cosh,'inverse,'acosh);
        put('acosh,'inverse,'cosh);
You can write a procedure to attach integrals or other functions to
ACOSH.  You may wish to add a check to see that its argument is
properly restricted.

\endsection
\item[ACOT]
ACOT                                                    (pages 76, 78)

ACOT represents the arccotangent of its argument.  It takes an
arbitrary scalar expression as its argument. The derivative of ACOT is
known to the system.  Numerical values may also be found by turning on
the switch ROUNDED.

        ACOT(expression) or ACOT simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.  You can add functionality
yourself with LET and procedures.

Examples:
acot a;                           ACOT(A) 
                                   PI
acot(0);                          ----
                                   2

                                    - 2*A
df(acot(a**2),a);                 --------
                                    4
                                   A  + 1

                                                      2
                                   2*ACOT(X)*X + LOG(X  + 1)
int(acot(x),x);                   ---------------------------
                                               2
on rounded;
acot(1);                          0.785398163397

\endsection
\item[ACOTH]
ACOTH                                                   (pages 76, 78)

ACOTH represents the inverse hyperbolic cotangent of its argument.  It
takes an arbitrary scalar expression as its argument.  The derivative
of ACOTH is known to the system.  Numerical values may also be found
by turning on the switch ROUNDED.

        ACOTH(expression) or ACOTH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression. simple_expression must be a single identifier or
begin with a prefix operator name.  You can add functionality yourself
with LET and procedures.

Examples:
acoth(0);                               0

                                          - 2*X
df(acoth(x^2),x);                       --------
                                          4
                                         X  - 1

int(acoth(x),x);                        ACOTH(X)*X + ACOTH(X) + LOG(X - 1)

\endsection
\item[ACSC]
ACSC                                                    (pages 76, 78)

The ACSC operator returns the arccosecant of its argument.

        ACSC(expression) or ACSC simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
acsc(ab);                            ACSC(AB) 
acsc 15;                             ACSC(15) 
                                               2  2
                                       - SQRT(X *Y  - 1)
df(acsc(x*y),x);                     --------------------
                                            2  2
                                        X*(X *Y  - 1)
on rounded; 
res := acsc(2/sqrt(3));              RES := 1.0471975512 
res-pi/3;                            0

An explicit numeric value is not given unless the switch ROUNDED is on
and the argument has an absolute numeric value less than or equal to
1.

\endsection
\item[ACSCH]
ACSCH                                                   (pages 76, 78)

The ACSCH operator returns the hyperbolic arccosecant of its argument.

        ACSCH(expression) or ACSCH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
acsch(ab);                           ACSCH(AB) 
acsch 15;                            ACSCH(15) 
                                               2  2
                                       - SQRT(X *Y  + 1)
df(acsch(x*y),x);                    --------------------
                                            2  2
                                        X*(X *Y  + 1)
on rounded; 
res := acsch(3);                     RES := 0.327450150237

An explicit numeric value is not given unless the switch ROUNDED is on
and the argument has an absolute numeric value less than or equal to
1.

\endsection
\item[ADJPREC]
ADJPREC                                                 (page 133)

When a real number is input, it is normally truncated to the PRECISION
in effect at the time the number is read.  If it is desired to keep
the full precision of all numbers input, the switch ADJPREC (for
adjust precision) can be turned on.  While on, ADJPREC will
automatically increase the precision, when necessary, to match that of
any integer or real input, and a message printed to inform the user of
the precision increase.

Examples:
on rounded;
1.23456789012345;                       1.23456789012
on adjprec;
1.23456789012345;                       *** precision increased to 15
                                        1.23456789012345

\endsection
\item[ALGEBRAIC]
ALGEBRAIC                                               (page 191)

The ALGEBRAIC command changes REDUCE's mode of operation to
algebraic.  When ALGEBRAIC is used as an operator (with an argument
inside parentheses) that argument is evaluated in algebraic mode, but
REDUCE's mode is not changed.

Examples:
algebraic;
symbolic;                                     NIL
                                               2
algebraic(x**2);                              X
x**2;                                         ***** The symbol X has no value.

REDUCE's symbolic mode does not know about most algebraic commands.
Error messages in this mode may also depend on the particular Lisp
used for the REDUCE implementation.

\endsection
\item[Algebraic mode]
Algebraic mode                                          (pages 191, 197, 198)

Most REDUCE calculatuons take place in Algebraic mode.  The
alternative is Symbolic mode, which is a syntactic form of LISP.  See
the commands ALGEBRAIC and SYMBOLIC for mor details.

\endsection
\item[ALGINT]
ALGINT

When the ALGINT switch is on, the algebraic integration module (which
must be loaded from the REDUCE library) is used for integration.

Loading ALGINT from the library automatically turns on the
ALGINT switch.  An error message will be given if ALGINT is
turned on when the ALGINT has not been loaded from the library.

\endsection
\item[ALGINT(Package)]
ALGINT(Package)                                         (page 178)

Author: James H. Davenport

The ALGINT package provides indefinite integration of square roots.
This package, which is an extension of the basic integration package
distributed with REDUCE, will analytically integrate a wide range of
expressions involving square roots.  The ALGINT switch provides for
the use of the facilities given by the module, and is automatically
turned on when the package is loaded.  If you want to return to the
standard integration algorithms, turn ALGINT off.  An error message is
given if you try to turn the ALGINT switch on when its module is not
loaded.

\endsection
\item[ALLBRANCH]
ALLBRANCH                                               (page 89)

When ALLBRANCH is on, the operator SOLVE selects all branches of
solutions. When ALLBRANCH is off, it selects only the principal
branches.  Default is ON.

Examples:

solve(log(sin(x+3)),x);    {X=2*ARBINT(1)*PI - ASIN(1) - 3,
                            X=2*ARBINT(1)*PI + ASIN(1) + PI - 3}
off allbranch;
solve(log(sin(x+3)),x);    {X=ASIN(1) - 3}

ARBINT(1) indicates an arbitrary integer, which is given a unique
identifier by REDUCE, showing that there are infinitely many solutions
of this type.  When ALLBRANCH is off, the single canonical solution is
given.

\endsection
\item[ALLFAC]
ALLFAC                                                  (pages 102, 104)

The ALLFAC switch, when on, causes REDUCE to factor out automatically
common products in the output of expressions.  Default is ON.

Examples:                                       3
x + x*y**3 + x**2*cos(z);        X*(COS(Z)*X + Y  + 1)
off allfac; 
                                         2     3
x + x*y**3 + x**2*cos(z);        COS(Z)*X + X*Y  + X

The ALLFAC switch has no effect when PRI is off.  Although the switch
setting stays as it was, printing behaviour is as if it were off.

\endsection
\xitem[ansatz of symmetry generator]
ansatz of symmetry generator, 386

\endsection
\item[ANTISYMMETRIC]
ANTISYMMETRIC                                           (page 93)

When an operator is declared ANTISYMMETRIC, its arguments are
reordered to conform to the internal ordering of the system.  If an
odd number of argument interchanges are required to do this ordering,
the sign of the expression is changed.

        ANTISYMMETRIC identifier {,identifier}

identifier is an identifier that has been declared as an operator.

Examples:
operator m,n;
antisymmetric m,n;
m(x,n(1,2));                        - M( - N(2,1),X)
operator p;
antisymmetric p;
p(a,b,c);                             P(A,B,C) 
p(b,a,c);                           - P(A,B,C)

If identifier has not been declared an operator, the flag
ANTISYMMETRIC is still attached to it.  When identifier is
subsequently used as an operator, the message
 Declare identifier operator? (Y or N)
is printed.  If the user replies Y, the antisymmetric property of the
operator is used.

Note in the first example, identifiers are customarily ordered
alphabetically, while numbers are ordered from largest to smallest.
The operators may have any desired number of arguments (less than 128).

\endsection
\item[APPEND]
APPEND                                                  (page 50)

The APPEND operator constructs a new list from the elements of its two
arguments (which must be lists).

        APPEND(lst,lst)

lst must be a list, though it may be the empty list ({}).  Any
arguments beyond the first two are ignored.

Examples:
alist := {1,2,{a,b}};            ALIST := {1,2,{A,B}}
blist := {3,4,5,sin(y)};         BLIST := {3,4,5,SIN(Y)}
append(alist,blist);             {1,2,{A,B},3,4,5,SIN(Y)}
append(alist,{});                {1,2,{A,B}}
append(list z,blist);            {Z,3,4,5,SIN(Y)}

Comment The new list consists of the elements of the second list
appended to the elements of the first list.  You can append new
elements to the beginning or end of an existing list by putting the
new element in a list (use curly braces or the operator list).  This
is particularly helpful in an iterative loop.

\endsection
\item[ARBCONST]
ARBCONST operator                                       (page 350)

See the ODESOLVE package

\endsection
\xitem[arbitrary ordering]
arbitrary ordering, 316

\endsection
\item[ARGLENGTH]
ARGLENGTH                                               (page 117)
The operator ARGLENGTH returns the number of arguments of the top-level
operator in its argument.

        ARGLENGTH(expression)

expression can be any valid REDUCE algebraic expression.

Examples:
arglength(a + b + c + d);                                   4
arglength(a/b/c);                                           2
arglength(log(sin(df(r**3*x,x))));                          1

In the first example, + is an n-ary operator, so the number of terms
is returned.  In the second example, since / is a binary operator, the
argument is actually (a/b)/c, so there are two terms at the top level.
In the last example, no matter how deeply the operators are nested,
there is still only one argument at the top level.

\endsection
\item[ARNUM]
ARNUM                                                   (pages 179, 223)
Author: Eberhard Schruefer

This package provides facilities for handling algebraic numbers as polynomial
coefficients in REDUCE calculations.  It includes facilities for introducing
indeterminates to represent algebraic numbers, for calculating splitting
fields, and for factoring and finding greatest common divisors in such
domains.

\endsection
\item[ARRAY]
ARRAY                                                   (page 67)

The ARRAY declaration declares a list of identifiers to be of type
ARRAY, and sets all their entries to 0.

        ARRAY identifier(dimensions){,identifier(dimensions)}

identifier may be any valid REDUCE identifier.  If the identifier
was already an array, a warning message is given that the array has been
redefined.  dimensions are of form
 integer{,integer}.

array a(2,5),b(3,3,3),c(200);  
array a(3,5);                   *** ARRAY A REDEFINED
a(3,4);                         0
length a;                       {4,6}

Arrays are always global, even if defined inside a procedure or block
statement.  Their status as an array remains until the variable is
reset by CLEAR.  Arrays may not have the same names as operators,
procedures or scalar variables.

Array elements are referred to by the usual notation: A(I,J) returns
the jth element of the ith row.  The ASSIGNment operator := is used to
put values into the array.  Arrays as a whole cannot be subject to
assignment by LET or := ; the assignment operator := is only valid for
individual elements.

When you use LET on an array element, the contents of that element
become the argument to LET.  Thus, if the element contains a number or
some other expression that is not a valid argument for this command,
you get an error message.  If the element contains an identifier, the
identifier has the substitution rule attached to it globally.  The
same behaviour occurs with CLEAR.  If the array element contains an
identifier or simple_expression, it is cleared.  Do NOT use CLEAR to
try to set an array element to 0.  Because of the side effects of
either LET or CLEAR, it is unwise to apply either of these to array
elements.

Array indices always start with 0, so that the declaration ARRAY A(5)
sets aside 6 units of space, indexed from 0 through 5, and initialises
them to 0.  The LENGTH command returns a list of the true number of
elements in each dimension.

\endsection
\item[ASEC]
ASEC                                                    (pages 76, 78)

The ASEC operator returns the arccosecant of its argument.

        ASEC(expression) or ASEC simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
asec(ab);                            ASEC(AB) 
asec 15;                             ASEC(15) 
                                            2  2
                                      SQRT(X *Y  - 1)
df(asec(x*y),x);                     -----------------
                                           2  2
                                       X*(X *Y  - 1)
on rounded; 
res := asec sqrt(2);                 RES := 0.785398163397 
res-pi/4;                            0

An explicit numeric value is not given unless the switch ROUNDED is
on and the argument has an absolute numeric value greater or equal to 1.

\endsection
\item[ASECH]
ASECH                                                   (pages 76, 78)

ASECH represents the hyperbolic arccosecant of its argument.  It takes
an arbitrary scalar expression as its argument. The derivative of
ASECH is known to the system.  Numerical values may also be found by
turning on the switch ROUNDED.

        ASECH(expression) or ASECH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
asech a;                          ASECH(A) 
asech(1);                         0 
                                           4
                                   2*SQRT(A  - 1)*A
df(acosh(a**2),a);                ------------------
                                         4
                                        A  - 1
int(asech(x),x);                 INT(ASECH(X),X)

You may attach functionality by defining ASECH to be the inverse of
SECH.  This is done by the commands
        put('sech,'inverse,'asech);
        put('asech,'inverse,'sech);
You can write a procedure to attach integrals or other functions to
ASECH.  You may wish to add a check to see that its argument is
properly restricted.

\endsection
\item[ASIN]
ASIN                                                    (pages 76, 78)

The ASIN operator returns the arcsine of its argument.

        ASIN(expression) or ASIN simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
asin(givenangle);                ASIN(GIVENANGLE) 
asin(5);                         ASIN(5) 
                                                  2
                                   - 2*SQRT( - 4*X  + 1)
df(asin(2*x),x);                 ------------------------
                                            2
                                         4*X  - 1
on rounded; 
asin .5;                         0.523598775598 
asin(sqrt(3));                   ASIN(1.73205080757) 
asin(sqrt(3)/2);                 1.04719755120 

A numeric value is not returned by ASIN unless the switch
ROUNDED is on and its argument has an absolute value less than or
equal to 1.

\endsection
\item[ASINH]
ASINH                                                   (pages  76, 78)

The ASINH operator returns the hyperbolic arcsine of its argument.
The derivative of ASINH and some simple transformations are known
to the system.

        ASINH(expression) or ASINH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
asinh d;                          ASINH(D) 
asinh(1);                         ASINH(1) 
                                             2
                                   2*SQRT(4*X  + 1)
df(asinh(2*x),x);                 ------------------
                                          2
                                       4*X  + 1

You may attach further functionality by defining ASINH to be the
inverse of SINH.  This is done by the commands
        put('sinh,'inverse,'asinh);
        put('asinh,'inverse,'sinh);

A numeric value is not returned by ASINH unless the switch ROUNDED is
on and its argument evaluates to a number.

\endsection
\xitem[Assignment]
Assignment, 54, 55, 57, 63, 195, 198

\endsection
\item[Asymptotic command]
Asymptotic command                                      (pages 139, 151)

See WEIGHT and WTLEVEL

\endsection
\item[ATAN]
ATAN                                                    (pages 76, 78, 81)

The ATAN operator returns the arctangent of its argument.

        ATAN(expression) or ATAN simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
atan(middle);                          ATAN(MIDDLE) 
on rounded; 
atan 45;                               1.54857776147 
off rounded; 
                                                           2
                                        2*ATAN(X)*X - LOG(X  + 1)
int(atan(x),x);                        ---------------------------
                                                    2
                                         2*Y
df(atan(y**2),y);                      --------
                                          4
                                        Y  + 1

A numeric value is not returned by ATAN unless the switch ROUNDED is
on and its argument evaluates to a number.

\endsection
\item[ATAN2]
ATAN2                                                   (pages 76, 78)

        ATAN2(expression,expression)

expression is any valid scalar REDUCE expression.  In ROUNDED mode, if
a numerical value exists, ATAN2 returns the principal value of the arc
tangent of the second argument divided by the first in the range
[-pi,+pi] radians, using the signs of both arguments to determine the
quadrant of the return value.  An expression in terms of ATAN2 is
returned in other cases.

Examples:
atan2(3,2);                          ATAN2(3,2); 
on rounded; 
atan2(3,2);                          0.982793723247 
atan2(a,b);                          ATAN2(a,b); 
atan2(1,0);                          1.57079632679

ATAN2 returns a numeric value only if ROUNDED is on. Then the
arctangent is calculated to the current degree of floating point precision.

\endsection
\item[ATANH]
ATANH                                                   (pages 76, 78)

The ATANH operator returns the hyperbolic arctangent of its argument.
The derivative of ASINH and some simple transformations are known
to the system.

        ATANH(expression) or ATANH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression.  simple_expression must be a single identifier
or begin with a prefix operator name.

Examples:
atanh aa;                         ATANH(AA) 
atanh(1);                         ATANH(1) 
                                      - X
df(atanh(x*y),y);                 -----------
                                    2  2
                                   X *Y  - 1

A numeric value is not returned by ASINH unless the switch ROUNDED is
on and its argument evaluates to a number.  You may attach additional
functionality by defining ATANH to be the inverse of TANH.  This is
done by the commands
        put('tanh,'inverse,'atanh);
        put('atanh,'inverse,'tanh);

\endsection
\xitem[AVEC function]
AVEC function, 232

\endsection
\item[AVECTOR]
AVECTOR                                                 (pages  179, 231)

Author:  David Harper

A Vector Algebra and Calculus Package.

This  package provides  REDUCE  with the  ability  to perform  vector
algebra  using the  same  notation  as scalar  algebra.    The  basic
algebraic  operations  are  supported,  as  are  differentiation  and
integration  of  vectors with  respect  to  scalar  variables,  cross
product and  dot product, component  manipulation and application  of
scalar  functions (e.g.    cosine)  to  a vector  to  yield a  vector
result.

\endsection
\item[BALANCED_MOD]
BALANCED_MOD

MODULAR numbers are normally produced in the range [0,...n), where
n is the current modulus.  With BALANCED_MOD on, the range
[-n/2,n/2] is used instead.

Examples:
        setmod 7;                1
        on modular;
        4;                       4
        on balanced_mod;
        4;                       -3

\endsection
\item[BEGIN...END]
BEGIN ... END                                           (pages 61, 62, 64)

BEGIN is used to start a BLOCK statement, which is closed with END.

        BEGIN statement{; statement} END

statement is any valid REDUCE statement.

Examples:
        begin for i := 1:3 do write i end;      1
                                                2
                                                
begin scalar n;n:=1;b:=for i:=1:4 product(x-i);return n end;
                                                1
                                                 4       3       2
b;                                              X  - 10*X  + 35*X  - 50*X  + 24

A BEGIN...END block can do actions (such as WRITE), but does not
return a value unless instructed to by a RETURN statement, which must
be the last statement executed in the block.  It is unnecessary to
insert a semicolon before the END.

Local variables, if any, are declared in the first statement
immediately after BEGIN, and may be defined as SCALAR, INTEGER, or
REAL.  ARRAY variables declared within a BEGIN...END block are global
in every case, and LET statements have global effects.  A LET
statement involving a formal parameter affects the calling parameter
that corresponds to it.  LET statements involving local variables make
global assignments, overwriting outside variables by the same name or
creating them if they do not exist.  You can use this feature to
affect global variables from procedures, but be careful that you do
not do it inadvertently.

\endsection
\item[BERNOULLI]
BERNOULLI                                               (pages 185, 393)
[Part of SPECFN package]

The BERNOULLI operator returns the nth Bernoulli number.

        BERNOULLI(integer)

Examples:
load_package specfn;                    (SPECFN)

                                          - 174611
bernoulli 20;                           -----------
                                            330

bernoulli 17;                           0

All Bernoulli numbers with odd indices except for 1 are zero.

The BERNOULLIP operator returns the nth Bernoulli Polynomial evaluated
at x.

        BERNOULLIP(integer,expression)

Examples:
load_package specfn;                    (SPECFN)

                                       2
                                 Z*(2*Z  - 3*Z + 1)
BernoulliP(3,z);                --------------------
                                         2

                                 338585
BernoulliP(10,3);               --------
                                   66

The value of the nth Bernoulli Polynomial at 0 is the nth Bernoulli number.

\endsection
\item[BESSELI]
BESSELI                                                 (pages 185, 396)
[Part of SPECFN package]

The BESSELI operator returns the modified Bessel function I.

        BESSELI(order,argument)

Examples:
load_package specfn;                    (SPECFN)
on rounded;
Besseli (1,1);                          0.565159103992

The knowledge about the operator BESSELI is currently fairly limited.

\endsection
\item[BESSELJ]
BESSELJ                                                 (pages 185, 396)
[Part of SPECFN package]

The BESSELJ operator returns the Bessel function of the first kind.

        BESSELJ(order,argument)

Examples:
load_package specfn;                   (SPECFN)
BesselJ(1/2,pi);                       0 
on rounded;
BesselJ(0,1);                          0.765197686558  

\endsection
\item[BESSELK]
BESSELK                                                 (pages 185, 396)
[Part of SPECFN package]

The BESSELK operator returns the modified Bessel function K.

        BESSELK(order,argument)

Examples:
load_package specfn;                   (SPECFN)
df(besselk(0,x),x);                    - BESSELK(1,X)

There is currently no numeric support for the operator BesselK.

\endsection
\item[BESSELY]
BESSELY                                                 (pages 185, 396)
[Part of SPECFN package]

The BESSELY operator returns the Bessel function of the second kind.
        BESSELY(order,argument)

Examples:
load_package specfn;                 (SPECFN)
Bessely (1/2,pi);                    - SQRT(2) / PI 
on rounded; 
Bessely (1,3);                        0.324674424792

The operator BESSELY is also called Weber's function.

\endsection
\item[BETA]
BETA                                                    (pages 185, 397)
[Part of SPECFN package]

The BETA operator returns the Beta function defined by

   Beta (z,w) := defint(t**(z-1)* (1 - t)**(w-1),t,0,1)  .


        BETA(expression,expression)


Examples:
load_package specfn;              (SPECFN)
Beta(2,2);                        1 / 6
Beta(x,y);                        GAMMA(X)*GAMMA(Y) / GAMMA(X + Y)

The operator BETA is simplified towards the GAMMA operator.

\endsection
\item[BFSPACE]
BFSPACE                                                 (page 133)

Floating point numbers are normally printed in a compact notation
(either fixed point or in scientific notation if SCIENTIFIC_NOTATION
has been used).  In some (but not all) cases, it helps
comprehensibility if spaces are inserted in the number at regular
intervals.  The switch BFSPACE, if on, will cause a blank to be
inserted in the number after every five characters.

Examples:
        on rounded;
        1.2345678;              1.2345678
        on bfspace;
        1.2345678;              1.234 5678

BFSPACE is normally off.

\endsection
\item[BINOMIAL]
BINOMIAL                                                        (page 185)

The BINOMIAL operator returns the Binomial coefficient if both
parameter are integer and expressions involving the Gamma function otherwise.

        BINOMIAL(integer,integer)

Examples:
Binomial(49,6);                 13983816

                                  GAMMA(N + 1)
Binomial(n,3);                  ----------------
                                 6*GAMMA(N - 2)

The operator BINOMIAL evaluates the Binomial coefficients from the
explicit form and therefore it is not the best algorithm if you want
to compute many binomial coefficients with big indices in which case a
recursive algorithm is preferable.

\endsection
\xitem[Block]
Block, 61, 64

\endsection
\xitem[BNDEQ!*]
BNDEQ!*, 257

\endsection
\xitem[Boolean]
Boolean, 45

\endsection
\item[BOUNDS]
BOUNDS                                                  (page 182)

Upper and lower bounds of a real valued function over an INTERVAL or a
rectangular multivariate domain are computed by the operator
BOUNDS. The algorithmic basis is the computation with inequalities:
starting from the interval(s) of the variables, the bounds are
propagated in the expression using the rules for inequality
computation. Some knowledge about the behavior of special functions
like ABS, SIN, COS, EXP, LOG, fractional exponentials etc. is
integrated and can be evaluated if the operator bounds is called with
rounded mode on (otherwise only algebraic evaluation rules are
available).
 
If BOUNDS finds a singularity within an interval, the evaluation is
stopped with an error message indicating the problem part of the
expression.
 
  BOUNDS(exp,var=(l .. u) [,var=(l .. u) ...])
  BOUNDS(exp,{var=(l .. u) [,var=(l .. u) ...]})

where exp is the function to be investigated, var are the variables of
exp, l and u specify the area as set of INTERVAL s.

BOUNDS computes upper and lower bounds for the expression in the given
area. An INTERVAL is returned.
 
Examples:
        bounds(sin x,x=(1 .. 2));               - 1 .. 1
        on rounded;
        bounds(sin x,x=(1 .. 2));               0.84147098481 .. 1
        bounds(x**2+x,x=(-0.5 .. 0.5));         - 0.25 .. 0.75

\endsection
\xitem[BROEBFULLREDUCTION]
BROEBFULLREDUCTION, 303

\endsection
\xitem[Buchberger's Algorithm]
Buchberger's Algorithm, 292, 295

\endsection
\item[BYE]
BYE                                                     (page 70)

The BYE command ends the REDUCE session, returning control to the
program (e.g., the operating system) that called REDUCE.  When you are
at the top level, the BYE command exits REDUCE. QUIT is a synonym for
BYE.

\endsection
\xitem[C(I)]
C(I), 379

\endsection
\xitem[Call by value]
Call by value, 171, 173

\endsection
\xitem[Canonical form]
Canonical form, 97

\endsection
\item[CARD_NO]
CARD_NO                                                 (page 108)

CARD_NO sets the total number of cards allowed in a Fortran
output statement when FORT is on.  Default is 20.

Examples:
on fort;
card_no := 4;             CARD_NO=4.
z := (x + y)**15;            
                          ANS1=5005.*X**6*Y**9+3003.*X**5*Y**10+1365.*X**4*Y**
                         . 11+455.*X**3*Y**12+105.*X**2*Y**13+15.*X*Y**14+Y**15
                          Z=X**15+15.*X**14*Y+105.*X**13*Y**2+455.*X**12*Y**3+ 
                         . 1365.*X**11*Y**4+3003.*X**10*Y**5+5005.*X**9*Y**6+
                         . 6435.*X**8*Y**7+6435.*X**7*Y**8+ANS1

Twenty total cards means 19 continuation cards.  You may set it for
more if your Fortran system allows more.  Expressions are broken apart
in a Fortran-compatible way if they extend for more than CARD_NO
continuation cards.

\endsection
\xitem[cartesian coordinates]
cartesian coordinates, 354

\endsection
\item[CEILING]
CEILING                                                 (page 72)

        CEILING(expression)

This operator returns the ceiling (i.e., the least integer greater
than or equal to its argument) if its argument has a numerical value.
For negative numbers, this is equivalent to FIX.  For non-numeric
arguments, the value is an expression in the original operator.

Examples:
ceiling 3.4;             4 
fix 3.4;                 3 
ceiling(-5.2);           -5 
fix(-5.2);               -5 
ceiling a;               CEILING(A)

\endsection
\item[CENTERED_MOD]
CENTERED_MOD                                            (page 134)

This is an error in the Reduce manual.  It should be BALANCED_MOD.
For more information select that entry.

\endsection
\xitem[chain rule]
chain rule, 254

\endsection
\xitem[Character set]
Character set, 33

\endsection
\item[Chebyshev_fit]
Chebyshev fit                                           (page 182)

The operator family CHEBYSHEV_... implements approximation and
evaluation of functions by the Chebyshev method.  Let T(n,a,b,x) be
the Chebyshev polynomial of order n transformed to the interval (a,b).
Then a function f(x) can be approximated in (a,b) by a series

  for i := 0:n sum c(i)*T(i,a,b,x)

The operator CHEBYSHEV_FIT computes this approximation and returns a
list, which has as first element the sum expressed as a polynomial and
as second element the sequence of Chebyshev coefficients.

CHEBYSHEV_DF and CHEBYSHEV_INT transform a Chebyshev coefficient list
into the coefficients of the corresponding derivative or integral
respectively.  For evaluating a Chebyshev approximation at a given
point in the basic interval the operator CHEBYSHEV_EVAL can be used.

CHEBYSHEV_EVAL is based on a recurrence relation which is in general
more stable than a direct evaluation of the complete polynomial.

   CHEBYSHEV_FIT(fcn,var=(lo .. hi),n)

   CHEBYSHEV_EVAL(coeffs,var=(lo .. hi), var=pt)

   CHEBYSHEV_DF(coeffs,var=(lo .. hi))

   CHEBYSHEV_INT(coeffs,var=(lo .. hi))


where fcn is an algebraic expression (the target function), var is the
variable of fcn, lo and hi are numerical real values which describe an
INTERVAL lo < hi, the integer n is the approximation order (set to 20
if missing), pt is a number in the interval and coeffs is a series of
Chebyshev coefficients.

Examples:

on rounded;
w:=chebyshev_fit(sin x/x,x=(1 .. 3),5);
                               3                   2
        W := {0.0382345446975*X  - 0.239802588672*X  + 0.0651206939005*X

               + 0.977836217464,

              {0.899091895826,-0.406599215895,-0.00519766024352,0.00946374143

               079,-0.0000948947435875}}

chebyshev_eval(second w, x=(1 .. 3), x=2.1);
        0.411091086819

\xitem[Chebyshev Polynomials]
Chebyshev Polynomials, 185

\endsection
\item[CHEBYSHEVT]
CHEBYSHEVT                                              (page 185)

The CHEBYSHEVT operator computes the nth Chebyshev T Polynomial (of the
first kind).

CHEBYSHEVT(integer,expression)

Examples:
load_package specfn;                 (SPECFN)
                                             2
ChebyshevT(3,xx);                    XX*(4*XX  - 3)

ChebyshevT(3,4);                     244

Chebyshev's T polynomials are computed using the recurrence relation:

ChebyshevT(n,x) := 2x*ChebyshevT(n-1,x) - ChebyshevT(n-2,x)  with 
ChebyshevT(0,x) := 0 and ChebyshevT(1,x) := x

\endsection
\item[CHEBYSHEVU]
CHEBYSHEVU                                              (page 185)

The CHEBYSHEVU operator returns the nth Chebyshev U Polynomial (of the
second kind).

CHEBYSHEVU(integer,expression)

Examples:
load_package specfn;               (SPECFN)
                                           2
ChebyshevU(3,xx);                  4*X*(2*X  - 1)

ChebyshevU(3,4);                   496

Chebyshev's U polynomials are computed using the recurrence relation:

ChebyshevU(n,x) := 2x*ChebyshevU(n-1,x) - ChebyshevU(n-2,x)  with
ChebyshevU(0,x) := 0 and ChebyshevU(1,x) := 2x

\endsection
\item[CLEAR]
CLEAR                                                   (pages 142, 146)

The CLEAR command is used to remove assignments or remove substitution
rules from any expression.

CLEAR identifier{,identifier} or
  let-type statement CLEAR identifier

identifier can be any SCALAR, MATRIX, or ARRAY variable or PROCEDURE
name.  let-type statement can be any general or specific LET statement
(see below).

Examples:
array a(2,3);
a(2,2) := 15;                             A(2,2) := 15 
clear a;                     
a(2,2);                                   Declare A operator? (Y or N)
let x = y + z; 
sin(x);                                   SIN(Y + Z)
clear x;
sin(x);                                   SIN(X)
let x**5 = 7;
clear x;
x**5;                                     7
clear x**5;
                                           5
x**5;                                     X

Although it is not a good idea, operators of the same name but taking
different numbers of arguments can be defined.  Using a CLEAR
statement on any of these operators clears every one with the same
name, even if the number of arguments is different.

The CLEAR command is used to ``forget'' matrices, arrays, operators
and scalar variables, returning their identifiers to the pristine
state to be used for other purposes.  When CLEAR is applied to array
elements, the contents of the array element becomes the argument for
CLEAR.  Thus, you get an error message if the element contains a
number, or some other expression that is not a legal argument to
CLEAR.  If the element contains an identifier, it is cleared.  When
clear is applied to matrix elements, an error message is returned if
the element evaluates to a number, otherwise there is no effect.  Do
NOT try to use CLEAR to set array or matrix elements to 0.  You will
not be pleased with the results.

If you are trying to clear power or product substitution rules made
with either LET or FORALL...LET, you must reproduce the rule, exactly
as you typed it with the same arguments, up to but not including the
equal sign, using the word CLEAR instead of the word LET.  This is
shown in the last example.  Any other type of LET or FORALL...LET
substitution can be cleared with just the variable or operator name.
MATCH behaves the same as LET in this situation.  There is a more
complicated example under FORALL.

\endsection
\item[CLEARRULES]
CLEARRULES                                              (page 148)

        CLEARRULES list{,list}

The operator CLEARRULES is used to remove previously defined
RULE lists from the system.  list can be an explicit rule
list, or evaluate to a rule list.

Examples:
trig1 := {cos(~x)*cos(~y) => (cos(x+y)+cos(x-y))/2,
          cos(~x)*sin(~y) => (sin(x+y)-sin(x-y))/2,
          sin(~x)*sin(~y) => (cos(x-y)-cos(x+y))/2,
          cos(~x)^2       => (1+cos(2*x))/2,
          sin(~x)^2       => (1-cos(2*x))/2}$
let trig1;
                                                 COS(A - B) + COS(A + B)
cos(a)*cos(b);                                  -------------------------
                                                            2
clearrules trig1;
cos(a)*cos(b);                                  COS(A)*COS(B)

\endsection
\item[COEFF]
COEFF                                                   (page 115)

The COEFF operator returns the coefficients of the powers of the
specified variable in the given expression, in a list.

        COEFF(expression,variable)

expression is expected to be a polynomial expression, not a rational
expression.  Rational expressions are accepted when the switch RATARG
is on.  variable must be a kernel.  The results are returned in a
list.

Examples:
                                      3    2
coeff((x+y)**3,x);                  {Y ,3*Y ,3*Y,1}
coeff((x+2)**4 + sin(x),x);         {SIN(X) + 16,32,24,8,1}
high_pow;                           4
low_pow;                            0
                                                            7    9
ab := x**9 + sin(x)*x**7 + sqrt(y); AB := SQRT(Y) + SIN(X)*X  + X
coeff(ab,x);                        {SQRT(Y),0,0,0,0,0,0,SIN(X),0,1}

The variables HIGH_POW and LOW_POW are set to the highest and lowest
powers of the variable, respectively, appearing in the expression.

The coefficients are put into a list, with the coefficient of the
lowest (constant) term first.  You can use the usual list access
methods (first, second, third, rest, length, and part) to extract
them.  If a power does not appear in the expression, the corresponding
element of the list is zero. Terms involving functions of the
specified variable but not including powers of it (for example in the
expression x**4 + 3*x**2 + tan(x)) are placed in the constant term.

Since the COEFF command deals with the expanded form of the
expression, you may get unexpected results when EXP is off, or when
FACTOR or IFACTOR are on.

If you want only a specific coefficient rather than all of them, use the
COEFFN operator.

\endsection
\item[Coefficient]
Coefficient                                             (pages 132, 134)

REDUCE allows for a variety of numerical domains for the numerical
coefficients of polynomials used in calculations.  The default mode is
integer arithmetic, although the possibility of using real
coefficients has been discussed elsewhere.  Rational coefficients have
also been available by using integer coefficients in both the
numerator and denominator of an expression, using the ON DIV option to
print the coefficients as rationals.  However, REDUCE includes several
other coefficient options in its basic version.

See ADJPREC, BFSPACE, COMPLEX, MODULAR, PRECISION, PRINT_PRECISION,
RATIONAL, RATIONALIZE, ROUNDALL, ROUNDBF, ROUNDED and SETMOD.

\endsection
\item[COEFFN]
COEFFN                                                  (page 116)

The COEFFN operator takes three arguments: an expression, a kernel,
and a non-negative integer.  It returns the coefficient of the kernel
to that integer power, appearing in the expression.

        COEFFN(expression,kernel,integer)

expression must be a polynomial, unless RATARG is on which allows
rational expressions.  kernel must be a Kernel, and integer must be a
non-negative integer.

Examples:

ff := x**7 + sin(y)*x**5 + y**4 + x + 7$
coeffn(ff,x,5);                      SIN(Y)
coeffn(ff,z,3);                      0
                                             5    7
coeffn(ff,y,0);                      SIN(Y)*X  + X  + X + 7

rr := 1/y**2+y**3+sin(y);
on ratarg;

coeffn(rr,y,-2);                     ***** -2 invalid as COEFFN index

coeffn(rr,y,5);                       1
                                     ----
                                       2
                                      y

If the given power of the kernel does not appear in the expression,
COEFFN returns 0.  Negative powers are never detected, even if they
appear in the expression and RATARG are on.  COEFFN with an integer
argument of 0 returns any terms in the expression that do not contain
the given kernel.

\endsection
\item[COFACTOR]
COFACTOR                                                (page 166)

The operator COFACTOR returns the cofactor of the element in row
row and column column of a MATRIX.  Errors occur
if row or column do not evaluate to integer expressions or if
the matrix is not square.

        COFACTOR(matrix_expression,row,column)

Examples:
cofactor(mat((a,b,c),(d,e,f),(p,q,r)),2,2);      A*R - C*P
cofactor(mat((a,b,c),(d,e,f)),1,1);              ***** non-square matrix

\endsection
\xitem[COFRAME]
COFRAME                                                 (pages 257, 262, 271)
      WITH METRIC                                       (page 263
      WITH SIGNATURE                                    (page 263

\endsection
\item[COLLECT]
COLLECT                                                 (page 57)

COLLECT is a key word of the FOR construction.  Details are given there.

\endsection
\item[COMBINEEXPT]
COMBINEEXPT                                             (page 77)

REDUCE is in general poor at surd simplification.  However, when the
switch COMBINEEXPT is on, the system attempts to combine
exponentials whenever possible.

Example:                                 1/3  1/6
3^(1/2)*3^(1/3)*3^(1/6);        SQRT(3)*3   *3
on combineexpt;
ws;                             1

\endsection
\item[COMBINELOGS]
COMBINELOGS                                             (page 77)

In many cases it is desirable to expand product arguments of logarithms,
or collect a sum of logarithms into a single logarithm.  Since these are
inverse operations, it is not possible to provide rules for doing both at
the same time and preserve the REDUCE concept of idempotent evaluation.
As an alternative, REDUCE provides two switches EXPANDLOGS and
COMBINELOGS to carry out these operations.
Examples:
        on expandlogs;
        log(x*y);               LOG(X) + LOG(Y)
        on combinelogs;
        ws;                     LOG(X*Y)

At the present time, it is possible to have both switches on at once,
which could lead to infinite recursion.  However, an expression is
switched from one form to the other in this case.  Users should not
rely on this behaviour, since it may change in the next release.

\endsection
\xitem[COMM]
COMM                                                    (page 378

\endsection
\xitem[Command]
Command                                                 (page 67

\endsection
\xitem[Command terminator]
Command terminator                                      (page 153

\endsection
\item[COMMENT]
COMMENT                                                 (page 38)

Beginning with the word COMMENT, all text until the next statement
terminator (; or $) is ignored.

Examples:
                                                                  2
x := a**2 comment--a is the velocity of the particle;;      X := A

Note that the first semicolon ends the comment and the second one
terminates the original REDUCE statement.

Multiple-line comments are often needed in interactive files.  The
COMMENT command allows a normal-looking text to accompany the REDUCE
statements in the file.

\endsection
\item[COMP]
COMP                                                    (page 213)

(Not available in Personal REDUCE}

When COMP is on, any succeeding function definitions are compiled
into a faster-running form.  Default is OFF.

Examples:
The following procedure finds Fibonacci numbers recursively.
Create a new file ``refib'' in your current directory with the following
lines in it:

procedure refib(n);
   if fixp n and n >= 0 then
     if n <= 1 then 1
       else refib(n-1) + refib(n-2)
    else rederr "nonnegative integer only";

end;

{Now load REDUCE and run the following:}

on time;                                  Time: 100 ms

in "refib"$                               Time: 0 ms

                                          REFIB

                                          Time: 260 ms

                                          Time: 20 ms

refib(80);                                37889062373143906

                                          Time: 14840 ms

on comp;                                  Time: 80 ms

in "refib"$                               Time: 20 ms

                                          REFIB

                                          Time: 640 ms

refib(80);                                37889062373143906

                                          Time: 10940 ms

Note that the compiled procedure runs faster.  Your time messages will
differ depending upon which system you have.  Compiled functions
remain so for the duration of the REDUCE session, and are then lost.
They must be recompiled if wanted in another session.  With the switch
TIME on as shown above, the CPU time used in executing the command is
returned in milliseconds.  Be careful not to leave COMP on unless you
want it, as it makes the processing of procedures much slower.

\endsection
\item[COMPACT]
COMPACT                                                 (pages 179, 241)

Author:  Anthony C. Hearn

COMPACT is a package of functions for the reduction of a polynomial in
the presence of side relations.  COMPACT applies the side relations to
the polynomial so that an equivalent expression results with as few
terms as possible.  For example, the evaluation of

     compact(s*(1-sin x^2)+c*(1-cos x^2)+sin x^2+cos x^2,
             {cos x^2+sin x^2=1});

yields the result

              2           2
        SIN(X) *C + COS(X) *S + 1

\endsection
\item[Compiler]
Compiler                                                (page 213)

A compiler is available in the Professional REDUCE to convert
functions into a compiled form for faster execution.  See the switch
COMP for more details.

\endsection
\item[COMPLEX]
COMPLEX                                                 (pages 135, 372)

When the COMPLEX switch is on, full complex arithmetic is used in
simplification, function evaluation, and factorisation.  Default is OFF.

Examples:
                                  2    2
factorize(a**2 + b**2);         {A  + B }
on complex;
factorize(a**2 + b**2);         {A - I*B,A + I*B}
(x**2 + y**2)/(x + i*y);        X - I*Y
on rounded;                     *** Domain mode COMPLEX changed to COMPLEX_FLOAT
sqrt(-17);                      4.12310562562*I
log(7*i);                       1.94591014906 + 1.57079632679*I

Complex floating-point can be done by turning on ROUNDED in addition
to COMPLEX.  With COMPLEX off however, REDUCE knows that i is the
square root of -1 but will not carry out more complicated complex
operations.  If you want complex denominators cleared by
multiplication by their conjugates, turn on the switch RATIONALIZE.

\endsection
\xitem[Compound statement]
Compound statement                                      (pages 61, 63

\endsection
\xitem[Conditional statement]
Conditional statement                                   (page 56)

\endsection
\item[CONJ]
CONJ                                                    (page 72)

        CONJ(expression) or CONJ simple_expression

This operator returns the complex conjugate of an expression, if that
argument has an numerical value.  A non-numerical argument is returned as
an expression in the operators REPART and IMPART.

Examples:
conj(1+i);       1-I 
conj(a+i*b);     REPART(A) - REPART(B)*I - IMPART(A)*I - IMPART(B)

\endsection
\xitem[Constructor]
Constructor                                             (page 198)

\endsection
\item[CONT]
CONT                                                    (page 160)

The command CONT returns control to an interactive file after a
PAUSE command that has been answered with N.

Examples:
Suppose you are in the middle of an interactive file.
   factorize(x**2 + 17*x + 60);    {X + 5,X + 12} 
   pause;                          Cont? (Y or N) 
   n 
   saveas results; 
   factor1 := first results;       FACTOR1 := X + 5 
   factor2 := second results;      FACTOR2 := X + 12 
   cont;                        
....the file resumes

A PAUSE allows you to enter your own REDUCE commands, change switch
values, inquire about results, or other such activities.  When you
wish to resume operation of the interactive file, use CONT.

\endsection
\xitem[COORDINATES operator]
COORDINATES operator                                    (page 234)

\endsection
\xitem[COORDS vector]
COORDS vector                                           (page 234)

\endsection
\xitem[CORFACTOR]
CORFACTOR                                               (page 350)

\endsection
\item[COS]
COS                                                     (pages 76, 78)

The COS operator returns the cosine of its argument.

        COS(expression) or COS simple_expression

expression is any valid scalar REDUCE expression, simple_expression is
a single identifier or begins with a prefix operator name.

Examples:
cos abc;                             COS(ABC) 
cos(pi);                             -1 
cos 4;                               COS(4) 
on rounded; 
cos(4);                              - 0.653643620864 
cos log 5;                           - 0.0386319699339

COS returns a numeric value only if ROUNDED is on. Then the cosine is
calculated to the current degree of floating point precision.

\endsection
\item[COSH]
COSH                                                    (pages 76, 78)

The COSH operator returns the hyperbolic cosine of its argument.  The
derivative of COSH and some simple transformations are known to the
system.

        COSH(expression) or COSH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression. simple_expression must be a single identifier or
begin with a prefix operator name.

Examples:
cosh b;                                   COSH(B) 
cosh(0);                                  1 
df(cosh(x*y),x);                          SINH(X*Y)*Y 
int(cosh(x),x);                           SINH(X)

You may attach further functionality by defining its inverse (see
ACOSH).  A numeric value is not returned by COSH unless the switch
ROUNDED is on and its argument evaluates to a number.

\endsection
\item[COT]
COT                                                     (pages 76, 78)

COT represents the cotangent of its argument.  It takes an arbitrary
scalar expression as its argument. The derivative of ACOT and some
simple properties are known to the system.

        COT(expression) or COT simple_expression

expression may be any scalar REDUCE expression.  simple_expression
must be a single identifier or begin with a prefix operator name.

Examples:
cot(a)*tan(a);                        COT(A)*TAN(A)) 
cot(1);                               COT(1) 
                                                   2
df(cot(2*x),x);                       - 2*(COT(2*X)  + 1)

Numerical values of expressions involving COT may be found by
turning on the switch ROUNDED.

\endsection
\item[COTH]
COTH                                                    (pages 76, 78)

The COTH operator returns the hyperbolic cotangent of its argument.
The derivative of COTH and some simple transformations are known to
the system.

        COTH(expression) or COTH simple_expression

expression may be any scalar REDUCE expression.  simple_expression
must be a single identifier or begin with a prefix operator name.

Examples:
                                                 2
df(coth(x*y),x);                   - Y*(COTH(X*Y)  - 1) 
coth acoth z;                      Z

You can write LET statements and procedures to add further
functionality to COTH if you wish.  Numerical values of expressions
involving COTH may also be found by turning on the switch ROUNDED.

\endsection
\item[CRAMER]
CRAMER                                                  (pages 85, 163)

When the CRAMER switch is on, MATRIX inversion and linear equation
solving (operator SOLVE) is done by Cramer's rule, through exterior 
multiplication. Default is OFF.

Examples:
on time;                                  Time: 80 ms
off output;                               Time: 100 ms
mm := mat((a,b,c,d,f),(a,a,c,f,b),
          (b,c,a,c,d), (c,c,a,b,f),
          (d,a,d,e,f));
                                          Time: 300 ms
inverse := 1/mm;                          Time: 18460
on cramer;                                Time: 80 ms
cramersinv := 1/mm;                       Time: 9260 MS

Your time readings will vary depending on the REDUCE version you use.
After you invert the matrix, turn on OUTPUT and ask for one of the
elements of the inverse matrix, such as CRAMERSINV(3,2), so that you
can see the size of the expressions produced.

Inversion of matrices and the solution of linear equations with dense
symbolic entries in many variables is generally considerably faster
with CRAMER on.  However, inversion of numeric-valued matrices is
slower.  Consider the matrices you're inverting before deciding
whether to turn CRAMER on or off.  A substantial portion of the time
in matrix inversion is given to formatting the results for printing.
To save this time, turn OUTPUT off, as shown in this example or
terminate the expression with a dollar sign instead of a semicolon.
The results are still available to you in the workspace associated
with your prompt number, or you can assign them to an identifier for
further use.

\endsection
\item[CREF]
CREF                                                    (pages 215, 216)

The switch CREF invokes the CREF cross-reference program that
processes a set of procedure definitions to produce a summary of their
entry points, undefined procedures, non-local variables and so on.  The
program will also check that procedures are called with a consistent
number of arguments, and print a diagnostic message otherwise.

The output is alphabetised on the first seven characters of each function
name.

To invoke the cross-reference program, CREF is first turned on.
This causes the program to load and the cross-referencing process to
begin.  After all the required definitions are loaded, turning CREF
off will cause a cross-reference listing to be produced.



Algebraic procedures in REDUCE are treated as if they were symbolic, so
that algebraic constructs will actually appear as calls to symbolic
functions, such as AEVAL.

\endsection
\xitem[CRESYS]
CRESYS                                                  (pages 378, 380)

\endsection
\xitem[CROSS]
CROSS 
      vector                                            (page 233)

\endsection
\xitem[cross product]
cross product                                           (pages 233, 357)

\endsection
\xitem[Cross reference]
Cross reference                                         (page 215)

\endsection
\item[CSC]
CSC                                                     (pages 76, 78)

The CSC operator returns the cosecant of its argument.  The derivative
of CSC and some simple transformations are known to the system.

        CSC(expression) or CSC simple_expression

expression may be any scalar REDUCE expression.  simple_expression
must be a single identifier or begin with a prefix operator name.

Examples:
csc(q)*sin(q);                      CSC(Q)*SIN(Q) 
df(csc(x*y),x);                     -COT(X*Y)*CSC(X*Y)*Y


You can write LET statements and procedures to add further
functionality to CSC if you wish.  Numerical values of expressions
involving CSC may also be found by turning on the switch ROUNDED.

\endsection
\item[CSCH]
CSCH                                                    (pages 76, 78)

The COSH operator returns the hyperbolic cosecant of its argument.
The derivative of CSCH and some simple transformations are known to
the system.

        CSCH(expression) or CSCH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression. simple_expression must be a single identifier or
begin with a prefix operator name.

Examples:
csch b;                                   CSCH(B) 
csch(0);                                  0 
df(csch(x*y),x);                          - COTH(X*Y)*CSCH(X*Y)*Y 
int(csch(x),x);                           INT(CSCH(X),X)

A numeric value is not returned by CSCH unless the switch ROUNDED is
on and its argument evaluates to a number.

\endsection
\xitem[CURL operator]
CURL operator                                           (page 234)

\endsection
\xitem[curl vector field]
curl vector field                                       (page 234)

\endsection
\xitem[curl operator]
curl operator                                           (page 358)

\endsection
\xitem[cylindrical coordinates]
cylindrical coordinates                                 (page 355)

\endsection
\xitem[d exterior differentiation]
d 
      exterior differentiation                          (page 271)

\endsection
\xitem[Declaration]
Declaration                                             (page 67)

\endsection
\item[DECOMPOSE]
DECOMPOSE                                               (page 127)

The DECOMPOSE operator takes a multivariate polynomial as argument,
and returns an expression and a LIST of EQUATIONs from which the
original polynomial can be found by composition.

        DECOMPOSE(expression) or DECOMPOSE  simple_expression

Examples:
decompose(x^8-88*x^7+2924*x^6-43912*x^5+263431*x^4-
          218900*x^3+65690*x^2-7700*x+234)
                                                          2
                                                        {U  + 35*U + 234,

                                                            2
                                                         U=V  + 10*V,

                                                                    2
                                                         V=X  - 22*X }

                                                          2
decompose(u^2+v^2+2u*v+1);                              {W  + 1,W=U + V}

Unlike factorisation, this decomposition is not unique.  Further
details can be found in V.S. Alagar, M.Tanh, Fast Polynomial
Decomposition, Proc. EUROCAL 1985, pp 150-153 (Springer) and J. von
zur Gathen, Functional Decomposition of Polynomials: the Tame Case, J.
Symbolic Computation (1990) 9, 281-299.

\endsection
\item[DEFINE]
DEFINE                                                  (page 70)

The command DEFINE allows you to supply a new name for an identifier
or replace it by any valid REDUCE expression.

        DEFINE identifier = substitution {,identifier = substitution}

identifier is any valid REDUCE identifier, substitution can be a
number, an identifier, an operator, a reserved word, or an expression.

Examples:

define is= :=, xx=y+z;
a is 10;                                 A := 10
                                          2            2
xx**2;                                   Y  + 2*Y*Z + Z

xx := 10;                                Y + Z := 10

The renaming is done at the input level, and therefore takes precedence
over any other replacement or substitution declared for the same identifier.
It remains in effect until the end of the REDUCE session.  Be careful with
it, since you cannot easily undo it without ending the session.

\endsection
\xitem[definite integration (simple)]
definite integration (simple)                           (page 236)

\endsection
\xitem[DEFINT function]
DEFINT function                                         (page 236)

\endsection
\xitem[DEFLINEINT function]
DEFLINEINT function                                     (page 238)

\endsection
\item[DEFN]
DEFN                                                    (pages 197, 218)

When the switch DEFN is on, the Standard Lisp equivalent of the
input statement or procedure is printed, but not evaluated.  Default is
OFF.

Examples:

on defn;
17/3;                        (AEVAL (LIST 'QUOTIENT 17 3))

df(sin(x),x,2);              (AEVAL (LIST 'DF (LIST 'SIN 'X) 'X 2))
procedure coshval(a);
   begin scalar g;
      g := (exp(a) + exp(-a))/2;
      return g
   end;                      (AEVAL 
                               (PROGN 
                                   (FLAG '(COSHVAL) 'OPFN) 
                                   (DE COSHVAL (A) 
                                     (PROG (G) 
                                        (SETQ G 
                                         (AEVAL 
                                            (LIST 
                                               'QUOTIENT 
                                               (LIST 
                                                  'PLUS 
                                                  (LIST 'EXP A) 
                                                  (LIST 'EXP (LIST 'MINUS A))) 
                                               2))) 
                                      (RETURN G)))) ) 
coshval(1);                (AEVAL (LIST 'COSHVAL 1))
off defn; 
coshval(1);                Declare COSHVAL operator? (Y or N)
n
procedure coshval(a);
   begin scalar g;
      g := (exp(a) + exp(-a))/2;
      return g
   end;                    COSHVAL
on rounded;
coshval(1);                1.54308063482

The above function COSHVAL finds the hyperbolic cosine (cosh) of its
argument.  When DEFN is on, you can see the Standard Lisp equivalent
of the function, but it is not entered into the system as shown by the
message DECLARE COSHVAL OPERATOR?.  It must be reentered with DEFN off
to be recognised.  This procedure is used as an example; a more
efficient procedure would eliminate the unnecessary local variable
with
      procedure coshval(a);
         (exp(a) + exp(-a))/2;

\endsection
\item[DEFPOLY]
DEFPOLY statement                                       (page 225)

DEFPOLY is used to introduce a defining polynoimial for an algebraic
number.  For example, to define an atom to stand for teh square root
of 2 one would say

        load arnum;
        defpoly sqrt2^2 -2;

This associates a simplification function for the variable and also
generates a power reduction rule used by the operations * and / for
the reduction of their result modulo the defining polynomial.  A basis
for the representation of an algebraic number is also set up by the
statement.  If the defining polynomial is not monic, it will be made
so by an appropriate substitution.

\endsection
\item[DEG]
DEG                                                     (page 128)

The operator DEG returns the highest degree of its variable argument
found in its expression argument.

        DEG(expression,kernel)

expression is expected to be a polynomial expression, not a rational
expression.  Rational expressions are accepted when the switch RATARG
is on.  variable must be a Kernel.  The results are returned in a
list.

Examples:
deg((x+y)**5,x);                    5 
deg((a+b)*(c+2*d)**2,d);            2 
deg(x**2 + cos(y),sin(x));   
deg((x**2 + sin(x))**5,sin(x));     5

\endsection
\xitem[Degree]
Degree                                                  (page 128)

\endsection
\xitem[DELSQ operator]
DELSQ 
      operator                                          (page 234)

\endsection
\xitem[delsq operator]
delsq operator                                          (page 358)

\endsection
\item[DEMO]
DEMO                                                    (page 69)

The DEMO switch is used for interactive files, causing the system
to pause after each command in the file until you type a Return.
Default is OFF.

The switch DEMO has no effect on top level interactive statements.
Use it when you want to slow down operations in a file so you can see
what is happening.

You can either include the ON DEMO command in the file, or enter it
from the top level before bringing in any file.  Unlike the PAUSE
command, ON DEMO does not permit you to interrupt the file for
questions of your own.

\endsection
\item[DEN]
DEN                                                     (pages 120, 129)

The DEN operator returns the denominator of its argument.

        DEN(expression)

expression is ordinarily a rational expression, but may be any valid
scalar REDUCE expression.

Examples:
                                           2
a := x**3 + 3*x**2 + 12*x;        A := X*(X  + 3*X + 12) 
b := 4*x*y + x*sin(x);            B := X*(SIN(X) + 4*Y) 
den(a/b);                         SIN(X) + 4*Y 
den(aa/4 + bb/5);                 20 
den(100/6);                       3 
den(sin(x));                      1

DEN returns the denominator of the expression after it has been
simplified by REDUCE.  As seen in the examples, this includes putting
sums of rational expressions over a common denominator, and reducing
common factors where possible.  If the expression does not have any
other denominator, 1 is returned.

Switch settings, such as MCD or RATIONAL, have an effect on the
denominator of an expression.

\endsection
\item[DEPEND]
DEPEND                                                  (page 95)

DEPEND declares that its first argument depends on the rest of its
arguments.

        DEPEND kernel{,kernel}

kernel must be a legal variable name or a prefix operator (see
Kernel).

Examples:

depend y,x;
df(y**2,x);                             2*DF(Y,X)*Y
depend z,cos(x),y; 
df(sin(z),cos(x));                      COS(Z)*DF(Z,COS(X))
df(z**2,x);                             2*DF(Z,X)*Z
nodepend z,y;
df(z**2,x);                             2*DF(Z,X)*Z
cc := df(y**2,x);                       CC := 2*DF(Y,X)*Y
y := tan x;                             Y := TAN(X);
                                                        2
cc;                                     2*TAN(X)*(TAN(X)  + 1)

Dependencies can be removed by using the declaration NODEPEND.  The
differentiation operator uses this information, as shown in the
examples above.  Linear operators also use knowledge of dependencies
(see LINEAR).  Note that dependencies can be nested: Having declared y
to depend on x, and z to depend on y, we see that the chain rule was
applied to the derivative of a function of z with respect to x.  If
the explicit function of the dependency is later entered into the
system, terms with DF(Y,X), for example, are expanded when they are
displayed again, as shown in the last example.

\endsection
\xitem[DEPEND statement]
DEPEND statement                                        (page 359)

\endsection
\xitem[DEQ(I)]
DEQ(I)                                                  (page 379)

\endsection
\xitem[derivative variational]
derivative 
      variational                                       (page 257)

\endsection
\item[DET]
DET                                                     (pages 97, 163)

The operator COFACTOR returns the cofactor of the element in row
row and column column of a MATRIX.  Errors occur
if row or column do not evaluate to integer expressions or if
the matrix is not square.

        COFACTOR(matrix_expression,row,column)

Examples:
cofactor(mat((a,b,c),(d,e,f),(p,q,r)),2,2);       A*R - C*P
cofactor(mat((a,b,c),(d,e,f)),1,1);               ***** non-square matrix

\endsection
\xitem[determinant]
determinant 
      in DETM!*                                         (page 263)

\endsection
\xitem[DETM!*]
DETM!*                                                  (page 263)

\endsection
\item[DF]
DF                                                      (pages 79, 80)

The DF operator finds partial derivatives with respect to one or
more variables.

  DF(expression,var
             [,number]
             {,var [ ,number] } )

expression can be any valid REDUCE algebraic expression.  var must be
a Kernel, and is the differentiation variable.  number must be a
non-negative integer.

Examples:
df(x**2,x);                           2*X 
                                                2
df(x**2*y + sin(y),y);                COS(Y) + X

df((x+y)**10,z);                      0 
                                       6  
df(1/x**2,x,2);                       ----
                                        4
                                       X
df(x**4*y + sin(y),y,x,3);            24*X 

for all x let df(tan(x),x) = sec(x)**2; 
                                               2
df(tan(3*x),x);                      3*SEC(3*X)

An error message results if a non-kernel is entered as a
differentiation operator.  If the optional number is omitted, it is
assumed to be 1.  See the declaration DEPEND to establish dependencies
for implicit differentiation.

You can define your own differentiation rules, expanding REDUCE's
capabilities, using the LET command as shown in the last example
above.  Note that once you add your own rule for differentiating a
function, it supersedes REDUCE's normal handling of that function for
the duration of the REDUCE session.  If you clear the rule
(CLEARRULES), you don't get back to the previous rule.

\endsection
\item[DFPRINT]
DFPRINT

When DFPRINT is on, expressions in the differentiation operator
DF are printed in a more ``natural'' notation, with the
differentiation variables appearing as subscripts.  In addition, if the
switch NOARG is on (the default), the arguments of the
differentiated operator are suppressed.

Examples:
operator f;
df(f x,x);                      DF(F(X),X);
on dfprint;
ws;                             F
                                 X
df(f(x,y),x,y);                 F
                                 X,Y
off noarg;
ws;                             F(X,Y)
                                      X

\endsection
\xitem[differential geometry]
differential geometry                                   (page 248)

\endsection
\xitem[Differentiation]
Differentiation                                         (pages 79, 80, 95)

\endsection
\xitem[differentiation]
differentiation 
      partial                                           (page 251)
      vector                                            (page 233)

\endsection
\item[DIGAMMA]
DIGAMMA                                                 (page 185, 395)

See PSI
\endsection
\item[DILOG]
DILOG                                                   (pages 76, 81, 185)

The DILOG operator is known to the differentiation and integration
operators, but has numeric value attached only at DILOG(0).  DILOG is
defined by
                   log(x)
  dilog(x) = -int  ------ dx
                     x-1

  dilog(x) = -int(log(x),x)/(x-1)

Examples:                                   2       2
df(dilog(x**2),x);                - (2*LOG(X )*X)/(X  - 1)

int(dilog(x),x);                 DILOG(X)*X - DILOG(X) + LOG(X)*X - X 
                                   2
dilog(0);                        PI /6

\endsection
\xitem[dimension]
dimension                                               (page 251)

\endsection
\xitem[Dirac gamma matrix]
Dirac gamma matrix                                      (page 206)

\endsection
\item[DISPLAY]
DISPLAY                                                 (page 158))

When given a numeric argument n, DISPLAY prints the n most recent
input statements, identified by prompt numbers.  If an empty pair of
parentheses is given, or if n is greater than the current number of
statements, all the input statements since the beginning of the
session are printed.

        DISPLAY(n) or DISPLAY()

n should be a positive integer.  However, if it is a real number, the
truncated integer value is used, and if a non-numeric argument is
used, all the input statements are printed.

The statements are displayed in upper case, with lines split at
semicolons or dollar signs, as they are in editing.  If long files
have been input during the session, the DISPLAY command is slow to
format these for printing.

\endsection
\xitem[Display]
Display                                                 (page 97)

\endsection
\xitem[DISPLAYFRAME command]
DISPLAYFRAME command                                    (pages 266, 271)

\endsection
\xitem[Displaying structure]
Displaying structure                                    (page 112)

\endsection
\item[DIV]
DIV                                                     (pages 103, 132)

When DIV is on, the system divides any simple factors found in the
denominator of an expression into the numerator.  Default is OFF.

Examples:

on div;
                                        2  -2
a := x**2/y**2;                   A := X *Y
                                        1   2  -2  -1
b := a/(3*z);                     B := ---*X *Y  *Z
                                        3
off div;
                                    2
                                   X
a;                                ----
                                    2
                                   Y

                                      2
                                     X
b;                                --------
                                      2
                                   3*Y *Z

The DIV switch only has effect when the PRI switch is on.  When PRI is
off, regardless of the setting of DIV, the printing behaviour is as if
DIV were off.

\endsection
\xitem[DIV operator]
DIV 
      operator                                          (page 234)

\endsection
\xitem[div operator]
div operator                                            (page 358)

\endsection
\xitem[divergence vector field]
divergence 
      vector field                                      (page 234)

\endsection
\xitem[DLINEINT]
DLINEINT                                                (page 360)

\endsection
\xitem[DO]
DO                                                      (pages 57--59)

\endsection
\xitem[Dollar sign]
Dollar sign                                             (page 53)

\endsection
\item[DOT]
DOT product of vectors                                  (pages 205, 233, 357)

The . operator is used to denote the scalar product of two Lorentz
four-vectors.
        vector . vector

vector must be an identifier declared to be of type VECTOR to have
the scalar product definition.  When applied to arguments that are not
vectors, the CONS operator is used,
whose symbol is also ``dot.''

Examples:
vector aa,bb,cc;
let aa.bb = 0;
aa.bb;                                    0
aa.cc;                                    AA.CC
q := aa.cc;                               Q := AA.CC
q;                                        AA.CC

Since vectors are special high-energy physics entities that do not
contain values, the . product will not return a true scalar product.
You can assign a scalar identifier to the result of a . operation, or
assign a .  operation to have the value of the scalar you supply, as
shown above.  Note that the result of a . operation is a scalar, not a
vector.

The metric tensor g(u,v) can be represented by U.V.  If contraction
over the indices is required, U and V should be declared to be of type
INDEX.

The dot operator has the highest precedence of the infix operators, so
expressions involving . and other operators have the scalar product
evaluated first before other operations are done.

\endsection
\xitem[Dot product]
Dot product                                             (pages 205, 233, 357)

\endsection
\xitem[DOTGRAD operator]
DOTGRAD operator                                        (page 358)

\endsection
\xitem[DVINT]
DVINT                                                   (page 360)

\endsection
\xitem[DVOLINT]
DVOLINT                                                 (page 360)

\endsection
\item[E]
E                                                       (page 36)

The constant E is reserved for use as the base of the natural
logarithm.  Its value is approximately 2.71828284590, which REDUCE gives
to the current decimal precision when the switch ROUNDED is on.


E may be used as an iterative variable in a FOR statement,
or as a local variable or a PROCEDURE.  If E is defined as a local
variable inside the procedure, the normal definition as the base of the
natural logarithm would be suspended inside the procedure.

\endsection
\item[ECHO]
ECHO                                                    (page 153)

The ECHO switch is normally off for top-level entry, and on when files
are brought in.  If ECHO is turned on at the top level, your input
statements are echoed to the screen (thus appearing twice).  Default
OFF (but note default ON for files).


If you want to display certain portions of a file and not others, use the
commands OFF ECHO and ON ECHO inside the file.  If you want
no display of the file, use the input command

        IN filename$

rather than using the semicolon delimiter.

Be careful when you use commands within a file to generate another file.
Since ECHO is on for files, the output file echoes input statements
(unlike its behaviour from the top level).  You should explicitly turn off
ECHO when writing output, and turn it back on when you're done.

\endsection
\item[ED]
ED                                                      (pages 157, 158)

The ED command invokes a simple line editor for REDUCE input
statements.

        ED integer or ED

ED called with no argument edits the last input statement.  If integer
is greater than or equal to the current line number, an error message
is printed.  Reenter a proper ED command or return to the top level
with a semicolon.

The editor formats REDUCE's version of the desired input statement,
dividing it into lines at semicolons and dollar signs.  The statement
is printed at the beginning of the edit session.  The editor works on
one line at a time, and has a pointer (shown by ^) to the current
character of that line.  When the session begins, the pointer is at
the left hand side of the first line.  The editing prompt is >.

The following commands are available.  They may be entered in either
upper or lower case.  All commands are activated by the carriage
return, which also prints out the current line after changes.  Several
commands can be placed on a single line, except that commands
terminated by an Cntrl-G must be the last command before the carriage
return.

b  
Move pointer to beginning of current line.

ddigit
Delete current character and next (digit-1) characters.  An error
message is printed if anything other than a single digit follows d.
If there are fewer than digit characters left on the line, all but the
final dollar sign or semicolon is removed.  To delete a line
completely, use the k command.

e
End the current session, causing the edited expression to be reparsed by
REDUCE.

fchar
Find the next occurrence of the character char to the right of the
pointer on the current line and move the pointer to it. If the
character is not found, an error message is printed and the pointer
remains in its original position.  Other lines are not searched.  The
f command is not case-sensitive.

istring{Cntrl-G}
Insert string in front of pointer.  The Cntrl-G key is your delimiter for
the input string.  No other command may follow this one on the same
line.

k
Kill rest of the current line, including the semicolon or dollar sign
terminator.  If there are characters remaining on the current line, and it
is the last line of the input statement, a semicolon is added to the line
as a terminator for REDUCE.  If the current line is now empty, one of the
following actions is performed:  If there is a following line, it becomes
the current line and the pointer is placed at its first character.  If the
current line was the final line of the statement, and there is a previous
line, the previous line becomes the current line.  If the current line was
the only line of the statement, and it is empty, a single semicolon is
inserted for REDUCE to parse.

l
Finish editing this line and move to the last previous line.  An error message
is printed if there is no previous line.

n
Finish editing this line and move to the next line.  An error message is 
printed if there is no next line.

p
Print out all the lines of the statement.  Then a dotted line is printed, and
the current line is reprinted, with the pointer under it.

q
Quit the editing session without saving the changes.  If a semicolon is
entered after q, a new line prompt is given, otherwise REDUCE prompts you
for another command.  Whatever you type in to the prompt appearing after
the q is entered is stored as the input for the line number in which you
called the edit.  Thus if you enter a semicolon, neither INPUT
ED will find anything under the current number.

rchar
Replace the character at the pointer by char.

sstring{Cntrl-G}
Search for the first occurrence of string to the right of the
pointer on the current line and move the pointer to its first character.
The Cntrl-G key is your delimiter for the input string.  The s function
does not search other lines of the statement.  If the string is not found,
an error message is printed and the pointer remains in its original
position.  The s command is not case-sensitive.  No other command may
follow this one on the same line.

x or space
Move the pointer one character to the right.  If the pointer is already at
the end of the line, an error message is printed.

- (minus)
Move the pointer one character to the left.  If the pointer is already at the
beginning of the line, an error message is printed.  

?
Display the Help menu, showing the commands and their actions.

Examples:
(Line numbers are shown in the following examples)
                                 2
2: x**2 + y;                    X  + Y
3: ed 2;
  X**2 + Y;
  ^
For help, type '?'
?-                       {(Enter three spaces and Return})}
  X**2 + Y;
     ^
?- r5
  X**5 + Y;
     ^
?- fY
  X**5 + Y;
         ^
?- iabc{(Terminate with Cntrl-G and Return)}
  X**5 + abcY;
            ^
?- ----
  X**5 + abcY;
        ^
?- fbd2
  X**5 + aY;
          ^
?- b
  X**5 + aY;
  ^                                   5
?- e                            AY + X
4: procedure dumb(a);
   write a;
DUMB
5: dumb(17);                    17
6: ed 4;
  PROCEDURE DUMB (A);
  ^
WRITE A;
?- fArBn
  WRITE A;
  ^
?- ibegin scalar a; a := b + 10;{space Cntrl-G and Return}
  begin scalar a; a := b + 10; WRITE A;
?- f;i end {Cntrl-G Return}
  begin scalar b; b := a + 10; WRITE A end;
                                          ^
?- p
 PROCEDURE DUMB (B);
 begin scalar b; b := a + 10; WRITE A end;
 -  -  -  -  -  -  -  -  -  -
  begin scalar b; b := a + 10; WRITE A end;
                                          ^
?- e                            DUMB
7: dumb(17);                    27
8: 

Note that REDUCE reparsed the procedure DUMB and updated the
definition.

Since REDUCE divides the expression to be edited into lines at
semicolons or dollar sign terminators, some lines may occupy more than
one line of screen space.  If the pointer is directly beneath the last
line of text, it refers to the top line of text.  If there is a blank
line between the last line of text and the pointer, it refers to the
second line of text, and likewise for cases of greater than two lines
of text.  In other words, the entire REDUCE statement up to the next
terminator is printed, even if it runs to several lines, then the
pointer line is printed.

You can insert new statements which contain semicolons of their own
into the current line.  They are run into the current line where you
placed them until you edit the statement again.  REDUCE will
understand the set of statements if the syntax is correct.

If you leave out needed closing brackets when you exit the editor, a
message is printed allowing you to redo the edit (you can edit the
previous line number and return to where you were).  If you leave out
a closing double-quotation mark, an error message is printed, and the
editing must be redone from the original version; the edited version
has been destroyed.  Most syntax errors which you inadvertently leave
in an edited statement are caught as usual by the REDUCE parser, and
you will be able to re-edit the statement.

When the editor processes a previous statement for your editing,
escape characters are removed.  Most special characters that you may
use in identifiers are printed in legal fashion, prefixed by the
exclamation point.  Be sure to treat the special character and its
escape as a pair in your editing.  The characters ( ) # ; ' ` are
different.  Since they have special meaning in Lisp, they are
double-escaped in the editor.  It is unwise to use these characters
inside identifiers anyway, due to the probability of confusion.

If you see a Lisp error message during editing, the edit has been
aborted.  Enter a semicolon and you will see a new line prompt.

Since the editor has no dependence on any window system, it can be
used if you are running REDUCE without windows.

\endsection
\item[EDITDEF]
EDITDEF                                                 (page 159)

The interactive editor ED may be used to edit a user-defined
procedure that has not been compiled.

        EDITDEF(identifier)

where identifier is the name of the procedure.  When EDITDEF is
invoked, the procedure definition will be displayed in editing mode,
and may then be edited and redefined on exiting from the editor using
standard ED commands.

\endsection
\item[END]
END                                                     (page 69)

The command END has two main uses:

(i)  as the ending of a BEGIN...END BLOCK; and
(ii) to end input from a file.

In a BEGIN...END BLOCK, there need not be a delimiter (; or $) before
the END, though there must be one after it, or a right bracket
matching an earlier left bracket.

Files to be read into REDUCE should end with END;, which must be
preceded by a semicolon (usually the last character of the previous
line).  The additional semicolon avoids problems with mistakes in the
files.  If you have suspended file operation by answering N to a PAUSE
command, you are still, technically speaking, ``in'' the file.  Use END
to exit the file.

An END at the top level of a program is ignored.

\endsection
\item[EPS]
EPS                                                     (pages 207, 267)

The EPS operator denotes the completely antisymmetric tensor of
order 4 and its contraction with Lorentz four-vectors, as used in
high-energy physics calculations.

        EPS(vector-expr,vector-expr,vector-expr,vector-expr)

vector-expr must be a valid vector expression, and may be an index.

Examples:
vector g0,g1,g2,g3;
eps(g1,g0,g2,g3);                     - EPS(G0,G1,G2,G3);
eps(g1,g2,g0,g3);                     EPS(G0,G1,G2,G3);
eps(g1,g2,g3,g1);                     0


Vector identifiers are ordered alphabetically by REDUCE.  When an odd
number of transpositions is required to restore the canonical order to
the four arguments of EPS, the term is ordered and carries a minus
sign.  When an even number of transpositions is required, the term is
returned ordered and positive.  When one of the arguments is repeated,
the value 0 is returned.  A contraction of the form eps(_i j mu nu
p_mu q_nu) is represented by EPS(I,J,P,Q) when I and J have been
declared to be of type INDEX.

\endsection
\xitem[EPS Levi-Civita tensor]
EPS 
      Levi-Civita tensor                        (page 271)

\endsection
\item[Equation]
Equation                                                (page 47)

An Equation is an expression where two algebraic expressions
are connected by the (infix) operator EQUAL or by =.
For access to the components of an EQUATION the operators
LHS, RHS or PART can be used. The
evaluation of the left-hand side of an EQUATION is controlled
by the switch EVALLHSEQP, while the right-hand side is
evaluated unconditionally. When an EQUATION is part of a
logical expression, e.g. in a IF or WHILE statement,
the equation is evaluated by subtracting both sides and comparing
the result with zero.

\endsection
\item[ERF]
ERF                                                     (page 81)

The ERF operator represents the error function, defined by
        erf(x) = (2/sqrt(pi))*int(e^(-x^2),x)

A limited number of its properties are known to the system, including
the fact that it is an odd function.  Its derivative is known, and
from this, some integrals may be computed.  However, a complete
integration procedure for this operator is not currently included.

Examples:
erf(0);                          0 
erf(-a);                         - ERF(A) 
                                  4*SQRT(PI)*X
df(erf(x**2),x);                 --------------
                                       4
                                      X

                                    2
                                   X
                                  E  *ERF(X)*PI*X + SQRT(PI)
int(erf(x),x);                   ----------------------------
                                              2
                                             X
                                            E  *PI

\endsection
\item[ERRCONT]
ERRCONT                                                 (page 157)

When the ERRCONT switch is on, error conditions do not stop file
execution.  Error messages will be printed whether ERRCONT is on or off.
Default is OFF.

The table below shows REDUCE behaviour under the settings of ERRCONT and
INT :

Behaviour in Case of Error in Files

errcont     int        Behaviour when errors in files are encountered
  off       off        Message is printed and parsing continues, but
                       no further statements are executed; no commands
                       from keyboard accepted except bye or end
  off        on        Message is printed, and you are asked if you
                       wish to continue.  (This is the default behaviour)
   on       off        Message is printed, and file continues to execute
                       without pause
   on        on        Message is printed, and file continues to execute
                       without pause


\endsection
\xitem[ETA(ALFA)]
ETA(ALFA)                                               (page 379)

\endsection
\xitem[euclidean metric]
euclidean metric                                        (page 263)

\endsection
\item[EULER]
EULER                                                   (pages 185, 393)

The EULER operator returns the nth Euler number.

EULER(integer)

Examples:
load_package specfn;                     (SPECFN)
Euler 20;                                370371188237525
Euler 0;                                 1

The EULER numbers are evaluated by a recursive algorithm which makes
it hard to compute Euler numbers above say 200.

Euler numbers appear in the coefficients of the power series 
representation of 1/cos(z).

\endsection
\item[EULERP]
Euler Polynomials                                       (page 185)

The EULERP operator returns the nth Euler Polynomial.

EULERP(integer,expression)

Examples:
        load_package specfn;       (SPECFN)
        EulerP(2,xx);              XX*(XX - 1)
        EulerP(10,3);              2046

The Euler numbers are the values of the Euler Polynomials at 1/2
multiplied by 2**n.

\endsection
\item[Euler Numbers]
Euler Numbers                                           (pages 185, 393)

See EULERP.
The Euler numbers are the values of the Euler Polynomials at 1/2
multiplied by 2**n.

\endsection
\item[EVAL_MODE]
EVAL_MODE                                               (page 191)

The constant E is reserved for use as the base of the natural
logarithm.  Its value is approximately 2.71828284590, which REDUCE gives
to the current decimal precision when the switch ROUNDED is on.


E may be used as an iterative variable in a FOR statement,
or as a local variable or a PROCEDURE.  If E is defined as a local
variable inside the procedure, the normal definition as the base of the
natural logarithm would be suspended inside the procedure.

\endsection
\item[EVALLHSEQP]
EVALLHSEQP                                              (page 47)

Under normal circumstances, the right-hand-side of an EQUATION is evaluated
but not the left-hand-side.  If both sides are to be evaluated, the switch
EVALLHSEQP should be turned on.

\endsection
\item[EVEN]
EVEN                                                    (page 90)

        EVEN identifier{,identifier}

This declaration is used to declare an operator even in its first
argument.  Expressions involving an operator declared in this manner
are transformed if the first argument contains a minus sign.  Any
other arguments are not affected.

Examples:
        even f; 
        f(-a)               F(A) 
        f(-a,-b)            F(A,-B)

\endsection
\xitem[Even operator]
Even operator                                           (page 90)

\endsection
\item[EVENP]
EVENP                                                   (page 46)

The EVENP logical operator returns TRUE if its argument is an even
integer, and NIL if its argument is an odd integer.  An error message
is returned if its argument is not an integer.

        EVENP(integer) or EVENP integer

integer must evaluate to an integer.

Examples:
aa := 1782;                                  AA := 1782 
if evenp aa then yes else no;                YES 
if evenp(-3) then yes else no;               NO 

Although you would not ordinarily enter an expression such as the last
example above, note that the negative term must be enclosed in
parentheses to be correctly parsed.  The EVENP operator can only be
used in conditional statements such as IF...THEN...ELSE or WHILE...DO.

\endsection
\item[EXCALC]
EXCALC                                          (pages 180, 247)

Author: Eberhard Schruefer

The EXCALC package is designed for easy use by all who are familiar
with the calculus of Modern Differential Geometry.  The program is currently
able to handle scalar-valued exterior forms, vectors and operations between
them, as well as non-scalar valued forms (indexed forms).  It is thus an ideal
tool for studying differential equations, doing calculations in general
relativity and field theories, or doing simple things such as calculating the
Laplacian of a tensor field for an arbitrary given frame. 

\endsection
\xitem[Exclamation mark]
Exclamation mark                                        (page 33)

\endsection
\xitem[EXCLUDE]
EXCLUDE                                                 (page 368)

\endsection
\xitem[EXDEGREE]
EXDEGREE                                                (page 271)

\endsection
\xitem[EXDEGREE command]
EXDEGREE command                                        (page 249)

\endsection
\item[EXP]
EXP (operator and switch)                       (pages 76, 78, 81, 120, 124)

The EXP operator returns E raised to the power of its argument.

        EXP(expression) or EXP simple_expression

expression can be any valid REDUCE scalar expression.
simple_expression must be a single identifier or begin with a
prefix operator.

Examples:
                                 SIN X
exp(sin(x));                    E
                                 11
exp(11);                        E
on rounded; 
exp sin(pi/3);                  2.37744267524

Numeric values are returned only when ROUNDED is on.  The single
letter E with the exponential operator ^ or ** may be substituted for
EXP without change of function.

EXP switch

When the EXP switch is on, powers and products of expressions are
expanded.  Default is ON.

Examples:                          3     2
(x+1)**3;                         X + 3*X + 3*X + 1
(a + b*i)*(c + d*i);              A*C + A*D*I + B*C*I - B*D
off exp;                                 3
(x+1)**3;                         (X + 1)
(a + b*i)*(c + d*i);              (A + B*I)*(C + D*I)
length((x+1)**2/(y+1));           2


Note that REDUCE knows that i^2 = -1.  When EXP is off, equivalent
expressions may not simplify to the same form, although zero
expressions still simplify to zero.  Several operators that expect a
polynomial argument behave differently when EXP is off, such as
LENGTH.  Be cautious about leaving EXP off.


\endsection
\item[EXPAND_CASES]
EXPAND_CASES                                            (page 86)

When a ROOT_OF form in a result of SOLVE has been converted to a
ONE_OF form, EXPAND_CASES can be used to convert this into form
corresponding to the normal explicit results of SOLVE. See ROOT_OF.

\endsection
\item[EXPANDLOGS]
EXPANDLOGS                                              (page 77)

In many cases it is desirable to expand product arguments of
logarithms, or collect a sum of logarithms into a single logarithm.
Since these are inverse operations, it is not possible to provide
rules for doing both at the same time and preserve the REDUCE concept
of idempotent evaluation.  As an alternative, REDUCE provides two
switches EXPANDLOGS and COMBINELOGS to carry out these operations.
Both are off by default.

Examples:
        on expandlogs;
        log(x*y);               LOG(X) + LOG(Y)
        on combinelogs;
        ws;                     LOG(X*Y)

At the present time, it is possible to have both switches on at once,
which could lead to infinite recursion.  However, an expression is
switched from one form to the other in this case.  Users should not rely
on this behaviour, since it may change in the next release.

\endsection
\item[EXPINT]
EXPINT                                                  (page 76)

The EXPINT operator represents the exponential integral defined by:

        expint(x) = int(e^x,x)/x

A limited number of its properties are known to the system, including
its derivative.  From this, some integrals may be computed.  However,
a complete integration procedure for this operator is not currently
included.

Examples:
expint(0);                       EXPINT(0) 
                                      2
                                     X
                                  2*E
df(expint(x**2),x);              -------
                                    X
                                                X
int(expint(x),x);                EXPINT(X)*X - E

\endsection
\xitem[EXPR]
EXPR                                                    (page 196)

\endsection
\xitem[Expression]
Expression                                              (page 43)

\endsection
\item[exterior calc]
exterior calculus                                       (page 248)

See the EXCALC package

\endsection
\item[exterior df]
exterior differentiation                                (page 252)

See the EXCALC package

\endsection
\xitem[exterior form]
exterior form 
      declaration                                       (page 249)
      vector                                            (page 249)
      with indices                                      (pages 249, 259)

\endsection
\xitem[exterior product]
exterior product                                        (pages 250, 269)

\endsection
\item[EZGCD]
EZGCD                                                   (page 124)

When EZGCD and GCD are on, greatest common divisors are
computed using the EZ GCD algorithm that uses modular arithmetic (and is
usually faster).  Default is OFF.


As a side effect of the gcd calculation, the expressions involved are
factored, though not the heavy-duty factoring of FACTORIZE. The
EZ GCD algorithm was introduced in a paper by J. Moses and D.Y.Y. Yun in
Proceedings of the ACM, 1973, pp. 159-166.

Note that the GCD switch must also be on for EZGCD to have
effect.

\endsection
\item[FACTOR]
FACTOR (Declaration and Switch)                         (pages 101, 121, 122)

When a kernel is declared by FACTOR, all terms involving fixed powers
of that kernel are printed as a product of the fixed powers and the
rest of the terms.

        FACTOR kernel {,kernel}

kernel must be a Kernel.

Examples:                          2                    2            2
a := (x + y + z)**2;         A := X  + 2*X*Y + 2*X*Z + Y  + 2*Y*Z + Z
factor y;                     2                  2            2
a;                           Y  + 2*Y*(X + Z) + X  + 2*X*Z + Z
factor sin(x);                            4               3         2
c := df(sin(x)**4*x**2*z,x); C := 2*SIN(X) *X*Z + 4*SIN(X) *COS(X)*X *Z
remfac sin(x);                       3
c;                           2*SIN(X) *X*Z*(2*COS(X)*X + SIN(X))

Use the FACTOR declaration to display variables of interest so that
you can see their powers more clearly, as shown in the example.
Remove this special treatment with the declaration REMFAC.  The FACTOR
declaration is only effective when the switch PRI is on.

The FACTOR declaration is not a factoring command; to factor
expressions use the FACTOR switch or the FACTORIZE command.

FACTOR (switch)

When the FACTOR switch is on, input expressions and results are
automatically factored.

Examples:

on factor;
aa := 3*x**3*a + 6*x**2*y*a + 3*x**3*b + 6*x**2*y*b
+ x*y*a + 2*y**2*a + x*y*b + 2*y**2*b;
                                                  2
                         AA := (A + B)*(3*X + Y)*(X + 2*Y)
off factor;
aa;
              3       2                   2        3    2                      2
         3*A*X  + 6*A*X *Y + A*X*Y + 2*A*Y  + 3*B*X  + 6*B*X *Y + B*X*Y + 2*B*Y
on factor;
                                2
ab := x**2 - 2;          AB := X  - 2

REDUCE factors univariate and multivariate polynomials with integer
coefficients, finding any factors that also have integer coefficients.
The factoring is done by reducing multivariate problems to univariate
ones with symbolic coefficients, and then solving the univariate ones
modulo small primes.  The results of these calculations are merged to
determine the factors of the original polynomial.  The factoriser
normally selects evaluation points and primes using a random number
generator.  Thus, the detailed factoring behaviour may be different
each time any particular problem is tackled.

When the FACTOR switch is turned on, the EXP switch is turned off, and
when the FACTOR switch is turned off, the EXP switch is turned on,
whether it was on previously or not.

When the switch TRFAC is on, informative messages are generated at
each call to the factoriser.  The TRALLFAC switch causes the
production of a more verbose trace message.  It takes precedence over
TRFAC if they are both on.

To factor a polynomial explicitly and store the results, use the operator 
FACTORIZE.

\endsection
\item[FACTORIAL]
FACTORIAL                                               (pages 72, 174)

FACTORIAL(expression)

If the argument of FACTORIAL is a positive integer or zero, its
factorial is returned.  Otherwise the result is expressed in terms of
the original operator.  For more general operations, the GAMMA
operator is available in the SPECFN package.

Examples:
factorial 4;     24 
factorial 30 ;   265252859812191058636308480000000 
factorial(a) ;   FACTORIAL(A)

\endsection
\item[Factorization]
Factorization                                           (page 121)

Operations for factorising expressions exist in REDUCE.  See the
operator FACTORIZE and the switch FACTOR.

The command FACTOR controls output format.

\endsection
\item[FACTORIZE]
FACTORIZE                                               (pages 121, 122)

The FACTORIZE operator factors a given expression.

        FACTORIZE(expression)

expression should be a polynomial, otherwise an error will result.

Examples:
                                               2          2
fff := factorize(x^3 - y^3);    FFF := {X - Y,X  + X*Y + Y }
fac1 := first fff;              FAC1 := X - Y
factorize(x^15 - 1);            {X - 1,

                                  2
                                 X  + X + 1,

                                  4    3    2
                                 X  + X  + X  + X + 1,

                                  8    7    5    4    3
                                 X  - X  + X  - X  + X  - X + 1}

                                            8    7    5    4    3
lastone := part(ws,length ws);  lastone := x  - x  + x  - x  + x  - x + 1
setmod 2;                       1
on modular;
factorize(x^15 - 1);            {X + 1,

                                  2
                                 X  + X + 1,

                                  4
                                 X  + X + 1,

                                  4    3
                                 X  + X  + 1,

                                  4    3    2
                                 X  + X  + X  + X + 1}

The FACTORIZE command returns the factors it finds as a LIST.  You can
therefore use the usual list access methods (FIRST, SECOND, THIRD,
REST, LENGTH and PART) to extract the factors.

If the expression given to FACTORIZE is an integer, it will be
factored into its prime components.  To factor any integer factor of a
non-numerical expression, the switch IFACTOR should be turned on.  Its
default is off. IFACTOR has effect only when factoring is explicitly
done by FACTORIZE, not when factoring is automatically done with the
FACTOR switch.  If full factorisation is not needed the switch
LIMITEDFACTORS allows you to reduce the computing time of calls to
FACTORIZE.

Factoring can be done in a modular domain by calling FACTORIZE when
MODULAR is on.  You can set the modulus with the SETMOD command.  The
last example above shows factoring modulo 2.

For general comments on factoring, see comments under the switch
FACTOR.

\endsection
\item[FAILHARD]
FAILHARD

When the FAILHARD switch is on, the integration operator INT terminates
with an error message if the integral cannot be done in closed terms.
Default is off.

Use the FAILHARD switch when you are dealing with complicated integrals
and want to know immediately if REDUCE was unable to handle them.  The
integration operator sometimes returns a formal integration form that is
more complicated than the original expression, when it is unable to
complete the integration.

\endsection
\xitem[Fast loading of code]
Fast loading of code                                    (page 214)

\endsection
\xitem[FDOMAIN command]
FDOMAIN command                                         (pages 251, 271)

\endsection
\xitem[FEXPR]
FEXPR                                                   (page 196)

\endsection
\xitem[File handling]
File handling                                           (page 153)

\endsection
\item[FIRST]
FIRST                                                   (page 50)

The FIRST operator returns the first element of a LIST.
        FIRST(list) or FIRST list

list must be a non-empty list to avoid an error message.

Examples:
alist := {a,b,c,d};              ALIST := {A,B,C,D} 
first alist;                     A
blist := {x,y,{ww,aa,qq},z};     BLIST := {X,Y,{WW,AA,QQ},Z}
first third blist;               WW

\endsection
\item[FIRSTROOT]
FIRSTROOT                                               (page 370)

        FIRSTROOT(expression)
        FIRSTROOT simple_exprerssion

FIRSTROOT is like ROOTS but only the first root determined by ROOTS is
computed.  Note that this is not in general the first root that would
be listed in ROOTS output, since the ROOTS outputs are sorted into a
canonical order.  Also, in some difficult root finding cases, the
first root computed might be incorrect.

\endsection
\item[FIX]
FIX                                                     (page 73)
        FIX(expression)

The operator FIX returns the integer part of its argument, if that
argument has a numerical value.  For positive numbers, this is equivalent
to FLOOR, and, for negative numbers, CEILING.  For
non-numeric arguments, the value is an expression in the original operator.

Examples:
fix 3.4;         3 
floor 3.4;       3 
ceiling 3.4;     4 
fix(-5.2);       -5 
floor(-5.2);     -6 
ceiling(-5.2);   -5 
fix(a);          FIX(A)

\endsection
\item[FIXP]
FIXP                                                    (page 46)

The FIXP logical operator returns true if its argument is an integer.

        FIXP(expression) or FIXP simple_expression

expression can be any valid REDUCE expression, simple_expression
must be a single identifier or begin with a prefix operator.

Examples:
if fixp 1.5 then write "ok" else write "not";             not 
if fixp(a) then write "ok" else write "not";              not 
a := 15;                                                  A := 15 
if fixp(a) then write "ok" else write "not";              ok

Logical operators can only be used inside conditional expressions such as
IF...THEN or WHILE...DO.

\endsection
\item[FLOOR]
FLOOR                                                   (page 73)

        FLOOR(expression)

This operator returns the floor (i.e., the greatest integer less than
or equal to its argument) if its argument has a numerical value.  For
positive numbers, this is equivalent to FIX.  For non-numeric
arguments, the value is an expression in the original operator.

Examples:
floor 3.4;               3 
fix 3.4;                 3 
floor(-5.2);             -6 
fix(-5.2);                -5 
floor a;                 FLOOR(A)

\endsection
\item[FOR]
FOR                                                     (page 65)

The FOR command is used for iterative loops.  There are many
possible forms it can take.

                   /                   \
   /               |STEP <number> UNTIL|        \
   |<var>:=<number>|                   |<number>|
FOR|               |         :         |        |<action> <exprn>
   |               \                   /        |
   |EACH <var> IN <list>                        |
   \                                            /

 where <action> ::= DO|PRODUCT|SUM|COLLECT|JOIN.

var can be any valid REDUCE identifier except T or NIL, inc, start and
stop can be any expression that evaluates to a positive or negative
integer. list must be a valid LIST structure.  The action taken must
be one of the actions shown above, each of which is followed by a
single REDUCE expression, statement or a GROUP (<<...>>) or BLOCK
(BEGIN...END) statement.

Examples:
for i := 1:10 sum i;                             55
for a := -2 step 3 until 6 product a;
                                                 -8 
a := 3;                                          A := 3 
for iter := 4:a do write iter; 
m := 0;                                          M := 0 
for s := 10 step -1 until 3 do 
        <<d := 10*s;m := m + d>>; 
m;                                               520
                                                  2    2    2
for each x in {q,r,s} sum x**2;                  Q  + R  + S
                                                     1   1   1
for i := 1:4 collect 1/i;                        {1,---,---,---}
                                                     2   3   4

for i := 1:3 join list solve(x**2 + i*x + 1,x); 
                              SQRT(3)*I - 1
                         {{X=---------------,
                                    2

                               - (SQRT(3)*I + 1)
                           X=--------------------},
                                      2

                          {X=-1},

                              SQRT(5) - 3      - SQRT(5) - 3
                          {X=-------------,X=----------------}}
                                   2                2
        
The behaviour of each of the five action words follows:

                           Action Word Behaviour
Keyword   Argument Type                    Action
   do    statement, command, group   Evaluates its argument once
         or block                    for each iteration of the loop,
                                     not saving results
collect expression, statement,       Evaluates its argument once for
        command, group, block, list  each iteration of the loop,
                                     storing the results in a list
                                     which is returned by the for
                                     statement when done
 join   list or an operator which    Evaluates its argument once for
        produces a list              each iteration of the loop,
                                     appending the elements in each
                                     individual result list onto the
                                     overall result list
product expression, statement,       Evaluates its argument once for
        command, group or block      each iteration of the loop,
                                     multiplying the results together
                                     and returning the overall product
  sum   expression, statement,       Evaluates its argument once for
        command, group or block      each iteration of the loop,
                                     adding the results together and
                                     returning the overall sum

For number-driven FOR statements, if the ending limit is smaller than
the beginning limit (larger in the case of negative steps) the action
statement is not executed at all.  The iterative variable is local to
the FOR statement, and does not affect the value of an identifier with
the same name.  For list-driven FOR statements, if the list is empty,
the action statement is not executed, but no error occurs.

You can use nested FOR statements, with the inner FOR statement after
the action keyword.  You must make sure that your inner statement
returns an expression that the outer statement can handle.

\endsection
\item[FORALL]
FORALL                                                  (pages 141, 142)

See the LET construction.

\endsection
\item[FOREACH]
FOREACH                                                 (page 57--59, 195)

FOREACH is a synonym for the FOR EACH variant of the
FOR construct.  It is designed to iterate down a list, and an
error will occur if a list is not used.  The use of FOR EACH is
preferred to FOREACH.

        FOREACH variable in list action expression
 where action ::= DO|PRODUCT|SUM|COLLECT|JOIN

Example:
                                    2    2    2
foreach x in {q,r,s} sum x**2;     Q  + R  + S

\endsection
\xitem[FORDER command]
FORDER command                                          (pages 268, 271)

\endsection
\item[FORT]
FORT                                                    (page 108)

When FORT is on, output is given Fortran-compatible syntax.  Default
is OFF.

Examples:
on fort;
df(sin(7*x + y),x);               ANS=7.*COS(7*X+Y)
on rounded;
b := log(sin(pi/5 + n*pi));       B=LOG(SIN(3.14159265359*N+0.628318530718))

REDUCE results can be written to a file (using OUT) and used as data
by Fortran programs when FORT is in effect.  FORT knows about correct
statement length, continuation characters, defining a symbol when it
is first used, and other Fortran details.

The GENTRAN package offers many more possibilities than the FORT
switch.  It produces Fortran (or C or Ratfor) code from REDUCE
procedures or structured specifications, including facilities for
producing double precision output.

\endsection
\item[FORT_WIDTH]
FORT_WIDTH                                              (page 111)

The FORT_WIDTH variable sets the number of characters in a line of
Fortran-compatible output produced when the FORT switch is on.
Default is 70.

Examples:
fort_width := 30;                     FORT_WIDTH := 30
on fort;
df(sin(x**3*y),x);                         ANS=3.*COS(X
                                          . **3*Y)*X**2*
                                          . Y

FORT_WIDTH includes the usually blank characters at the beginning
of the card.  As you may notice above, it is conservative and makes the
lines even shorter than it was told.

\endsection
\item[FORTRAN]
FORTRAN                                                 (pages 108, 110)

REDUCE can produce FORTRAN syntax printed expressions with the switch 
        ON FORT

There are also two major packages concerned with generating FORTRAN,
GENTRAN and SCOPE.  The first of these is an embedded language for
defining FORTRAN program fragments or program units, with parts
substituted from algebraic calculation.  SCOPE is a system for
optimising the form of FORTRAN expressions, usually used in
conjunction with GENTRAN.

\endsection
\xitem[FRAME command]
FRAME command                                           (pages 265, 271)

\endsection
\item[FREEOF]
FREEOF                                                  (page 46)
The FREEOF logical operator returns TRUE if its first argument does
not contain its second argument anywhere in its structure.

        FREEOF(expression,kernel) or expression FREEOF kernel

expression can be any valid scalar REDUCE expression, kernel must
be a kernel expression (see Kernel).

Examples:                                                                2
a := x + sin(y)**2 + log sin z;                 A := LOG(SIN(Z)) + SIN(Y)  + X 
if freeof(a,sin(y)) 
    then write "free" else write "not free";
                                                not free 
if freeof(a,sin(x)) 
    then write "free" else write "not free";
                                                free 
if a freeof sin z 
    then write "free" else write "not free";
                                                not free

Logical operators can only be used in conditional expressions such as 
IF...THEN or WHILE...DO.

\endsection
\item[FULLPREC]
FULLPREC

Trailing zeroes of rounded numbers to the full system precision are
normally not printed.  If this information is needed, for example to get a
more understandable indication of the accuracy of certain data, the switch
FULLPREC can be turned on.

Examples:
        on rounded;
        1/2;                    0.5
        on fullprec;
        ws;                     0.500000000000

This is just an output options which neither influences the accuracy
of the computation nor does it give additional information about the
precision of the results.  See also SCIENTIFIC_NOTATION.

\endsection
\item[FULLROOTS]
FULLROOTS                                               (page 87)

Since roots of cubic and quartic polynomials can often be very
messy, a switch FULLROOTS controls the production
of results in closed form. SOLVE will apply the
formulas for explicit forms for degrees 3 and 4 only if
FULLROOTS is ON. Otherwise the result forms
are built using ROOT_OF. Default is OFF.

\endsection
\xitem[Function]
Function                                                (page 175)

\endsection
\item[G]
G                                                       (page 206)

G is an n-ary operator used to denote a product of gamma matrices
contracted with Lorentz four-vectors, in high-energy physics.
        G(identifier,vector-expr
{,vector-expr})

identifier is a scalar identifier representing a fermion line
identifier, vector-expr can be any valid vector expression,
representing a vector or a gamma matrix.

Examples:
vector aa,bb,cc;
vector a;
g(line1,aa,bb);                      AA.BB
g(line2,aa,a);                       0
g(id,aa,bb,cc);                      0
g(li1,aa,bb) + k;                    AA.BB + K
let aa.bb = m*k;
g(ln1,aa)*g(ln1,bb);                 K*M
g(ln1,aa)*g(ln2,bb);                 0

The vector A is reserved in arguments of G to denote the special gamma
matrix gamma_5.  It must be declared to be a vector before you use it.

Gamma matrix expressions are associated with fermion lines in a
Feynman diagram.  If more than one line occurs in an expression, the
gamma matrices involved are separate (operating in independent spin
space), as shown in the last two example lines above.  A product of
gamma matrices associated with a single line can be entered either as
a single G command with several vector arguments, or as products of
separate G commands each with a single argument.

While the product of vectors is not defined, the product, sum and
difference of several gamma expressions are defined, as is the product
of a gamma expression with a scalar.  If an expression involving gamma
matrices includes a scalar, the scalar is treated as if it were the
product of itself with a unit 4 x 4 matrix.

Dirac expressions are evaluated by computing the trace of the
expression using the commutation algebra of gamma matrices.  The
algorithms used are described in articles by J. S. R. Chisholm in Il
Nuovo Cimento X, Vol.  30, p. 426, 1963, and J. Kahane, Journal of
Mathematical Physics, Vol. 9, p. 1732, 1968.  The trace is then
divided by 4 to distinguish between the trace of a scalar and the
trace of an expression that is the product of a scalar with a unit 4 x
4 matrix.

Trace calculations may be prevented over any line identifier by
declaring it to be NOSPUR.  If it is later desired to evaluate these
traces, the declaration can be undone with the SPUR declaration.

The notation of Bjorken and Drell, Relativistic Quantum Mechanics,
1964, is assumed in all operations involving gamma matrices.  For an
example of the use of G in a calculation, see the REDUCE
User's Manual.

\endsection
\item[GAMMA]
GAMMA                                                   (pages 185, 394)

The GAMMA operator returns the Gamma function.

        GAMMA(expression)

Examples:
        load_package specfn;          (SPECFN)
        gamma(10);                    362880    
        gamma(1/2);                   SQRT(PI)

\endsection
\item[Gamma Function]
Gamma Function                                          (pages 185, 394)

See GAMMA.

\endsection
\item[GC]
GC

With the GC switch, you can turn the garbage collection messages on
or off.  The form of the message depends on the particular Lisp used for
the REDUCE implementation.

See RECLAIM for an explanation of garbage collection.  REDUCE does
garbage collection when needed even if you have turned the notices off.

\endsection
\item[GCD]
GCD (operator and switch)                               (pages 123, 124)

The GCD operator returns the greatest common divisor of two
polynomials.

        GCD(expression,expression)

expression must be a polynomial (or integer), otherwise an error
occurs.

Examples:
gcd(2*x**2 - 2*y**2,4*x + 4*y);                                2*(X + Y) 
gcd(sin(x),x**2 + 1);                                          1  
gcd(765,68);                                                   17

The operator GCD described here provides an explicit means to find the
gcd of two expressions.  The switch GCD described below simplifies
expressions by finding and cancelling gcd's at every opportunity.  When
the switch EZGCD is also on, gcd's are figured using the EZ GCD
algorithm, which is usually faster.

GCD switch

With the GC switch, you can turn the garbage collection messages on
or off.  The form of the message depends on the particular Lisp used for
the REDUCE implementation.


See RECLAIM for an explanation of garbage collection.  REDUCE does
garbage collection when needed even if you have turned the notices off.

\endsection
\item[GDIMENSION]
GDIMENSION                                              (page 300)

     GDIMENSION(bas[,vars]) 

where bas is a GROEBNER basis in the current term order which must be
LEX term order (see IDEAL parameters).  GDIMENSION computes the
dimension of the ideal spanned by the given basis.

GDIMENSION cannot be called with other TERM orders.

\endsection
\item[GEGENBAUERP]
GEGENBAUERP                                             (page 185)

The GEGENBAUERP operator computes Gegenbauer's (ultraspherical)
polynomials.

        GEGENBAUERP(integer,expression,expression)

Examples:
        load_package specfn;             (SPECFN)
                                                   2
        GegenbauerP(3,2,xx);             4*XX*(8*XX  - 3)

        GegenbauerP(3,2,4);              2000

\endsection
\xitem[GEN(I)]
GEN(I)                                                  (page 379)

\endsection
\xitem[Generalized Hypergeometric functions]
Generalized Hypergeometric functions                    (page 187)

\endsection
\item[GENTRAN]
GENTRAN                                                 (page 180)

Author: Barbara L. Gates

This package is an automatic code GENerator and TRANslator.  It constructs
complete numerical programs based on sets of algorithmic specifications and
symbolic expressions.  Formatted FORTRAN, RATFOR or C code can be generated
through a series of interactive commands or under the control of a template
processing routine.  Large expressions can be automatically segmented into
subexpressions of manageable size, and a special file-handling mechanism
maintains stacks of open I/O channels to allow output to be sent to any
number of files simultaneously and to facilitate recursive invocation of the
whole code generation process.

\endsection
\xitem[GETCSYSTEM command]
GETCSYSTEM command                                      (page 235)

\endsection
\xitem[GETROOT]
GETROOT                                                 (page 370)

\endsection
\xitem[GFNEWT]
GFNEWT                                                  (page 371)

\endsection
\xitem[GFROOT]
GFROOT                                                  (page 371)

\endsection
\item[GINDEPENDENT_SETS]
GINDEPENDENT_SETS                                       (page 300)

        GINDEPENDENT_SETS(bas[,vars])

where bas is a GROEBNER basis in LEX term order (which must be the
current TERM order) with the specified variables (see IDEAL
parameters).

GINDEPENDENT_SETS computes the maximal left independent variable sets
of the ideal, that are the variable sets which play the role of free
parameters in the current ideal basis. Each set is a list which is a
subset of the variable list. The result is a list of these sets. For
an ideal with dimension zero the list is empty.  The
Kredel-Weispfenning algorithm is used.

The operator cannot be called under another TERM order.

\endsection
\xitem[GL(I)]
GL(I)                                                   (page 379)

\endsection
\item[GLEXCONVERT]
GLEXCONVERT                                             (page 300)

        GLEXCONVERT(bas[,vars][,MAXDEG=mx][,NEWVARS=nv])

where bas is a GROEBNER basis in the current term order, mx (optional)
is a positive integer and nvl (optional) is a list of variables (see
IDEAL parameters).

The operator GLEXCONVERT converts the basis of a zero-dimensional
ideal (finite number of isolated solutions) from arbitrary ordering
into a basis under LEX term order.

The parameter newvars defines the new variable sequence. If omitted,
the original variable sequence is used. If only a subset of variables
is specified here, the partial ideal basis is evaluated.

If newvars is a list with one element, the minimal UNIVARIATE
polynomial is computed.

maxdeg is an upper limit for the degrees.  The algorithm stops with an
error message, if this limit is reached.

A warning occurs, if the ideal is not zero dimensional.

During the call the TERM order of the input basis must be active.

\endsection
\item[GLTBASIS]
GLTBASIS                                                (pages 299, 303)

If GLTBASIS set on, the leading terms of the result basis of a
GROEBNER or GROEBNERF calculation are extracted. They are collected as
a basis of monomials, which is available as value of the global
variable GLTB.

\endsection
\xitem[GNUPLOT]
GNUPLOT                                                 (page 181)

\endsection
\xitem[GO TO]
GO TO                                                   (page 63)

\endsection
\item[GosperAlg]
Gosper's Algorithm                                      (page 403)

See SUM and PROD.

\endsection
\xitem[GRAD operator]
GRAD 
      operator                                          (page 234)

\endsection
\xitem[grad operator]
grad operator                                           (page 358)

\endsection
\xitem[gradient vector field]
gradient 
      vector field                                      (page 234)

\endsection
\item[GRADLEX]
GRADLEX                                                 (page 293)

The terms are ordered first with their total degree, and if the total
degree is identical the comparison is LEX term order.  With Groebner
basis calculations this term order produces polynomials of lowest
degree.

\endsection
\item[GRADLEXGRADLEX]
GRADLEXGRADLEX

The terms are separated into two groups where the second parameter of
the TORDER call determines the length of the first group.  For a
comparison first the total degrees of both variable groups are
compared.  If both are equal GRADLEX term order comparison is applied
to the first group, and if that does not decide GRADLEX term order is
applied for the second group.  This order has the elimination property
for the variable groups.  It can be used e.g. for separating variables
from parameters.  The terms are ordered first with their total degree,
and if the total degree is identical the comparison is LEX term order.
With Groebner basis calculations this term order produces polynomials
of lowest degree.

\endsection
\item[GREDUCE]
GREDUCE                                                 (page 307)

        GREDUCE(exp, exp1, exp2, ... , expm}[,vars])

where exp is an expression, and {exp1, exp2, ... , expm} is a list of
expressions or equations and vars is an optional list of variables
(see IDEAL parameters).

GREDUCE is functionally equivalent with a call to GROEBNER and then a
call to PREDUCE.

\endsection
\item[GROEBFULLREDUCTION]
GROEBFULLREDUCTION                                      (page 298)

If GROEBFULLREDUCTION set off, the polynomial reduction steps during
GROEBNER and GROEBNERF are limited to the pure head term reduction;
subsequent terms are reduced otherwise.

By default GROEBFULLREDUCTION is on.

\endsection
\item[GROEBMONFAC]
GROEBMONFAC                                             (page 304)

The variable GROEBMONFAC is connected to the handling of monomial
factors.  A monomial factor is a product of variable powers as a
factor, e.g. x**2*y in x**3*y - 2*x**2*y**2.  A monomial factor
represents a solution of the type x = 0 or y = 0 with a certain
multiplicity.  With GROEBNERF the multiplicity of monomial factors is
lowered to the value of the shared variable GROEBMONFAC which by
default is 1 (= monomial factors remain present, but their
multiplicity is brought down). With GROEBMONFAC:= 0 the monomial
factors are suppressed completely.

\endsection
\item[GROEBNER]
GROEBNER                                                (pages 181, 296)

        GROEBNER({exp, ...}[,{var, ...}])

where {exp, ... } is a list of expressions or equations, {var, ... }
is an optional list of variables (see IDEAL PARAMETERS).

The operator GROEBNER implements the Buchberger algorithm for
computing Groebner bases for a given set of expressions with respect
to the given set of variables in the order given.  As a side effect,
the sequence of variables is stored as a REDUCE list in the shared
variable GVARSLAST - this is important in cases where the algorithm
rearranges the variable sequence because GROEBOPT is ON.

Example:

   groebner({x**2+y**2-1,x-y})          {X - Y,2*Y**2 -1}

See also GROEBNERF, GVARSLAST, GROEBOPT, GROEBPREREDUCE,
GROEBFULLREDUCTION, GLTBASIS, GLTB, GLTERMS, GROEBSTAT, TRGROEB,
TRGROEBS, GROEBPROT, GROEBPROTFILE, GROEBNERT.

\endsection
\item[Groebner_Bases]
Groebner Bases                                          (page 291)

The GROEBNER package calculates Groebner bases using the Buchberger
algorithm and provides related algorithms for arithmetic with ideal
bases, such as ideal quotients, Hilbert polynomials, basis conversion,
independent variable set.

Some routines of the Groebner package are used by SOLVE -- in
that context the package is loaded automatically. However, if you
want to use the package by explict calls you must load it by 

    load_package groebner;

For the common parameter setting of most operators in this package 
see IDEAL PARAMETERS.

\endsection
\item[GROEBNERF]
GROEBNERF                                               (pages 302, 304, 318)

        GROEBNERF({exp, ...}[,{var, ...}] [,{nz, ... }]);

where {exp, ... } is a list of expressions or equations, {var, ...} is
an optional list of variables (see IDEAL parameters) and {nz,... } is
an optional list of polynomials to be considered as non zero for this
calculation.

GROEBNERF tries to separate polynomials into individual factors and to
branch the computation in a recursive manner (factorization tree).
The result is a list of partial Groebner bases.  Multiplicities (one
factor with a higher power, the same partial basis twice) are deleted
as early as possible in order to speed up the calculation.

The third parameter of GROEBNERF declares some polynomials
nonzero. If any of these is found in a branch of the calculation
the branch is canceled. 

Example:

groebnerf({ 3*x**2*y+2*x*y+y+9*x**2+5*x = 3,  
            2*x**3*y-x*y-y+6*x**3-2*x**2-3*x = -3, 
            x**3*y+x**2*y+3*x**3+2*x**2 }, {y,x});

       {{Y - 3,X},

                      2
    {2*Y + 2*X - 1,2*X  - 5*X - 5}}

See also GROEBRESMAX, GROEBMONFAC, GROEBRESTRICTION, GROEBNER,
GVARSLAST, GROEBOPT, GROEBPREREDUCE, GROEBFULLREDUCTION, GLTBASIS,
GLTB, GLTERMS, GROEBSTAT, TRGROEB, TRGROEBS, GROEBNERT.

\endsection
\item[GROEBNERT]
GROEBNERT                                               (page 311)

        GROEBNERT(v}=exp,...}[,vars])

where v are KERNELS (simple or indexed variables), exp are polynomials
and optional vars are variables (see IDEAL parameters).

GROEBNERT is functionally equivalent to a GROEBNER call for {exp,...},
but the result is a set of equations where the left-hand sides are the
basis elements while the right-hand sides are the same values
expressed as combinations of the input formulas, expressed in terms of
the names v.

Example:

    groebnert({p1=2*x**2+4*y**2-100,p2=2*x-y+1});

   GB1 := {2*X - Y + 1=P2,

           2
        9*Y  - 2*Y - 199= - 2*X*P2 - Y*P2 + 2*P1 + P2}


\endsection
\item[GROEBOPT]
GROEBOPT                                                (pages 298, 303)

If GROEBOPT is set ON, the sequence of variables is optimized with
respect to execution speed of GROEBNER calculations; note that the
final list of variables is available in GVARSLAST.  By default
GROEBOPT is off, conserving the original variable sequence.

An explicitly declared dependency using the DEPEND declaration
superseeds the variable optimization.

Example:

   depend a, x, y;

guarantees that a will be placed in front of x and y.

\endsection
\item[GROEBPREREDUCE]
GROEBPREREDUCE                                          (pages 298, 303)

If GROEBPREREDUCE set ON, GROEBNER and GROEBNERF try to simplify the
input expressions: if the head term of an input expression is a
multiple of the head term of another expression, it can be reduced;
these reductions are done cyclicly as long as possible in order to
shorten the main part of the algorithm.

By default GROEBPREREDUCE is off.

\endsection
\item[GROEBPROT]
GROEBPROT                                               (page 309)

If GROEBPROT is ON the computation steps during PREDUCE, GREDUCE and
GROEBNER are collected in a list which is assigned to the variable
GROEBPROTFILE.

\endsection
\item[GROEBPROTFILE]
GROEBPROTFILE                                           (page 309)

If GROEBPROT is ON the computation steps during PREDUCE, GREDUCE and
GROEBNER are collected in a list which is assigned to the variable
GROEBPROTFILE.

\endsection
\xitem[GROEBRES]
GROEBRES                                                (page 304)

\endsection
\item[GROEBRESMAX]
GROEBRESMAX                                             (page 305)

The variable GROEBRESMAX controls during GROEBNERF calculations the
number of partial results.  Its default value is 300.  If more partial
results are calculated, the calculation is terminated.

\endsection
\item[GROEBRESTRICTION]
GROEBRESTRICTION                                        (page 306)

During GROEBNERF calculations irrelevant branches can be excluded by
setting the variable GROEBRESTRICTION. The following restrictions are
implemented:

     GROEBRESTRICTION := NONNEGATIVE
     GROEBRESTRICTION := POSITIVE

With NONNEGATIVE branches are excluded where one polynomial has no
nonnegative real zeros; with POSITIVE the restriction is sharpened to
positive zeros only.

\endsection
\item[GROEBSTAT]
GROEBSTAT                                               (pages 299, 303)

If GROEBSTAT is on, a summary of the GROEBNER or GROEBNERF computation
is printed at the end including the computing time, the number of
intermediate H polynomials and the counters for the criteria hits.

\endsection
\xitem[GROEPOSTPROC]
GROEPOSTPROC                                            (page 319)

\endsection
\xitem[GROESOLVE]
GROESOLVE                                               (page 318)

\endsection
\xitem[Group statement]
Group statement                                         (pages 55, 56, 61)

\endsection
\xitem[grouped ordering]
grouped ordering                                        (page 315)

\endsection
\item[GSORT]
GSORT                                                   (page 322)

        GSORT(p[,vars])

where p is a polynomial or a list of polynomials, vars in an optional
list of variables (see IDEAL parameters).

The polynomials are reordered and sorted corresponding to the current
TERM order.

Example:

  torder lex;
                                            2                2
  gsort(x**2+2x*y+y**2,{y,x});            {Y  + 2 * Y * X + X }

\endsection
\item[GSPLIT]
GSPLIT                                                  (page 323)

        GSPLIT(p[,vars]);

where p is a polynomial or a list of polynomials, vars in an optional
list of variables (see IDEAL parameters).

The polynomial is reordered corresponding to the the current TERM
order and then separated into leading term and reductum. Result is a
list with the leading term as first and the reductum as second
element.

Example:

  torder lex;
                                          2           2
  gsplit(x**2+2x*y+y**2,{y,x});         {Y , 2*Y*X + X }

\endsection
\item[GSPOLY]
GSPOLY                                                  (page 324)

        GSPOLY(p1,p2[,vars]);

where p1 and p2 are polynomials, vars in an optional list of variables
(see IDEAL parameters).

The SUBTRACTION polynomial of p1 and p2 is computed corresponding to
the method of the Buchberger algorithm for computing GROEBNER bases:
p1 and p2 are multiplied with terms such that when subtracting them
the leading terms cancel each other.

\endsection
\item[GVARS]
GVARS                                                   (page 296)

        GVARS({exp,exp,... })

 where exp are expressions or equations.

GVARS extracts from the expressions the KERNELs which can 
play the role of variables for a GROEBNER or GROEBNERF calculation. 

\endsection
\item[GVARSLAST]
GVARSLAST                                               (page 298)

After a GROEBNER or GROEBNERF calculation the actual variable sequence
is stored in the variable GVARSLAST.  If GROEBOPT is ON, GVARSLAST
shows the variable sequence after reordering.

\endsection
\item[GZERODIM?]
GZERODIM?                                               (page 299)

  GZERODIM!?(basis[,vars])

where basis is a Groebner basis in the current 
TERM order with the specified variables (see IDEAL parameters). 

GZERODIM!? tests whether the ideal spanned by the given basis 
has dimension zero. If yes, the number of zeros is returned,
NIL otherwise.

\endsection
\item[Hankel Functions]
Hankel Functions                                        (pages 185, 396)

Part of the SPECFN package.  See HANKEL1 and HANKEL2.

\endsection
\item[HANKEL1]
HANKEL1                                                 (pages 185, 396)

The HANKEL1 operator returns the Hankel function of the first kind.

HANKEL1(order,argument)

Examples:
        load_package specfn;                 (SPECFN)
        Hankel1 (1/2,pi);                    - SQRT(2) / PI 
        on rounded; 
        Hankel1 (1,3);                       0.324674424792

The operator HANKEL1 is also called Bessel function of the third kind.
There is currently no numeric evaluation of Hankel functions.

\endsection
\item[HANKEL2]
HANKEL2                                                 (pages 185, 396)

The HANKEL2 operator returns the Hankel function of the second kind.

        HANKEL2(order,argument)

Examples:
        load_package specfn;                 (SPECFN)
        Hankel2 (1/2,pi);                    - SQRT(2) / PI 
        on rounded; 
        Hankel2 (1,3);                        0.324674424792

The operator HANKEL2 is also called Bessel function of the third kind.
There is currently no numeric evaluation of Hankel functions.

\endsection
\item[HERMITEP]
HERMITEP                                                (page 185)

The HERMITEP operator returns the nth Hermite Polynomial.

        HERMITEP(integer,expression)

Examples:
        load_package specfn;            (SPECFN)
                                                  2
        HermiteP(3,xx);                 4*XX*(2*XX  - 3) 
        HermiteP(3,4);                  464

Hermite polynomials are computed using the recurrence relation:
  
HermiteP(n,x) := 2x*HermiteP(n-1,x) - 2*(n-1)*HermiteP(n-2,x)  with 
HermiteP(0,x) := 1 and HermiteP(1,x) := 2x

\endsection
\xitem[HFACTORS scale factors]
HFACTORS scale factors                                  (page 234)

\endsection
\xitem[High energy trace]
High energy trace                                       (page 209)

\endsection
\item[HIGH_POW]
HIGH_POW                                                (page 115)

The variable HIGH_POW is set by COEFF to the highest power
of the variable of interest in the given expression.  You can access this
variable for use in further computation or display.

Examples:
coeff((x+1)^5*(x*(y+3)^2)^2,x); {0,
                                
                                 0,
                                
                                  4       3       2
                                 Y  + 12*Y  + 54*Y  + 108*Y + 81,
                                
                                     4       3       2
                                 5*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
                                
                                      4       3       2
                                 10*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
                                
                                      4       3       2
                                 10*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
                                
                                     4       3       2
                                 5*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
                                
                                  4       3       2
                                 Y  + 12*Y  + 54*Y  + 108*Y + 81}

high_pow;                       7

\endsection
\xitem[HIGHESTDERIV]
HIGHESTDERIV                                            (page 350)

\endsection
\item[HILBERTPOLYNOMIAL]
HILBERTPOLYNOMIAL                                       (page 321)

        HILBERTPOLYNOMIAL(bas,[vars])

where bas is a GROEBNER basis in the current TERM order and vars is an
optional variable list(see IDEAL parameters).

The degree of the HILBERT polynomial is the dimension of the ideal
spanned by the basis. For an ideal of dimension zero the Hilbert
polynomial is a constant which is the number of common zeros of the
ideal (including eventual multiplicities).  The HOLLMANN algorithm is
used.

\endsection
\xitem[History]
History                                                 (page 158)

\endsection
\xitem[Hodge-* duality operator]
Hodge-* duality operator                                (pages 256, 266)

\endsection
\item[HORNER]
HORNER

When the HORNER switch is on, polynomial expressions are printed
in Horner's form for faster and safer numerical evaluation. Default
is OFF. The leading variable of the expression is selected as
Horner variable. To select the Horner variable explicitly use the 
KORDER declaration.

Examples:
on horner;                       3           2
(13p-4q)^3;             ( - 64)*Q  + P*(624*Q  + P*(( - 2028)*Q + P*2197))
korder q;
                              3                 2
ws;                     2197*P  + Q*(( - 2028)*P  + Q*(624*P + Q*(-64)))

\endsection
\xitem[HYPERGEOMETRIC]
Hypergeometric Functions                                (page 397)

The HYPERGEOMETRIC operator  provides simplifications for the 
generalised hypergeometric functions. 
The HYPERGEOMETRIC operator is included in the package specfn2.

        HYPERGEOMETRIC(list_of_parameters,list_of_parameters,argument)

Examples:
load_package specfn;                     (SPECFN)
hypergeometric ({1/2,1},{3/2},-x^2);     \rfrac{atan(x)}{x}
hypergeometric ({},{},z);                e^z

The special case with length of the first list equals 2 and
length of the second list equals 1 is often called "hypergeometric function".

\endsection
\item[HYPOT]
HYPOT                                                   (pages 76, 78)

        HYPOT(expression,expression)

If ROUNDED is on, and the two arguments evaluate to numbers, this
operator returns the square root of the sums of the squares of the
arguments in a manner that avoids intermediate overflow.  In other cases,
an expression in the original operator is returned.

Examples:
hypot(3,4);      HYPOT(3,4) 
on rounded; 
ws;              5.0 
hypot(a,b);      HYPOT(A,B)

\endsection
\item[I]
I                                                       (page 36)

REDUCE knows I is the square root of -1, and that i^2 = -1.

Examples:
(a + b*i)*(c + d*i);               A*C + A*D*I + B*C*I - B*D
i**2;                              -1

I cannot be used as an identifier.  It is all right to use I as an
index variable in a FOR loop, or as a local (SCALAR) variable inside a
BEGIN...END block, but it loses its definition as the square root of
-1 inside the block in that case.

Only the simplest properties of i are known by REDUCE unless the
switch COMPLEX is turned on, which implements full complex arithmetic
in factoring, simplification, and functional values.  COMPLEX is
ordinarily off.

\endsection
\xitem[i]
i                                                       (page 223)

\endsection
\xitem[ideal dimension]
ideal dimension                                         (page 300)

\endsection
\item[IDEAL PARAMETERS]
IDEAL PARAMETERS

Most operators of the Groebner package compute expressions in a
polynomial ring which given as R[var,var,...]  where R is the current
REDUCE coefficient domain.  All algebraically exact domains of REDUCE
are supported. The package can operate over rings and fields. The
operation mode is distinguished automatically.  In general the ring
mode is a bit faster than the field mode.  The factoring variant can
be applied only over domains which allow you factoring of multivariate
polynomials.

The variable sequence var is either given explicitly as argument in
form of a list, or it is extracted automatically from the
expressions.  In the second case the current REDUCE system order is
used (see KORDER) for arranging the variables.  If some kernels should
play the role of formal parameters (the ground domain R then is the
polynomial ring over these), the variable sequences must be given
explicitly.

All REDUCE kernels can be used as variables.  But please note, that
all variables are considered as independent; e.g. when using SIN(A)
and COS(A) as variables, the basic relation SIN(A)^2+COS(A)^2-1=0 must
be explicitly added to an equation set because the Groebner operators
do not include such knowledge automatically.

The terms (monomials) in polynomials are arranged according to the
current TERM ORDER.  Note that the algebraic properties of the
computed results only are valid as long as neither the ordering nor
the variable sequence changes.

The input expressions exp can be polynomials P, rational functions N/D
or equations LH=RH built from polynomials or rational functions.
Apart from the tracing algorithms GROEBNERT and PREDUCET, where the
equations have a specific meaning, equations are converted to simple
expressions by taking the difference of the left-hand and right-hand
sides LH-RH=>P.  Rational functions are converted to polynomials by
converting the expression to a common denominator form first, and then
using the numerator only N=>P.  So eventual zeros of the denominators
are ignored.
 
A basis on input or output of an algorithm is coded as a list
of expressions {exp,exp,...}.

\endsection
\item[IDEALQUOTIENT]
IDEALQUOTIENT                                           (page 320)

        IDEALQUOTIENT({exp, ...}, d [,{var, ...}])

where {exp,...} is a list of expressions or equations, d is a single
expression or equation and {var,...} is an optional list of variables
(see IDEAL parameters).

IDEALQUOTIENT computes the ideal quotient: ideal spanned by the
expressions {exp,...}  divided by the single polynomial/expression
f. The result is the GROEBNER basis of the quotient ideal.

\endsection
\item[Identifier]
Identifier                                              (page 35)

Identifiers in REDUCE consist of one or more alphanumeric characters,
of which the first must be alphabetical.  The maximum number of
characters allowed is system dependent, but is usually over 100.
However, printing is simplified if they are kept under 25 characters.

You can also use special characters in your identifiers, but each must be
preceded by an exclamation point ! as an escape character.  Useful
special characters are # $ % ^ & * - + = ? < > ~ | / ! and
the space.  Note that the use of the exclamation point as a special
character requires a second exclamation point as an escape character.
The underscore _ is special in this regard.  It must be preceded
by an escape character in the first position in an identifier, but is
treated like a normal letter within an identifier.

Other characters, such as ( ) # ; ` ' " can also be used if preceded
by a !, but as they have special meanings to the Lisp reader it is
best to avoid them to avoid confusion.

Many system identifiers have * before or after their names, or -
between words.  If you accidentally pick one of these names for your
own identifier, it could have disastrous effects.  For this reason it
is wise not to include * or - anywhere in your identifiers.

You will notice that REDUCE does not use the escape characters when it
prints identifiers containing special characters; however, you still
must use them when you refer to these identifiers.  Be careful when
editing statements containing escaped special characters to treat the
character and its escape as an inseparable pair.

Identifiers are used for variable names, labels for GO TO statements,
and names of arrays, matrices, operators, and procedures.  Once an
identifier is used as a matrix, array, scalar or operator identifier,
it may not be used again as a matrix, array or operator.  An operator
or array identifier may later be used as a scalar without problems,
but a matrix identifier cannot be used as a scalar.  All procedures
are entered into the system as operators, so the name of a procedure
may not be used as a matrix, array, or operator identifier either.

\endsection
\item[IF]
IF                                                      (pages 55, 56)

The IF command is a conditional statement that executes a statement
if a condition is true, and optionally another statement if it is not.

        IF condition THEN statement {ELSE statement}

condition must be a logical or comparison operator that evaluates to
true or false.  statement must be a single REDUCE statement or a GROUP
(<<...>>) or BLOCK (BEGIN...END) statement.

Examples:
if x = 5 then a := b+c else a := d+f;                           D + F
x := 9;                                                         X := 9
if numberp x and x<20 then y := sqrt(x) else write "illegal";   3 
clear x;
if numberp x and x<20 then y := sqrt(x) else write "illegal";   illegal
x := 12;                                                        X := 12
a := if x < 5 then 100 else 150;                                A := 150
b := u**(if x < 10 then 2);                                     B := 1
                                                                       2
bb := u**(if x > 10 then 2);                                    BB := U

An IF statement may be used inside an assignment statement and sets
its value depending on the conditions, or used anywhere else an
expression would be valid, as shown in the last example.  If there is
no ELSE clause, the value is 0 if a number is expected, and nothing
otherwise.

The ELSE clause may be left out if no action is to be taken if the
condition is false.

The condition may be a compound conditional statement using AND or
OR.  If a non-conditional statement, such as a constant, is used by
accident, it is assumed to have value true.
 
Be sure to use GROUP or BLOCK statements after THEN or ELSE.

The IF operator is right associative.  The following constructions are
examples:

(1)
        IF condition THEN IF condition THEN action ELSE action

which is equivalent to
        IF condition THEN (IF condition THEN action ELSE action);

(2)     IF condition THEN action ELSE IF condition THEN action ELSE action
which is equivalent to
        IF condition THEN action ELSE 
            (IF condition THEN action ELSE action).

\endsection
\item[IFACTOR]
IFACTOR                                                 (page 121)

When the IFACTOR switch is on, any integer terms appearing as a result
of the FACTORIZE command are factored themselves into primes.  Default
is OFF.  If the argument of FACTORIZE is an integer,
IFACTOR has no effect, since the integer is always factored.

Examples:
factorize(4*x**2 + 28*x + 48);                  {4,X + 3,X + 4}
factorize(22587);                               {3,7529}
on ifactor;
factorize(4*x**2 + 28*x + 48);                  {2,2,X + 4,X + 3}
factorize(22587);                               {3,7529}

Constant terms that appear within nonconstant polynomial factors are
not factored.

The IFACTOR switch affects only factoring done specifically with
FACTORIZE, not on factoring done automatically when the FACTOR switch
is on.

\endsection
\xitem[imaginary unit]
imaginary unit                                          (page 223)

\endsection
\item[IMPART]
IMPART                                                  (pages 72, 73, 75)

        IMPART(expression) or IMPART simple_expression

This operator returns the imaginary part of an expression, if that
argument has an numerical value.  A non-numerical argument is returned
as an expression in the operators REPART and IMPART.

Examples:
impart(1+i);              1 
impart(a+i*b);            REPART(B) + IMPART(A)

\endsection
\item[IN]
IN                                                      (page 153)

The IN command takes a list of file names and inputs each file into
the system.
        IN filename{,filename}

filename must be in the current directory, or be a valid pathname.
If the file name is not an identifier, double quote marks (") are
needed around the file name.


A message is given if the file cannot be found, or has a mistake
in it.

Ending the command with a semicolon causes the file to be echoed to the
screen; ending it with a dollar sign does not echo the file.  If you want
some but not all of a file echoed, turn the switch ECHO on or off
in the file.

An efficient way to develop procedures in REDUCE is to write them into a file 
using a system editor of your choice, and then input the
files into an active REDUCE session.  REDUCE reparses the procedure as
it takes information from the file, overwriting the previous procedure
definition.  When it accepts the procedure, it echoes its name to the screen.
Data can also be input to the system from files.

Files to be read in should always end in END; to avoid
end-of-file problems.  Note that this is an additional END; to any
ending procedures in the file.

\endsection
\item[Indefinite integration]
Indefinite integration                                  (page 80)

See the INT operator.

\endsection
\xitem[independent sets]
independent sets                                        (page 300)

\endsection
\item[INDEX]
INDEX                                                   (page 206)

The declaration INDEX flags a four-vector as an index for subsequent
high-energy physics calculations.
        INDEX vector-id{,vector-id}

vector-id must have been declared of type VECTOR.

Examples:
vector aa,bb,cc;
index uu;
let aa.bb = 0;
(aa.uu)*(bb.uu);                        0 
(aa.uu)*(cc.uu);                        AA.CC

Index variables are used to represent contraction over components of
vectors when scalar products are taken by the . operator, as well as
indicating contraction for the EPS operator or metric tensor.

The special status of a vector as an index can be revoked with the
declaration REMIND.  The object remains a vector, however.

\endsection
\xitem[INDEX_SYMMETRIES command]
INDEX_SYMMETRIES command                                (page 271)

\endsection
\xitem[INDEXRANGE command]
INDEXRANGE command                                      (page 271)

\endsection
\xitem[INDEXSYMMETRIES command]
INDEXSYMMETRIES command                                 (page 262)

\endsection
\item[INFINITY]
INFINITY                                                (pages 37, 368)

The name INFINITY is used to represent the infinite positive number.
However, at the present time, arithmetic in terms of this operator reflects
finite arithmetic, rather than true operations on infinity.

\endsection
\item[INFIX]
INFIX                                                   (page 94)

INFIX declares identifiers to be infix operators.

        INFIX identifier {,identifier}

identifier can be any valid REDUCE identifier, which has not already
been declared an operator, array or matrix, and is not reserved by the
system.

Examples:
infix aa;
for all x,y let aa(x,y) = cos(x)*cos(y) - sin(x)*sin(y);
x aa y;                                        COS(X)*COS(Y) - SIN(X)*SIN(Y)
                                                 - SQRT(3)
pi/3 aa pi/2;                                  ------------
                                                    2
aa(pi,pi);                                     1

A LET statement must be used to attach functionality to the operator.
Note that the operator is defined in prefix form in the LET statement.
After its definition, the operator may be used in either prefix or infix
mode.  The above operator aa finds the cosine of the sum of two angles by
the formula 
        cos(x+y) = cos(x)*cos(y) - sin(x)*sin(y).
Precedence may be attached to infix operators with the PRECEDENCE declaration.

User-defined infix operators may be used in prefix form.  If they are used
in infix form, a space must be left on each side of the operator to avoid
ambiguity.  Infix operators are always binary.

\endsection
\xitem[Infix operator]
Infix operator                                          (pages 38--41)

\endsection
\xitem[inner product]
inner product                                           (page 357)

\endsection
\xitem[inner product exterior form]
inner product 
      exterior form                                     (page 254)

\endsection
\item[INPUT]
INPUT                                                   (page 158)

The INPUT command returns the input expression to the REDUCE numbered
prompt that is its argument.
        INPUT(number) or INPUT number


number must be between 1 and the current REDUCE prompt number.

An expression brought back by INPUT can be re-executed with new
values or switch settings, or used as an argument in another expression.
The command WS brings back the results of a numbered REDUCE
statement.  Two lists contain every input and every output statement since
the beginning of the session.  If your session is very long, storage space
begins to fill up with these expressions, so it is a good idea to end the
session once in a while, saving needed expressions to files with the
SAVEAS and OUT commands.

Switch settings and LET statements can also be re-executed by using
INPUT.

An error message is given if a number is called for that has not yet been used.

\endsection
\xitem[Input]
Input                                                   (page 153)

\endsection
\xitem[Instant evaluation]
Instant evaluation                          (pages 68, 117, 140, 162, 164)

\endsection
\item[INT]
INT (operator and switch)                               (pages 80, 160)

The INT operator performs analytic integration on a variety of
functions.

        INT(expression,kernel)

expression can be any scalar expression. involving polynomials, log
functions, exponential functions, or tangent or arctangent
expressions.  INT attempts expressions involving error functions,
dilogarithms and other trigonometric expressions.  Integrals involving
algebraic extensions (such as square roots) may not succeed. kernel
must be a REDUCE KERNEL.

Examples:
                                     3
                                 X*(X  + 12)
int(x**3 + 3,x);                -------------
                                      4

                                  2*X
                                 E   *( - COS(X) + 2*SIN(x))
int(sin(x)*exp(2*x),x);         -----------------------------
                                              5

                             SQRT(2)*(LOG( - SQRT(2) + X) - LOG(SQRT(2) + X))
int(1/(x^2-2),x);           --------------------------------------------------
                                                    4

                                          COS(X)
                                  - ATAN(--------)
                                            2
int(sin(x)/(4 + cos(x)**2),x);  -------------------
                                         2

                                         SQRT(x - 1)
int(1/sqrt(x^2-x),x);           INT(---------------------,X)
                                     SQRT(X)*X - SQRT(X)

Note that REDUCE could not handle the last integral with its default
integrator, since the integrand involves a square root.  However, the
integral can be found using the ALGINT package.  Alternatively, you
could add a rule using the LET statement to evaluate this integral.

The arbitrary constant of integration is not shown.  Definite
integrals can be found by evaluating the result at the limits of
integration (use ROUNDED) and subtracting the lower from the higher.
Evaluation can be easily done by the SUB operator.

When INT cannot find an integral it returns an expression involving
formal INT expressions unless the switch FAILHARD has been set. If not
all of the expression can be integrated, the switch NOLNR controls
whether a partially integrated result should be returned or not.

INT switch

The INT switch specifies an interactive mode of operation.  Default
ON.


There is no reason to turn INT off during interactive calculations,
since there are no benefits to be gained.  If you do have INT off
while inputting a file, and REDUCE finds an error, it prints the message
``Continuing with parsing only''.  In this state, REDUCE accepts only
END; or BYE; from the keyboard;
everything else is ignored, even the command ON INT.

\endsection
\item[INTEGER]
INTEGER                                                 (page 61)

The INTEGER declaration must be made immediately after a BEGIN (or
other variable declaration such as REAL and SCALAR) and declares local
integer variables.  They are initialised to 0.

        INTEGER identifier{,identifier}

identifier may be any valid REDUCE identifier, except T or NIL.

Integer variables remain local, and do not share values with variables
of the same name outside the BEGIN...END block.  When the block is
finished, the variables are removed.  You may use the words REAL or
SCALAR in the place of INTEGER.  INTEGER does not indicate
type-checking by the current REDUCE; it is only for your own
information.  Declaration statements must immediately follow the
BEGIN, without a semicolon between BEGIN and the first variable
declaration.

Any variables used inside BEGIN...END blocks that were not declared
SCALAR, REAL or INTEGER are global, and any change made to them inside
the block affects their global value.  Any ARRAY or MATRIX declared
inside a block is always global.

\endsection
\xitem[Integer]
Integer                                                 (page 44)

\endsection
\item[Integration]
Integration                                             (pages 80, 92)

See INT, ALGINT or NUM_INT.
\endsection
\xitem[integration definite (simple)]
integration definite (simple)                           (page 236)
      line                                              (page 238)
      volume                                            (page 237)

\endsection
\xitem[Interactive use]
Interactive use                                         (pages 157, 160)

\endsection
\item[INTERPOL]
INTERPOL                                                (page 127)

INTERPOL generates an interpolation polynomial.

   INTERPOL(values,variable,points)

values and points are LISTs of equal length and variable is an
algebraic expression (preferably a KERNEL).  The interpolation
polynomial is generated in the given variable of degree
length(values)-1.  The unique polynomial F is defined by the property
that for corresponding elements V of values and P of points the
relation F(P)=V holds.

Examples:
f := for i:=1:4 collect(i**3-1);   F := {0,7,26,63} 
p := {1,2,3,4};                    P := {1,2,3,4} 
                                    3
interpol(f,x,p);                   X  - 1

The Aitken-Neville interpolation algorithm is used which guarantees a
stable result even with rounded numbers and an ill-conditioned problem.

\endsection
\item[INTSTR]
INTSTR                                                  (page 98)

If INTSTR (for ``internal structure'') is on, arguments of an
operator are printed in a more structured form.

Examples:
        operator f;
        f(2x+2y);               F(2*X + 2*Y)
        on intstr;
        ws;                     F(2*(X + Y))

\endsection
\item[ISOLATER]
ISOLATER                                                        (page 369)

        ISOLATER(expression)
        ISOLATER simple_expresion
        ISOLATER(expression, POSITIVE)
        ISOLATER(expression, NEGATIVE)
        ISOLATER(expression, lo, hi)

The ISOLATER function produces a list of rational intervals, each
containing a single real root of the univariate polynomial p, within
the specified region, but does not find the roots.  If arg2 and arg3
are not present, all real roots are found.  If the additional
arguments are present, they restrict the region of consideration.  

If arg2=NEGATIVE then only negative roots of p are included; if
arg2=POSITIVE then only positive roots of p are included.  Zero roots
are excluded.

If arguments are (p,arg2,arg3) then Arg2 and Arg3 must be r (a real
number) or EXCLUDE r, or a member of the list POSITIVE, NEGATIVE,
INFINITY, -INFINITY. EXCLUDE r causes the value r to be excluded from
the region.  The order of the sequence arg2, arg3 is unimportant.
Assuming that arg2 <= arg3 when both are numeric, then

      {-INFINITY,INFINITY}   is equivalent to  {} represents all roots;
      {arg2,NEGATIVE}           represents     -1<r<arg2;
      {arg2,POSITIVE}           represents     arg2<r<1;

In each of the following, replacing an arg with EXCLUDE arg converts
the corresponding inclusive <= to the exclusive <

      {arg2,-INFINITY}   represents  -1<r<=arg2;
      {arg2,INFINITY}    represents  arg2<=r<1;
      {arg2,arg3}        represents  arg2<=r<=arg3;

If zero is in the interval the zero root is included.

Examples:
    load_package roots;
                                    - 1689018745249963   1689018745249963
    isolater(x^3-3x^2+2x+10);   {{---------------------,------------------}}
                                     281474976710656     281474976710656

    isolater(x^2+y^2);          ***** Univariate polynomial required
\endsection
\item[JACOBIP]
JACOBIP                                                         (page 185)

The JACOBIP operator computes the nth Jacobi Polynomial.

        JACOBIP(integer,expression,expression,expression)

Examples:
load_package specfn;            (SPECFN)
                                         3        2
                                 7*(65*XX  - 13*XX  - 13*XX + 1)
JacobiP(3,4,5,xx);              ---------------------------------
                                                8

                                 94465
JacobiP(3,4,5,6);               -------
                                   8

\endsection
\item[JOIN]
JOIN                                                    (page 57)

See the FOR loop construction.
\endsection
\xitem[KEEP command]
KEEP command                                            (page 268, 271)

\endsection
\item[KERNEL]
Kernel                                                  (pages 97, 98, 101, 114)

A KERNEL is a form that cannot be modified further by the REDUCE
canonical simplifier.  Scalar variables are always kernels.  The other
important class of kernels are operators with their arguments.  Some
examples should help clarify this concept:

        Expression                     Kernel?

          x                              Yes
          varname                        Yes
          cos(a)                         Yes
          log(sin(x**2))                 Yes
          a*b                            No
          (x+y)**4                       No
          matrix-identifier              No

Many REDUCE operators expect kernels among their arguments.  Error
messages result from attempts to use non-kernel expressions for these
arguments.

\endsection
\item[KORDER]
KORDER                                                  (page 114)

The KORDER declaration changes the internal canonical ordering of
kernels.

        KORDER kernel{,kernel}

kernel must be a REDUCE KERNEL.

The declaration KORDER changes the internal ordering, but not the print
ordering, so the effects cannot be seen on output.  However, in some 
calculations, the order of the variables can have significant effects on the 
time and space demands of a calculation.  If you are doing a demanding 
calculation with several kernels, you can experiment with changing the 
canonical ordering to improve behaviour.

The first kernel in the argument list is given the highest priority,
the second gets the next highest, and so on.  Kernels not named in a
KORDER ordering otherwise.  A new KORDER declaration replaces the
previous one.  To return to canonical ordering, use the command KORDER
NIL.

To change the print ordering, use the declaration ORDER.

\endsection
\item[Kummer Functions]
Kummer Functions                                        (pages 185, 397)

Part of the SPECFN package.  See KUMMERM and KUMMERU.

\endsection
\item[KUMMERM]
KUMMERM                                                 (pages 185, 397)

The KUMMERM operator returns Kummer's M function.

        KUMMERM(parameter,parameter,argument)

Examples:
        load_package specfn;              (SPECFN)
                                           X
        kummerm(1,1,x);                   E
        on rounded;
        kummerm(1,3,1.3);                 1.62046942914

Kummer's M function is one of the Confluent Hypergeometric functions.
For reference see the HYPERGEOMETRIC operator.

\endsection
\item[KUMMERU]
KUMMERU                                                 (pages 185, 397)

The KUMMERU operator returns Kummer's U function.

        KUMMERU(parameter,parameter,argument)

Examples:
        load_package specfn;               (SPECFN)
        df(kummeru(1,1,x),x)               - KUMMERU(2,2,X)

Kummer's U function is one of the Confluent Hypergeometric functions.
For reference see the HYPERGEOMETRIC operator.

\endsection
\xitem[l'Hopital's rule]
l'Hopital's rule                                        (pages 329, 359)

\endsection
\xitem[Label]
Label                                                   (page 63)

\endsection
\item[LAGUERREP]
LAGUERREP                                               (page 185)

The LAGUERREP operator computes the nth Laguerre Polynomial.
The two argument call of LaguerreP is a (common) abbreviation of
LaguerreP(n,0,x).

        LAGUERREP(integer,expression)  or
        LAGUERREP(integer,expression,expression)

Examples:
        load_package specfn;            (SPECFN)
                                              3       2
                                          - XX  + 9*XX  - 18*XX + 6
        LaguerreP(3,xx);                ----------------------------
                                                     6

        LaguerreP(2,3,4);               -2

Laguerre polynomials are computed using the recurrence relation:

LaguerreP(n,a,x) := (2n+a-1-x)/n*LaguerreP(n-1,a,x) - 
                        (n+a-1) * LaguerreP(n-2,a,x) with 
 
LaguerreP(0,a,x) := 1 and LaguerreP(2,a,x) := -x+1+a

\endsection
\xitem[LAMBDA]
LAMBDA                                                  (page 194)

\endsection
\xitem[Laplacian vector field]
Laplacian 
      vector field                                      (page 234)

\endsection
\xitem[Laurent series]
Laurent series                                          (page 405)

\endsection
\xitem[Laurent series expansions]
Laurent series expansions                               (page 413)

\endsection
\item[LCM]
LCM                                                     (page 125)

The LCM switch instructs REDUCE to compute the least common multiple
of denominators whenever rational expressions occur.  Default is ON.

Examples:
off lcm;
                                                    2*X*(X - Y)
z := 1/(x**2 - y**2) + 1/(x-y)**2;     Z := ---------------------------
                                              4      3          3    4
                                             X  - 2*X *Y + 2*X*Y  - Y
on lcm;
                                               2*X*(X - Y)
z;                                     ---------------------------
                                         4      3          3    4
                                        X  - 2*X *Y + 2*X*Y  - Y

                                                       2*x
zz := 1/(x**2 - y**2) + 1/(x-y)**2;    ZZ := -----------------------
                                               3    2        2    3
                                              X  - X *Y - X*Y  + Y
on gcd;
                                                 2*x
z;                                     -----------------------
                                         3    2        2    3
                                        X  - X *Y - X*Y  + Y

Note that LCM has effect only when rational expressions are first
combined.  It does not examine existing structures for simplifications
on display.  That is shown above when z is entered with LCM off.  It
remains unsimplified even after LCM is turned back on.  However, a new
variable containing the same expression is simplified on entry.  The
switch GCD does examine existing structures, as shown in the last
example line above.

Full greatest common divisor calculations become expensive if work
with large rational expressions is required.  A considerable savings
of time can be had if a full gcd check is made only when denominators
are combined, and only a partial check for numerators.  This is the
effect of the LCM switch.

\endsection
\item[LCOF]
LCOF                                                    (page 129)

The LCOF operator returns the leading coefficient of a given expression
with respect to a given variable.

        LCOF(expression,kernel)

expression is ordinarily a polynomial. If RATARG is on, a rational
expression may also be used, otherwise an error results.  kernel must
be a KERNEL.

Examples:
lcof((x+2*y)**5,y);                                      32 
                                                               2
lcof((x + y*sin(x))**2 + cos(x)*sin(x)**2,sin(x));       COS(X)  + Y 
                                                          2
lcof(x**2 + 3*x + 17,y);                                 X  + 3*X + 17

If the kernel does not appear in the expression, LCOF returns the
expression.

\endsection
\xitem[Leading coefficient]
Leading coefficient                                     (page 129)

\endsection
\item[LEGENDREP]
LEGENDREP                                               (page 185)

The binary LEGENDREP operator computes the nth Legendre Polynomial
which is a special case of the nth Jacobi Polynomial with
 
LegendreP(n,x) := JacobiP(n,0,0,x)
  
The ternary form returns the associated Legendre Polynomial (see below).

        LEGENDREP(integer,expression)      or
        LEGENDREP(integer,expression,expression)

Examples:
load_package specfn;            (SPECFN)
                                         2
                                 XX*(5*XX  - 3)
LegendreP(3,xx);                ----------------
                                       2
                                            2
LegendreP(3,2,xx);              15*XX*( - XX  + 1)

The ternary form of the operator LEGENDREP is the associated
Legendre Polynomial defined as  

  P(n,m,x) = (-1)**m * (1-x**2)**(m/2) * df(LegendreP(n,x),x,m)

\endsection
\item[LENGTH]
LENGTH                                       (pages 49, 68, 82, 119, 121, 163)

The LENGTH operator returns the number of items in a LIST, the number
of terms in an expression, or the dimensions of an array or matrix.

        LENGTH(expr) or LENGTH expr

expr can be a list structure, an array, a matrix, or a scalar expression.

Examples:
alist := {a,b,{ww,xx,yy,zz}};     ALIST := {A,B,{WW,XX,YY,ZZ}} 
length alist;                     3  
length third alist;               4  
dlist := {d};                     DLIST := {D} 
length rest dlist;                0  
matrix mmm(4,5);  
length mmm;                       {4,5} 
array aaa(5,3,2); 
length aaa;                       {6,4,3}
                                           2
                                          X  + 6*X + 9
eex := (x+3)**2/(x-y);            EEX := --------------
                                             X - Y
length eex;                       5

An item in a list that is itself a list only counts as one item.  An
error message will be printed if LENGTH is called on a matrix which
has not had its dimensions set.  The LENGTH of an array includes the
zeroeth element of each dimension, showing the full number of elements
allocated.  (Declaring an array A with n elements allocates
A(0),A(1),...,A(n).)  The LENGTH of an expression is the total number
of additive terms appearing in the numerator and denominator of the
expression.  Note that subtraction of a term is represented internally
as addition of a negative term.

\endsection
\item[LESSSPACE]
LESSSPACE

You can turn on the switch LESSSPACE if you want fewer
blank lines in your output.

\endsection
\item[LET]
LET                             (pages 76, 79, 90, 92--94, 95, 138, 148, 173)

The LET command defines general or specific substitution rules.

LET identifier = expression{,identifier = expression}

identifier can be any valid REDUCE identifier except an array, and in
some cases can be an expression; expression can be any valid REDUCE
expression.

Examples:
let a = sin(x);
b := a;                                B := SIN X; 
let c = a;  
                                        SIN(X) 
exp(a);                                E
                                             2
a := x**2;                             A := X
                                         2
                                        X
exp(a);                                E
                                        SIN(X)
exp(b);                                E
                                         2
                                        X
exp(c);                                E
let m + n = p; 
                                        5
(m + n)**5;                            P
operator h; 
let h(u,v) = u - v; 
h(u,v);                                U - V 
h(x,y);                                H(X,Y) 
array q(10); 
let q(1) = 15;                         ***** Substitution for 0 not allowed

The LET command is also used to activate a RULE sets.

LET list{,list}

list can be an explicit RULE LIST, or evaluate to a rule list.

Examples:
trig1 := {cos(~x)*cos(~y) => (cos(x+y)+cos(x-y))/2,
          cos(~x)*sin(~y) => (sin(x+y)-sin(x-y))/2,
          sin(~x)*sin(~y) => (cos(x-y)-cos(x+y))/2,
          cos(~x)^2       => (1+cos(2*x))/2,
          sin(~x)^2       => (1-cos(2*x))/2}$
let trig1;
                                         COS(A - B) + COS(A + B)
cos(a)*cos(b);                          -------------------------
                                                    2

A LET   command returns no    value, though the substitution  rule  is
entered.  Assignment rules made  by ASSIGN and  LET  rules are at  the
same level, and  cancel  each other.  There is  a  difference in their
operation, however, as shown in  the  first example: a LET  assignment
tracks the changes in what it is assigned to, while a := assignment is
fixed at the value it originally had.

The  use of expressions  as  left-hand  sides  of LET statements  is a
little complicated.  The rules of operation are:

(i) Expressions of the form A*B = C  do not change A, B  or C, but set
A*B to C.

(ii) Expressions  of the form A+B =  C substitute C - B  for A, but do
not change B or C.

(iii) Expressions of the form A-B =  C substitute B +  C for A, but do
not change B or C.

(iv) Expressions of the form A/B = C substitute B*C  for A, but do not
change B or C.

(v)  Expressions of the form A**N  = C substitute  C for A**N in every
expression  of a power  of A to  N or  greater.  An asymptotic command
such as A**N = 0 sets all terms involving A  to powers greater than or
equal to N to 0.  Finite fields may be  generated by requiring modular
arithmetic (the MODULAR switch) and  defining the primitive polynomial
via a LET statement.

LET substitutions involving expressions are cleared by using the CLEAR
command with exactly the same expression.

Note when a simple LET statement is used to assign functionality to an
operator, it is  valid only for the  exact identifiers  used.  For the
use of the  LET command  to  attach more general functionality  to  an
operator, see FORALL.

Arrays as a whole cannot be  arguments to LET statements, but matrices
as a  whole  can be   legal arguments,  provided both   arguments  are
matrices.  However, it is important to  note that the two matrices are
then linked.   Any  change to an   element of  one  matrix changes the
corresponding value in the other.  Unless you want this behaviour, you
should not  use LET for matrices.   The assignment operator ASSIGN can
be used for   non-tracking  assignments, avoiding the side    effects.
Matrices are redimensioned as needed in LET statements.

When  array or matrix  elements are used as the  left-hand side of LET
statements,  the contents  of that element   is used  as the argument.
When the contents is  a number or some other  expression that is not a
valid left-hand  side  for LET, you   get  an error  message.   If the
contents is   an identifier  or simple expression,    the LET rule  is
globally attached to that identifier, and is in effect not only inside
the  array or matrix,  but everywhere.  Because  of such unwanted side
effects, you should not  use LET with array  or matrix  elements.  The
assignment operator := can be used to put values  into array or matrix
elements without the side effects.

Local variables  declared inside BEGIN...END  blocks cannot be used as
the  left-hand  side of LET  statements.   However, BEGIN...END blocks
themselves can be used as the right-hand side  of LET statements.  The
construction:
        FOR ALL vars
        LET operator(vars) = block
is an alternative to the 
        PROCEDURE name(vars); block
construction.  One important difference  between the two constructions
is that the vars as formal parameters to a procedure have their global
values protected against change by the  procedure, while the vars of a
LET statement are changed globally by its actions.

Be careful in using a construction such as LET x = x + 1 except inside
a controlled loop  statement.  The process of resubstitution continues
until a stack overflow message is given.

The LET statement may be used to make global changes to variables from
inside procedures.   If X  is a  formal parameter to  a procedure, the
command LET x = ...  makes the change  to the  calling variable.   For
example, if a procedure was defined by
        procedure f(x,y);
        let x = 15;
and the procedure was called as
        f(a,b);
A would have its  value  changed to 15.   Be  careful when using   LET
statements inside procedures to avoid unwanted side effects.

It is also important to be careful when  replacing LET statements with
other LET  statements.  The overlapping  of these substitutions can be
unpredictable.  Ordinarily the latest-entered  rule is the first to be
applied.  Sometimes the  previous rule is superseded completely; other
times it stays around as a special case.   The order of entering a set
of related  LET expressions    is  very important  to their   eventual
behaviour.   The best  approach  is to assume  that  the rules will be
applied in an arbitrary order.

\endsection
\xitem[Levi-Cevita tensor]
Levi-Cevita tensor                                      (page 267)

\endsection
\item[LEX]

The terms are ordered lexicographically:  two terms t1 t2 are compared
for their degrees along the fixed variable sequence: t1 is higher than
t2 if the first different degree is higher in t1.   This order has the
elimination property for  GROEBNER  BASIS calculations.  If  the ideal
has  a univariate polynomial in  the last variable  the groebner basis
will  contain such   polynomial. LEX  is   best suited  for solving of
polynomial equation systems.

\endsection
\item[LHS]
LHS                                                     (page 47)

The LHS operator returns the left-hand side of an EQUATION, such as
those returned in a list by SOLVE.

        LHS(equation) or LHS equation

equation must be an equation of the form 
        LEFT-HAND SIDE = RIGHT-HAND SIDE.

Examples:
polly := (x+3)*(x^4+2x+1);
                          5      4      2
                POLLY := X  + 3*X  + 2*X  + 7*X + 3

pollyroots := solve(polly,x);
                                           3     2
                POLLYROOTS := {X=ROOT_OF(X_  - X_  + X_ + 1,X_),X=-1,X=-3}

variable := lhs first pollyroots;
                VARIABLE := X

\endsection
\xitem[LIE Derivative]
Lie Derivative                                          (page 255)

\endsection
\item[LIMIT]
LIMIT                                                   (pages 329, 360)

LIMITS is  a fast limit  package for REDUCE  for functions which  are
continuous except  for computable poles  and singularities, based  on
some earlier  work by Ian  Cohen and John  P. Fitch.   The  Truncated
Power  Series package  is  used  for non-critical  points,  at  which
the  value of  the function  is the  constant term  in the  expansion
around  that point.    l'Hopital's rule  is used  in critical  cases,
with preprocessing  of 1-1  forms and reformatting  of product  forms
in order  to apply  l'Hopital's rule.   A limited  amount of  bounded
arithmetic is also employed where applicable.        

        LIMIT(expr,var,limpoint) or 
        LIMIT!+(expr,var,limpoint) or
        LIMIT!-(expr,var,limpoint) 

where expr is an expression depending of the variable var (a KERNEL)
and limpoint is the limit point.  If the limit depends upon the
direction of approach to the limpoint, the operators LIMIT!+ and
LIMIT!- may be used.

Examples:
        limit(x*cot(x),x,0);                    0
                                                 2
        limit((2x+5)/(3x-2),x,infinity);        ---
                                                 3

\endsection
\xitem[LIMIT0]
LIMIT0                                                  (page 330)

\endsection
\xitem[LIMIT1]
LIMIT1                                                  (page 330)

\endsection
\xitem[LIMIT2]

\endsection
\xitem[LIMIT2]
LIMIT2                                                  (page 330)

\endsection
\xitem[LIMITS]
LIMITS                                                  (page 181)

\endsection
\xitem[LIMITS package]
LIMITS package                                          (page 329)

\endsection
\item[LIMITEDFACTORS]
LIMITEDFACTORS

To get limited factorisation in cases where it is too expensive to use
full multivariate polynomial factorisation, the switch
LIMITEDFACTORS can be turned on.  In that case, only ``inexpensive''
factoring operations, such as square-free factorisation, will be used
when FACTORIZE is called.

Examples:
a := (y-x)^2*(y^3+2x*y+5)*(y^2-3x*y+7)$
factorize a;         { - X + Y,
                       X - Y,
                                3
                       2*X*Y + Y  + 5,
                                2
                       3*X*Y - Y  - 7}
on limitedfactors;
factorize a;         { - X + Y,
                      X - Y,
                         2  2        4        3          5      3      2
                      6*X *Y  + 3*X*Y  - 2*X*Y  + X*Y - Y  - 7*Y  - 5*Y  - 35}

\endsection
\xitem[line integrals]
line integrals                          (page 238)

\endsection
\item[LINEAR]
LINEAR                                                  (page 91)

An operator can be declared linear in its first argument over powers of
its second argument by the declaration LINEAR.

        LINEAR operator{,operator}

operator must have been declared to be an operator.  Be careful not to
use a system operator name, because this command may change its
definition.  The operator being declared must have at least two
arguments, and the second one must be a kernel.

Examples:
operator f; 
linear f; 
f(0,x);                              0 
f(-y,x);                             - F(1,X)*Y 
f(y+z,x);                            F(1,X)*(Y + Z) 
f(y*z,x);                            F(1,X)*Y*Z 
depend z,x; 
f(y*z,x);                            F(Z,X)*Y 
                                        1
f(y/z,x);                            F(---,X)*Y
                                        Z

depend y,x;  
                                        Y
f(y/z,x);                            F(---,X)
                                        Z
nodepend z,x; 
                                      F(Y,X)
f(y/z,x);                            --------
                                        Z

                                          SIN(x)
f(2*e**sin(x),x);                    2*F(E      ,X)

Even when the operator has not had its functionality attached, it
exhibits linear properties as shown in the examples.  Notice the
difference when dependencies are added.  Dependencies are also in
effect when the operator's first argument contains its second, as in
the last line above.

For a fully-developed example of the use of linear operators, refer to
the article in the Journal of Computational Physics, Vol. 14
(1974), pp.  301-317, ``Analytic Computation of Some Integrals in
Fourth Order Quantum Electrodynamics'', by J.A. Fox and A.C. Hearn.
The article includes the complete listing of REDUCE procedures used
for this work.

\endsection
\xitem[Linear operator]
Linear operator                         (pages 91, 92, 95)

\endsection
\xitem[LINEINT]
LINEINT                                 (page 360)

\endsection
\xitem[LINEINT function]
LINEINT function                        (page 238)

\endsection
\item[LINELENGTH]
LINELENGTH                                              (page 100)

The LINELENGTH declaration sets the length of the output line.  Default
is 80.

        LINELENGTH integer

integer must be positive, less than 128 (although this varies from
system to system), and should not be less than 20 or so for proper
operation.

LINELENGTH returns the previous linelength.  If you want the current
linelength value, but not change it, say LINELENGTH NIL.

\endsection
\item[LISP]
LISP                                                    (page 191)

The LISP command changes REDUCE's mode of operation to symbolic.  When
LISP is followed by an expression, that expression is evaluated in
symbolic mode, but REDUCE's mode is not changed.  This command is
equivalent to SYMBOLIC.

Examples:
lisp;                                   NIL
car '(a b c d e);                       A
algebraic;                                        2
c := (lisp car '(first second))**2;     C := FIRST

\endsection
\item[LIST]
LIST                                                    (page 103)

The LIST switch causes REDUCE to print each term in any sum on
separate lines.

Examples:                                             2              2
                                            X*(2*A*X*Y  + 4*A*X*Y + Y  + Z)
x**2*(y**2 + 2*y) + x*(y**2 + z)/(2*a);    ---------------------------------
                                                          2*A
on list;
                                                      2
ws;                                        (X*(2*A*X*Y
                                             + 4*A*X*Y
                                                2
                                             + Y
                                             + Z))/(2*A)

\endsection
\xitem[List]
List                                    (page 49)

\endsection
\item[List(operation)]
List operation                                          (pages 49, 51)

The LIST operator constructs a list from its arguments.
        LIST(item {,item}) or 
        LIST() to construct an empty list.

item can be any REDUCE scalar expression, including another list.
Left and right curly brackets can also be used instead of the operator
LIST to construct a list.

Examples:
liss := list(c,b,c,{xx,yy},3x**2+7x+3,df(sin(2*x),x));
                                                  2
                        LISS := {C,B,C,{XX,YY},3*X  + 7*X + 3,2*COS(2*X)}
length liss;            6 
liss := {c,b,c,{xx,yy},3x**2+7x+3,df(sin(2*x),x)};
                                                  2
                        LISS := {C,B,C,{XX,YY},3*X  + 7*X + 3,2*COS(2*X)}
emptylis := list();     EMPTYLIS := {}
a . emptylis;           {A}

Lists are ordered, hierarchical structures.  The elements stay where
you put them, and only change position in the list if you specifically
change them.  Lists can have nested sublists to any (reasonable)
level.  The PART operator can be used to access elements anywhere
within a list hierarchy.  The LENGTH operator counts the number of
top-level elements of its list argument; elements that are themselves
lists still only count as one element.

\endsection
\item[LISTARGP]
LISTARGP                                                (page 51)

        LISTARGP operator{,operator}

If an operator other than those specifically defined for lists is
given a single argument that is a LIST, then the result of this
operation will be a list in which that operator is applied to each
element of the list.  This process can be inhibited for a specific
operator, or list of operators, by using the declaration LISTARGP.

Examples:
log {a,b,c};                             {LOG(A),LOG(B),LOG(C)} 
listargp log;
log {a,b,c};                             LOG({A,B,C})

It is possible to inhibit such distribution globally by turning on the
switch LISTARGS.  In addition, if an operator has more than one
argument, no such distribution occurs, so LISTARGP has no effect.

\endsection
\item[LISTARGS]
LISTARGS                                                (page 51)

If an operator other than those specifically defined for lists is given a
single argument that is a list, then the result of this operation will be
a list in which that operator is applied to each element of the list.
This process can be inhibited globally by turning on the switch
LISTARGS.

Examples:
        log {a,b,c};            {LOG(A),LOG(B),LOG(C)}
        on listargs;
        log {a,b,c};            LOG({A,B,C})

It is possible to inhibit such distribution for a specific operator by
using the declaration LISTARGP.  In addition, if an operator has
more than one argument, no such distribution occurs, so LISTARGS
has no effect.

\endsection
\item[LN]
LN                                                      (pages 76, 78)

        LN(expression)

expression can be any valid scalar REDUCE expression.

The LN operator returns the natural logarithm of its argument.
However, unlike LOG, there are no algebraic rules associated
with it; it will only evaluate when ROUNDED is on, and the
argument is a real number.

Examples:
ln(x);                              LN(X) 
ln 4;                               LN(4) 
ln(e);                              LN(E) 
df(ln(x),x);                        DF(LN(X),X) 
on rounded; 
ln 4;                               1.38629436112 
ln e;                               1

Because of the restricted algebraic properties of LN, users are
advised to use LOG whenever possible.

\endsection
\xitem[LOAD]
LOAD                                                    (page 214)

\endsection
\item[LOAD_PACKAGE]
LOAD_PACKAGE                                            (pages 177, 188, 215)

The LOAD_PACKAGE command is used to load REDUCE packages, such as
GENTRAN that are not automatically loaded by the system.  

        LOAD_PACKAGE "package_name"

A package is only loaded once; subsequent calls of LOAD_PACKAGE
for the same package name are ignored.

\endsection
\item[LOG]
LOG                                                     (pages 76, 78, 81)

The LOG operator returns the natural logarithm of its argument.

        LOG(expression) or LOG expression

expression can be any valid scalar REDUCE expression.

Examples:
log(x);                              LOG(X) 
log 4;                               LOG(4) 
log(e);                              1 
on rounded; 
log 4;                               1.38629436112

LOG returns a numeric value only when ROUNDED is on.  In that case,
use of a negative argument for LOG results in an error message.  No
error is given on a negative argument when REDUCE is not in that mode.

\endsection
\xitem[LOG10]
LOG10                                                   (pages 76, 78)

\endsection
\item[LOGB]
LOGB                                                    (pages 76, 78)

        LOGB(expression,integer)

expression can be any valid scalar REDUCE expression.

The LOGB operator returns the logarithm of its first argument using
the second argument as base.  However, unlike LOG, there are no
algebraic rules associated with it; it will only evaluate when ROUNDED
is on, and the first argument is a real number.

Examples:
logb(x,2);                          LOGB(X,2) 
logb(4,3);                          LOGB(4,3) 
logb(2,2);                          LOGB(2,2) 
df(logb(x,3),x);                    DF(LOGB(X,3),X) 
on rounded; 
logb(4,3);                          1.26185950714 
logb(2,2);                          1

\endsection
\item[Lommel Functions]
Lommel Functions                                        (pages 185, 397)

Part of the SPECFN package.  See LOMMEL1 and LOMMEL2.

\endsection
\item[LOMMEL1]
LOMMEL1                                                 (pages 185, 397)

        LOMMEL1(integer, integer, expression)

The LOMMEL1 function is defined in terms of the BESSELJ and GAMMA
functions for some of its arguments, and the STRUVEH function for
others.  There are no rules for differentiation or for numerical
evaluation.

Examples:
        load_package specfn;            (SPECFN)
                                                                3
        Lommel1(3,2,xx);                 - 48*BESSELJ(3,XX) + XX
                                         15*STRUVEH(3,XX)*PI
        Lommel1(3,3,xx);                ---------------------
                                                  2

\endsection
\item[LOMMEL2]
LOMMEL2                                                 (pages 185, 397)

        LOMMEL2(integer, integer, expression)

The LOMMEL2 function is defined in terms of the BESSELY, GAMMA and
STRUVEH function for some of its arguments.  There are no rules for
differentiation or for numerical evaluation.

Examples:
load_package specfn;            (SPECFN)
                                  2
Lommel2(3,2,xx);                XX
                                 15*PI*( - BESSELY(3,XX) + STRUVEH(3,XX))
Lommel2(3,3,xx);                ------------------------------------------
                                                    2

\endsection
\xitem[Loop]
Loop                                                    (pages 57, 58)

\endsection
\item[LOW_POW]
LOW_POW                                                 (page 115)

The variable LOW_POW is set by COEFF to the lowest power
of the variable of interest in the given expression.  You can access this
variable for use in further computation or display.

Examples:                         6
coeff((x+2*y)**6,y);            {X ,
                                     5
                                 12*X ,
                                     4
                                 60*X ,
                                      3
                                 160*X ,
                                      2
                                 240*X ,

                                 192*X,

                                 64}

low_pow;                        0
coeff(x**2*(x*sin(y) + 1),x);   {0,0,1,SIN(Y)}
low_pow;                        2

\endsection
\item[LTERM]
LTERM                                                   (pages 130, 203)

The LTERM operator returns the leading term of an expression with
respect to a kernel.

        LTERM(expression,kernel)

expression is ordinarily a polynomial. If RATARG is on, a rational
expression may also be used, otherwise an error results.  kernel must
be a kernel.

Examples:                                        6
lterm((x+2*y)**6,y);                         64*Y 
                                                   8
lterm((x + cos(x))**8 + df(x**2,x),cos(x));  COS(X)
lterm(x**3 + 3*x,y);                         0

\endsection
\xitem[MACRO]
MACRO                                                   (page 196)

\endsection
\item[MAINVAR]
MAINVAR                                                 (page 130)

The MAINVAR operator returns the main variable (in the system's
internal representation) of its argument.

        MAINVAR(expression)

expression is usually a polynomial, but may be any valid REDUCE scalar
expression.  In the case of a rational function, the main variable of
the numerator is returned.  The main variable returned is a KERNEL.

Examples:                             2                    2            2
test := (a + b + c)**2;      TEST := A  + 2*A*B + 2*A*C + B  + 2*B*C + C
mainvar(test);               A 
korder c,b,a; 
mainvar(test);               C 
mainvar(2*cos(x)**2);        COS(X) 
mainvar(17);                 0

The main variable is the first variable in the canonical ordering of
kernels.  Generally, alphabetically ordered functions come first, then
alphabetically ordered identifiers (variables).  Numbers come last,
and as far as MAINVAR is concerned belong in the family 0.  The
canonical ordering can be changed by the declaration KORDER, as shown
above.

\endsection
\item[MASS]
MASS                                                    (pages 208, 210)

The MASS command associates a scalar variable as a mass with
the corresponding vector variable, in high-energy physics calculations.
        MASS vector-var=scalar-var {,vector-var=scalar-var}

vector-var can be a declared vector variable;  MASS will declare
it to be of type VECTOR if it is not.  This may override an existing
matrix variable by that name.  scalar-var must be a scalar variable.

Examples:
vector bb,cc;
mass cc=m;
mshell cc;
                                        2
cc.cc;                                 M

Once a mass has been attached to a vector with a MASS declaration, the
MSHELL declaration puts the associated particle ``on the mass shell.''
Subsequent scalar (.) products of the vector with itself will be
replaced by the square of the mass expression.

\endsection
\item[MAT]
MAT                                                     (pages 161--162)

The MAT operator is used to represent a two-dimensional 
MATRIX.
        MAT((expr{,expr}) {(expr{,expr})})

expr may be any valid REDUCE scalar expression.

Examples:
mat((1,2),(3,4));               MAT(1,1) := 1
                                MAT(2,3) := 2
                                MAT(2,1) := 3
                                MAT(2,2) := 4
mat(2,1);                       ***** Matrix mismatch
                                Cont? (Y or N) 
matrix qt;
qt := ws;                       QT(1,1) := 1
                                QT(1,2) := 2
                                QT(2,1) := 3
                                QT(2,2) := 4 
matrix a,b;
a := mat((x),(y),(z));          A(1,1) := X
                                A(2,1) := Y
                                A(3,1) := Z 
b := mat((sin x,cos x,1));      B(1,1) := SIN(X)
                                B(1,2) := COS(X)
                                B(1,3) := 1

Matrices need not have a size declared (unlike arrays).  MAT
redimensions a matrix variable as needed.  It is necessary, of course,
that all rows be the same length.  An anonymous matrix, as shown in
the first example, must be named before it can be referenced (note
error message).  When using MAT to fill a 1 x n matrix, the row of
values must be inside a second set of parentheses, to eliminate
ambiguity.

\endsection
\item[MATCH]
MATCH                                                   (page 146)

The MATCH command is similar to the LET command, except
that it matches only explicit powers in substitution.

        MATCH expr = expression{,expr = expression}

expr is generally a term involving powers, and is limited by the rules
for the LET command.  expression may be any valid REDUCE scalar
expression.

Examples:
match c**2*a**2 = d;
                                     4      3          3    4
(a+c)**4;                           A  + 4*A *C + 4*A*C  + C  + 6*D
match a+b = c;
a + 2*b;                            B + C
                                     2    2              2
(a + b + c)**2;                     A  - B  + 2*B*C + 3*C
clear a+b;
                                     2                    2            2
(a + b + c)**2;                     A  + 2*A*B + 2*A*C + B  + 2*B*C + C
let p*r = s;
match p*q = ss;
                                     2            2
(a + p*r)**2;                       A  + 2*A*S + S
                                     2             2  2
(a + p*q)**2;                       A  + 2*A*SS + P *Q

Note in the last example that A + B has been explicitly matched after
the squaring was done, replacing each single power of A by C - B.
This kind of substitution, although following the rules, is confusing
and could lead to unrecognisable results.  It is better to use MATCH
with explicit powers or products only.  MATCH should not be used
inside procedures for the same reasons that LET should not be.

Unlike LET substitutions, MATCH substitutions are executed after all
other operations are complete.  The last example shows the
difference. MATCH commands can be cleared by using CLEAR, with exactly
the expression that the original MATCH took.  MATCH commands can also
be done more generally with FOR ALL or FORALL...SUCH THAT commands.

\endsection
\item[MATEIGEN]
MATEIGEN                                                (page 164)

The MATEIGEN operator calculates the eigenvalue equation and the
corresponding eigenvectors of a MATRIX.

        MATEIGEN(matrix-id,tag-id)

matrix-id must be a declared matrix of values, and tag-id must be a
legal REDUCE identifier.

Examples:
aa := mat((2,5),(1,0))$
                                    2
mateigen(aa,alpha);          {{ALPHA  - 2*ALPHA - 5,
                              1,
                                          5*ARBCOMPLEX(1)
                              MAT(1,1) := ---------------
                                             ALPHA - 2

                              MAT(2,1) := ARBCOMPLEX(1)
                             }}
                                              2
charpoly := first first ws;  CHARPOLY := ALPHA  - 2*ALPHA - 5

bb := mat((1,0,1),(1,1,0),(0,0,1))$
                            
mateigen(bb,lamb);          {{LAMB - 1,3,

                             [      0      ]
                             [             ]
                             [ARBCOMPLEX(2)]
                             [             ]
                             [      0      ]

                            }}

The MATEIGEN operator returns a list of lists of three elements.  The
first element is a square free factor of the characteristic
polynomial; the second element is its multiplicity; and the third
element is the corresponding eigenvector.  If the characteristic
polynomial can be completely factored, the product of the first
elements of all the sublists will produce the minimal polynomial.  You
can access the various parts of the answer with the usual list access
operators.

If the matrix is degenerate, more than one eigenvector can be produced
for the same eigenvalue, as shown by more than one arbitrary variable
in the eigenvector.  The identification numbers of the arbitrary
complex variables shown in the examples above may not be the same as
yours.  Note that since LAMBDA is a reserved word in REDUCE, you
cannot use it as a tag-id for this operator.

\endsection
\xitem[Mathematical function]
Mathematical function                                   (page 76)

\endsection
\item[MATRIX]
MATRIX                                                  (page 162)

Identifiers are declared to be of type MATRIX.
        MATRIX identifier (index,index) {,identifier (index,index)}

identifier must not be an already-defined operator or array or the
name of a scalar variable.  Dimensions are optional, and if used
appear inside parentheses.  index must be a positive integer.

Examples:
matrix a,b(1,4),c(4,4);
b(1,1);                                 0
a(1,1);                                 ***** Matrix A not set
a := mat((x0,y0),(x1,y1));              A(1,1) := X0
                                        A(1,2) := Y0
                                        A(2,1) := X0
                                        A(2,2) := X1
length a;                               {2,2}
                                                    2
b := a**2;                              B(1,1) := X0  + X1*Y0
                                        B(1,2) := Y0*(X0 + Y1)
                                        B(2,1) := X1*(X0 + Y1)
                                                            2
                                        B(2,2) := X1*Y0 + Y1

When a matrix variable has not been dimensioned, matrix elements
cannot be referenced until the matrix is set by the MAT operator.
When a matrix is dimensioned in its declaration, matrix elements are
set to 0.  Matrix elements cannot stand for themselves.  When you use
LET on a matrix element, there is no effect unless the element
contains a constant, in which case an error message is returned.  The
same behaviour occurs with CLEAR.  Do not use CLEAR to try to set a
matrix element to 0. LET statements can be applied to matrices as a
whole, if the right-hand side of the expression is a matrix
expression, and the left-hand side identifier has been declared to be
a matrix.

Arithmetical operators apply to matrices of the correct dimensions.
The operators + and - can be used with matrices of the same
dimensions.  The operator * can be used to multiply m x n matrices by
n x p matrices.  Matrix multiplication is non-commutative.  Scalars
can also be multiplied with matrices, with the result that each
element of the matrix is multiplied by the scalar.  The operator /
applied to two matrices computes the first matrix multiplied by the
inverse of the second, if the inverse exists, and produces an error
message otherwise.  Matrices can be divided by scalars, which results
in dividing each element of the matrix.  Scalars can also be divided
by matrices when the matrices are invertible, and the result is the
multiplication of the scalar by the inverse of the matrix.  Matrix
inverses can by found by 1/A or /A, where A is a matrix.  Square
matrices can be raised to positive integer powers, and also to
negative integer powers if they are nonsingular.

When a matrix variable is assigned to the results of a calculation, the
matrix is redimensioned if necessary.

\endsection
\xitem[Matrix assignment]
Matrix assignment                                       (page 168)

\endsection
\xitem[Matrix calculations]
Matrix calculations                                     (page 161)

\endsection
\item[MAX]
MAX                                                     (page 73)

The operator MAX is an n-ary prefix operator, which returns the largest
value in its arguments.

        MAX(expression{,expression})

expression must evaluate to a number.  MAX of an empty list returns 0.

Examples:
max(4,6,10,-1);                                      10 
<<a := 23;b := 2*a;c := 4**2;max(a,b,c)>>;           46 
max(-5,-10,-a);                                      -5

\endsection
\item[MCD]
MCD                                                     (pages 123, 125, 126)

When MCD is on, sums and differences of rational expressions are put
on a common denominator.  Default is ON.

Examples:                                5*A + B*X + B
a/(x+1) + b/5;                          ---------------
                                           5*(X + 1)
off mcd;
                                               -1
a/(x+1) + b/5;                          (X + 1)  *A + 1/5*B

1/6 + 1/7;                              13/42

Even with MCD off, rational expressions involving only numbers are
still put over a common denominator.

Turning MCD off is useful when explicit negative powers are needed, or
if no greatest common divisor calculations are desired, or when
differentiating complicated rational expressions.  Results when MCD is
off are no longer in canonical form, and expressions equivalent to
zero may not simplify to 0.  Some operations, such as factoring cannot
be done while MCD is off.  This option should therefore be used with
some caution.  Turning MCD off is most valuable in intermediate parts
of a complicated calculation, and should be turned back on for the
last stage.

\endsection
\xitem[MEIJERG]
Meijer's G function                                     (page 187)

The MEIJERG operator provides simplifications for Meijer's G  
function. The simplifications are performed towards polynomials,
elementary or
special functions or (generalised) HYPERGEOMETRIC functions.

The MEIJERG operator is included in the package specfn2.

MEIJERG(list of parameters,list of parameters,argument)
The first element of the lists has to be the list containing the
first group (mostly called "m" and "n") of parameters. This passes 
the  four parameters of a Meijer's G function implicitly via the
length of the lists.

Examples:
load specfn2;
MeijerG({{},1},{{0}},x);       &   heaviside(-x+1)
MeijerG({{}},{{1+1/4},1-1/4},(x^2)/4) * sqrt pi;
                & \rfrac{sqrt(2)*sin(x)*x^2}{4*sqrt(x)}

Many well-known functions can be written as G functions,
e.g. exponentials, logarithms, trigonometric functions, Bessel functions
and hypergeometric functions.
The formulae can be found e.g. in 
A.P.Prudnikov, Yu.A.Brychkov, O.I.Marichev: 
Integrals and Series, Volume 3: More special functions,
Gordon and Breach Science Publishers (1990).

\endsection
\xitem[METRIC command]
METRIC command                                          (page 271)

\endsection
\xitem[metric structure]
metric structure                                        (page 262)

\endsection
\item[MIN]
MIN                                                     (page 73)

The operator MIN is an n-ary prefix operator, which returns the
smallest value in its arguments.

        MIN(expression{,expression})

expression must evaluate to a number. MIN of an empty list
returns 0.

Examples:
min(-3,0,17,2);                                     -3 
<<a := 23;b := 2*a;c := 4**2;min(a,b,c)>>;          16 
min(5,10,a);                                        5

\endsection
\xitem[Minimum]
Minimum                                                 (page 182)

\endsection
\item[MKID]
MKID                                                    (page 83)

The MKID command constructs an identifier, given a stem and an identifier
or an integer.

        MKID(stem,leaf)

stem can be any valid REDUCE identifier that does not include escaped
special characters. leaf may be an integer, including one given by a
local variable in a FOR loop, or any other legal group of characters.

Examples:
mkid(x,3);                              X3 
factorize(x^15 - 1);                    {X - 1,

                                          2
                                         X  + X + 1,

                                          4    3    2
                                         X  + X  + X  + X + 1,

                                          8    7    5    4    3
                                         X  - X  + X  - X  + X  - X + 1}

for i := 1:length ws do write set(mkid(f,i),part(ws,i));
                                        X - 1

                                         2
                                        X  + X + 1

                                         4    3    2
                                        X  + X  + X  + X + 1

                                         8    7    5    4    3
                                        X  - X  + X  - X  + X  - X + 1

You can use MKID to construct identifiers from inside procedures.  This
allows you to handle an unknown number of factors, or deal with variable
amounts of data.  It is particularly helpful to attach identifiers to the
answers returned by FACTORIZE and SOLVE.

\endsection
\item[MKPOLY]
MKPOLY                                                  (page 370)

Given a roots list as returned by ROOTS, the operator MKPOLY
constructs a polynomial which has these numbers as roots.

        MKPOLY rl

where rl is a LIST with equations, which all have the same KERNEL on
their left-hand sides and numbers as right-hand sides.

Examples:
                                         4    3    2
        mkpoly{x=1,x=-2,x=i,x=-i};      X  + X  - X  + X - 2


Note that this polynomial is unique only up to a numeric factor.

\endsection
\xitem[MM]
MM                                                      (page 379)

\endsection
\xitem[Mode]
Mode                                                    (page 68)

\endsection
\xitem[Mode communication]
Mode communication                                      (page 197)

\endsection
\item[MODULAR]
MODULAR                                                 (page 134)

When MODULAR is on, polynomial coefficients are reduced by the
modulus set by SETMOD.  If no modulus has been set, MODULAR
has no effect.

Examples:
setmod 2;                              1 
on modular;                             
                                        2    2
(x+y)**2;                              X  + Y
                                        2
145*x**2 + 20*x**3 + 17 + 15*x*y;      X  + X*Y + 1

Modular operations are only conducted on the coefficients, not the
exponents.  The modulus is not restricted to being prime.  When the
modulus is prime, division by a number not relatively prime to the
modulus results in a Zero divisor error message.  When the modulus is
a composite number, division by a power of the modulus results in an
error message, but division by an integer which is a factor of the
modulus does not.  The representation of modular number can be
influenced by BALANCED_MOD.

\endsection
\xitem[Modular coefficient]
Modular coefficient                                     (page 134)

\endsection
\item[MSG]
MSG                                                     (page 218)

When MSG is off, the printing of warning messages is suppressed.  Error
messages are still printed.

Warning messages include those about redimensioning an ARRAY or declaring
an OPERATOR where one is expected.  

\endsection
\item[MSHELL]
MSHELL                                                  (page 210)

The MSHELL command puts particles on the mass shell in high-energy
physics calculations.
        MSHELL vector-var{,vector-var}

vector-var must have had a mass attached to it by a MASS
declaration.

Examples:
vector v1,v2;
mass v1=m,v2=q;
mshell v1;
                                         2
v1.v1;                                  M
v2.v2;                                  V2.V2
mshell v2;
                                         2  2
v1.v1*v2.v2;                            M *Q

Even though a mass is attached to a vector variable representing a
particle, the replacement does not take place until the MSHELL
declaration is given for that vector variable.

\endsection
\xitem[Multiple assignment statement]
Multiple assignment statement                           (page 54)

\endsection
\item[MULTIPLICITIES]
MULTIPLICITIES                                          (page 86)

When MSG is off, the printing of warning messages is suppressed.  Error
messages are still printed.

Warning messages include those about redimensioning an ARRAY or declaring
an OPERATOR where one is expected.  

\endsection
\xitem[MULTIROOT]
MULTIROOT                                               (page 373)

\endsection
\item[NAT]
NAT                                                     (page 111, 259)

When NAT is on, output is printed to the screen in natural form, with
raised exponents.  NAT should be turned off when outputting expressions
to a file for future input.  Default is ON.

Examples:                               3      2          2    3
(x + y)**3;                            X  + 3*X *Y + 3*X*Y  + Y
off nat;
(x + y)**3;                            X**3 + 3*X**2*Y + 3*X*Y**2 + Y**3$
on fort;
(x + y)**3;                            ANS=X**3+3.*X**2*Y+3.*X*Y**2+Y**3

With NAT off, a dollar sign is printed at the end of each expression.
An output file written with NAT off is ready to be read into REDUCE
using the command IN.

\endsection
\item[NEARESTROOT]
NEARESTROOT                                             (pages 370, 372)

The operator NEARESTROOT finds one root of a polynomial with an
iteration using a given starting point.

        NEARESTROOT(p,pt)

where p is a univariate polynomial and pt is a number.

Example:

        nearestroot(x^2+2,2);           {X=1.41421*I}

The minimal accuracy of the result values is controlled by ROOTACC.

\endsection
\xitem[NEARESTROOTS]
NEARESTROOTS                                            (page 370)

\endsection
\xitem[NEGATIVE]
NEGATIVE                                                (page 368)

\endsection
\item[NERO]
NERO                                                    (page 108)

When NERO is on, zero assignments (such as matrix elements) are not
printed.

Examples:
matrix a;
a := mat((1,0),(0,1));          A(1,1) := 1
                                A(1,2) := 0
                                A(2,1) := 0
                                A(2,2) := 1
on nero;
a;                              MAT(1,1) := 1
                                MAT(2,2) := 1
a(1,2);                                         {nothing is printed.}
b := 0;                                         {nothing is printed.}
off nero;
b := 0;                         B := 0

NERO is often used when dealing with large sparse matrices, to avoid
being overloaded with zero assignments.

\endsection
\xitem[Newton's method]
Newton's method                                         (page 182)

\endsection
\item[NEXTPRIME]
NEXTPRIME                                               (page 74)

        NEXTPRIME(expression)

If the argument of NEXTPRIME is an integer, the least prime greater
than that argument is returned.  Otherwise, a type error results.

Examples:
nextprime 5001;                          5003  
nextprime(10^30);                        1000000000000000000000000000057 
nextprime a;                             ***** A invalid as integer

\endsection
\xitem[NN]
NN                                                      (page 379)

\endsection
\item[NOARG]
NOARG

When DFPRINT is on, expressions in the differentiation operator
DF are printed in a more ``natural'' notation, with the
differentiation variables appearing as subscripts.  When NOARG
is on (the default), the arguments of the differentiated operator are also
suppressed.

Examples:
operator f;
df(f x,x);              DF(F(X),X);
on dfprint;
ws;                     F
                         X
df(f(x,y),x,y);         F
                         X,Y
off noarg;
ws;                     F(X)
                            X

\endsection
\item[NODEPEND]
NODEPEND                                                (page 95)

The NODEPEND declaration removes the dependency declared with DEPEND.

        NODEPEND dep-kernel{,kernel}

dep-kernel 
must be a kernel that has had a dependency declared upon
the one or more other kernels that are its other arguments.

Examples:
depend y,x,z;
df(sin y,x);                         COS(Y)*DF(Y,X)
df(sin y,x,z);                       COS(Y)*DF(Y,X,Z) - DF(Y,X)*DF(Y,Z)*SIN(Y)
nodepend y,z;
df(sin y,x);                         COS(Y)*DF(Y,X)
df(sin y,x,z);                       0

A warning message is printed if the dependency had not been declared by
DEPEND.

\endsection
\xitem[NOETHER function]
NOETHER function                                        (pages 258, 271)

\endsection
\xitem[Non-commuting operator]
Non-commuting operator                  (page 92)

\endsection
\item[NOLNR]
NOLNR

When NOLNR is on, the linear properties of the integration operator
INT are suppressed if the integral cannot be found in closed terms.


REDUCE uses the linear properties of integration to attempt to break down
an integral into manageable pieces.  If an integral cannot be found in
closed terms, these pieces are returned.  When the NOLNR switch is off,
as many of the pieces as possible are integrated.  When it is on, if any piece
fails, the rest of them remain unevaluated.

\endsection
\item[NONCOM]
NONCOM                                                  (page 92)

NONCOM declares that already-declared operators are noncommutative
under multiplication.

        NONCOM operator{,operator}

operator must have been declared an OPERATOR, or a warning message is
given.

Examples:
operator f,h; 
noncom f; 
f(a)*f(b) - f(b)*f(a);                            F(A)*F(B) - F(B)*F(A) 
h(a)*h(b) - h(b)*h(a);                            0 
operator comm; 
for all x,y such that x neq y and ordp(x,y)
        let f(x)*f(y) = f(y)*f(x) + comm(x,y);
f(1)*f(2);                                        F(1)*F(2) 
f(2)*f(1);                                        COMM(2,1) + F(1)*F(2)

The last example introduces the commutator of f(x) and f(y) for all x
and y.  The equality check is to prevent an infinite loop.  The
operator f can have other functionality attached to it if desired, or
it can remain an indeterminate operator.

\endsection
\item[NONZERO]
NONZERO                                                 (page 90)

        NONZERO identifier{,identifier}

If an operator F is declared ODD, then F(0) is replaced by zero unless
F is also declared non zero by the declaration NONZERO.

Examples:
        odd f; 
        f(0)               0 
        nonzero f;
        f(0)               F(0)

\endsection
\item[NOSPLIT]
NOSPLIT                                                 (page 103)

Under normal circumstances, the printing routines try to break an expression
across lines at a natural point.  This is a fairly expensive process.  If
you are not overly concerned about where the end-of-line breaks come, you
can speed up the printing of expressions by turning off the switch
NOSPLIT.  This switch is normally on.

\endsection
\item[NOSPUR]
NOSPUR                                                  (page 210)

The NOSPUR declaration prevents the trace calculation over the given
line identifiers in high-energy physics calculations.
        NOSPUR line-id{,line-id}


line-id is a scalar identifier that will be used as a line identifier.

Examples:
vector a1,b1,c1;
g(line1,a1,b1)*g(line2,b1,c1);           A1.B1*B1.C1
nospur line2;
g(line1,a1,b1)*g(line2,b1,c1);           A1.B1*G(LINE2,B1,C1)

Nospur declarations can be removed by making the declaration SPUR.

\endsection
\xitem[NOSUM command]
NOSUM command                                           (pages 262, 271)

\endsection
\xitem[NOSUM switch]
NOSUM switch                                            (page 262)

\endsection
\item[NOXPND @]
NOXPND @                                                (pages 254, 271)
NOXPND D                                                (pages 253, 271)

(Part of the EXCALC package)

There are two forms of the NOXPND command, which controls the use of
the product rule for the d operator and the expansion into partial
derivatives.  The default for both these is OFF.

        noxpnd d;
        noxpnd @;

Example:
        load_package excalc;            *** ^ redefined
                                        (excalc)
        pform x=0,y=k,z=m;
                                              K
        d(y^z);                         ( - 1) *Y^d Z + d Y^Z

        noxpnd d;
        d(y^z);                         d(Y^Z)


See also XPND
\endsection
\xitem[NS dummy variable]
NS dummy variable                                       (page 260)

\endsection
\item[NULLSPACE]
NULLSPACE                                               (page 166)

NULLSPACE(matrix_expression)

nullspace calculates for its MATRIX argument, A, a list of linear
independent vectors (a basis) whose linear combinations satisfy the
equation A x = 0.  The basis is provided in a form such that as many
upper components as possible are isolated.

Examples:
nullspace mat((1,2,3,4),(5,6,7,8));     {
                                         [ 1  ]
                                         [    ]
                                         [ 0  ]
                                         [    ]
                                         [ - 3]
                                         [    ]
                                         [ 2  ]
                                         ,
                                         [ 0  ]
                                         [    ]
                                         [ 1  ]
                                         [    ]
                                         [ - 2]
                                         [    ]
                                         [ 1  ]
                                        }

Note that with B := NULLSPACE A, the expression LENGTH B is the
nullity of A, and that SECOND LENGTH A - LENGTH B calculates the rank
of A.  The rank of a matrix expression can also be found more directly
by the RANK operator.

In addition to the REDUCE matrix form, NULLSPACE accepts as input a
matrix given as a LIST of lists, that is interpreted as a row matrix.  If
that form of input is chosen, the vectors in the result will be
represented by lists as well.  This additional input syntax facilitates
the use of NULLSPACE in applications different from classical linear
algebra.

\endsection
\item[NUM]
NUM                                                     (page 131)
The NUM operator returns the numerator of its argument.

        NUM(expression) or NUM simple_expression

expression can be any valid REDUCE scalar expression.

Examples:
num(100/6);                          50 
num(a/5 + b/6);                      6*A + 5*B 
num(sin(x));                         SIN(X)

NUM returns the numerator of the expression after it has been simplified
by REDUCE.  As seen in the examples, this includes putting sums of rational
expressions over a common denominator, and reducing common factors where
possible.  If the expression is not a rational expression, it is returned
unchanged.  

\endsection
\item[NUMVAL]
NUMVAL

With ROUNDED on, elementary functions with numerical arguments
will return a numerical answer where appropriate.  If you wish to inhibit
this evaluation, NUMVAL should be turned off.  It is normally on.

Examples:
        on rounded;
        cos 3.4;                - 0.966798192579
        off numval;
        cos 3.4;                COS(3.4)

\endsection
\item[NUM_INT]
NUM_INT                                                 (page 182)

For the numerical evaluation of univariate integrals over a finite
interval the following strategy is used: If INT finds a formal
antiderivative which is bounded in the integration interval, this is
evaluated and the end points and the difference is returned.
Otherwise a Chebyshev fit is computed, starting with order 20,
eventually up to order 80.  If that is recognized as sufficiently
convergent it is used for computing the integral by directly
integrating the coefficient sequence.  If none of these methods is
successful, an adaptive multilevel quadrature algorithm is used.

For multivariate integrals only the adaptive quadrature is used.  This
algorithm tolerates isolated singularities.  The value ITERATIONS here
limits the number of local interval intersection levels.  a is a
measure for the relative total discretization error (comparison of
order 1 and order 2 approximations).

NUM_INT(exp,var=(l .. u) [,var=(l .. u),...] [,accuracy=a][,iterations=i])

where exp is the function to be integrated, var are the integration
variables, l are the lower bounds, u are the upper bounds.
 
Result is the value of the integral.
 
Example:
        on rounded;
        num_int(sin x,x=(0 .. pi));             2.0

\endsection
\item[NUM_MIN]
NUM_MIN                                                 (page 182)

The Fletcher Reeves version of the STEEPEST_DESCENT algorithms is used
to find the minimum of a function of one or more variables. The
function must have continuous partial derivatives with respect to all
variables. The starting point of the search can be specified; if not,
random values are taken instead.  The steepest descent algorithms in
general find only local minima.
 
Syntax:

 NUM_MIN(exp, var[=val] [,var[=val] ... [,accuracy=a] [,iterations=i]) 
NUM_MIN(exp, {var[=val] [,var[=val} ...] } [,accuracy=a] [,iterations=i]) 

where exp is a function expression, var are the variables in exp and
val are the (optional) start values.  For a and i see NUMERIC_ACCURACY.

NUM_MIN tries to find the next local minimum along the descending path
starting at the given point. The result is a LIST with the minimum
function value as first element followed by a list of equations, where
the variables are equated to the coordinates of the result point.

Examples:
        load numeric;
        num_min(sin(x)+x/5, x);         { - 0.0775892231689,{x=4.51200216375}}
        num_min(sin(x)+x/5, x=0);       { - 1.33416631212,{x= - 1.78326532423}}

\endsection
\item[NUM_ODESOLVE]
NUM_ODESOLVE                                            (page 182)

The Runge-Kutta method of order 3 finds an approximate graph for the
solution of real ODE initial value problem.
 
NUM_ODESOLVE(exp,depvar=start, indep=(from .. to) [,accuracy=a][,iterations=i])
NUM_ODESOLVE({exp,exp,...},{depvar=start,depvar=start,...} indep=(from .. to)
                                                  [,accuracy=a][,iterations=i])

where depvar and start specify the dependent variable(s) and the
starting point value (vector), indep, from and to specify the
independent variable and the integration interval (starting point and
end point), exp are equations or expressions which contain the first
derivative of the independent variable with respect to the dependent
variable.
 
The ODEs are converted to an explicit form, which then is used for a
Runge Kutta iteration over the given range. The number of steps is
controlled by the value of i (default: 20).  If the steps are too
coarse to reach the desired accuracy in the neighborhood of the
starting point, the number is increased automatically.
 
Result is a list of pairs, each representing a point of the
approximate solution of the ODE problem.

Example:
num_odesolve(df(y,x)=y,y=1,x=(0 .. 1), iterations=5);

        {{0.0,1.0},{0.2,1.2214},{0.4,1.49181796},{0.6,1.8221064563},
         {0.8,2.2255208258},{1.0,2.7182511366}}

If in exp the differential is not isolated on the left-hand side,
please ensure that the dependent variable is explicitly declared using
a DEPEND otherwise the formal derivative will be computed to zero by
REDUCE.

The operator SOLVE is used to convert the form into an explicit
ODE. If that process fails or has no unique result, the evaluation is
stopped with an error message.

\endsection
\item[NUM_SOLVE]
NUM_SOLVE                                               (page 182)

An adaptively damped Newton iteration is used to find an approximative
root of a function (function vector) or the solution of an EQUATION
(equation system). The expressions must have continuous derivatives
for all variables.  A starting point for the iteration can be
given. If not given random values are taken instead. When the number
of forms is not equal to the number of variables, the Newton method
cannot be applied. Then the minimum of the sum of absolute squares is
located instead.

With COMPLEX on, solutions with imaginary parts can be found, if
either the expression(s) or the starting point contain a nonzero
imaginary part.

 NUM_SOLVE(exp, var[=val][,accuracy=a][,iterations=i])
 NUM_SOLVE({exp,...,exp}, var[=val],...,var[=val] [,accuracy=a][,iterations=i])
 NUM_SOLVE({exp,...,exp}, {var[=val],...,var[=val]}
                                                  [,accuracy=a][,iterations=i])
 
where exp are function expressions,
      var are the variables,
      val are optional start values.
For a and i see NUMERIC_ACCURACY.
 
NUM_SOLVE tries to find a zero/solution of the expression(s).  Result
is a list of equations, where the variables are equated to the
coordinates of the result point.
 
The Jacobian matrix is stored as side effect the shared jacobian.
 
Examples:
num_solve({sin x=cos y, x + y = 1},{x=1,y=2});
                                {X= - 52.1216769476,Y=53.1216769476}
                                [COS(X)  SIN(Y)]
jacobian;                       [              ]
                                [  1       1   ]
\endsection
\xitem[Number]
Number                                                  (pages 34, 35)

\endsection
\item[NUMBERP]
NUMBERP                                                 (page 46)
The NUMBERP operator returns TRUE if its argument is a number,
and NIL otherwise.

        NUMBERP(expression) or NUMBERP expression

expression can be any REDUCE scalar expression.

Examples:
cc := 15.3;                                                  CC := 15.3 
if numberp(cc) then write "number" else write "nonnumber";   number 
if numberp(cb) then write "number" else write "nonnumber";   nonnumber

Logical operators can only be used in conditional expressions, such as 
IF...THEN...ELSE and WHILE...DO.

\endsection
\item[NUMERIC package]
NUMERIC package                                         (page 337)

The numeric package supplies algorithms based on approximation
techniques of numerical mathematics. The algorithms use the ROUNDED
mode arithmetic of REDUCE, including the variable precision feature
which is exploited in some algorithms in an adaptive manner in order
to reach the desired accuracy.

\endsection
\xitem[Numerical operator]
Numerical operator                                      (page 71)

\endsection
\xitem[Numerical precision]
Numerical precision                                     (page 36)

\endsection
\item[ODD]
ODD                                                     (page 90)

        ODD identifier{,identifier}

This declaration is used to declare an operator odd in its first
argument.  Expressions involving an operator declared in this manner
are transformed if the first argument contains a minus sign.  Any
other arguments are not affected.

Examples:
        odd f;
        f(-a)                      -F(A)
        f(-a,-b)                   -F(A,-B)
        f(a,-b)                     F(A,-B)

If say F is declared odd, then F(0) is replaced by zero unless F is
also declared non zero by the declaration NONZERO.

\endsection
\xitem[ODEDEGREE]
ODEDEGREE                                               (page 350)

\endsection
\xitem[ODELINEARITY]
ODELINEARITY                                            (page 350)

\endsection
\xitem[ODEORDER]
ODEORDER                                                (page 350)

\endsection
\item[ODESOLVE]
ODESOLVE                                                (pages 183, 349)

Main Author:  Malcolm A.H. MacCallum
Other contributors:  Francis Wright, Alan Barnes
   
Ordinary Differential Equations Solver.

The  ODESOLVE   package  is  a   solver  for  ordinary   differential
equations.   At the  present time it  has very limited  capabilities.
It  can  handle  only  a  single  scalar  equation  presented  as  an
algebraic  expression or  equation,  and  it  can solve  only  first-
order  equations of  simple  types,  linear equations  with  constant
coefficients and Euler  equations.  These solvable types  are exactly
those for which  Lie symmetry techniques give no  useful information.

For example, the evaluation of
        depend(y,x);
        odesolve(df(y,x)=x**2+e**x,y,x);
yields the result
               X                    3
            3*E  + 3*ARBCONST(1) + X
        {Y=---------------------------}
                        3              

\endsection
\item[OFF]
OFF                                                     (pages 68, 69)

The OFF command is used to turn switches off.

        OFF switch{,switch}

switch can be any SWITCH name.  There is no problem if the switch is
already off.  If the switch name is mistyped, an error message is
given.

\endsection
\item[ON]
ON                                                      (pages 68, 69)

The ON command is used to turn switches on.

        ON switch{,switch}

switch can be any SWITCH name.  There is no problem if the switch is
already on.  If the switch name is mistyped, an error message is
given.

\endsection
\item[ONE_OF]
ONE_OF                                                  (page 86)
The operator ONE_OF is used to represent an indefinite choice 
of one element from a finite set of objects. 

Example:
        x=one_of{1,2,5}

This equation encodes that x can take one of the values 1,2 or 5

REDUCE generates a ONE_OF form in cases when an implicit ROOT_OF
expression could be converted to an explicit solution set. A ONE_OF
form can be converted to a SOLVE solution using EXPAND_CASES. See
ROOT_OF.   

\endsection
\item[OPERATOR]
OPERATOR                                                (page 202)

Use the OPERATOR declaration to declare your own operators.

        OPERATOR identifier{,identifier}

identifier can be any valid REDUCE identifier, which is not the name
of a MATRIX, ARRAY, scalar variable or previously-defined operator.

Examples:
operator dis,fac;
let dis(~x,~y) = sqrt(x^2 + y^2);
dis(1,2);                          SQRT(5)
                                         2
dis(a,10);                         SQRT(A  + 100)
on rounded;
dis(1.5,7.2);                      7.35459040329
let fac(~n) = 
  if n=0 then 1
  else if not(fixp n and n>0)
          then rederr "choose non-negative integer"
          else for i := 1:n product i;

fac(5);                           120
fac(-2);                          ***** choose non-negative integer

The first operator is the Euclidean distance metric, the distance of
point (x,y) from the origin.  The second operator is the factorial.

Operators can have various properties assigned to them; they can be
declared INFIX, LINEAR, SYMMETRIC, ANTISYMMETRIC, or NONCOMmutative.
The default operator is prefix, nonlinear, and commutative.
Precedence can also be assigned to operators using the declaration
PRECEDENCE.

Functionality is assigned to an operator by a LET statement or a
FORALL...LET statement, (or possibly by a procedure with the name of
the operator). Be careful not to redefine a system operator by
accident. REDUCE permits you to redefine system operators, giving you
a warning message that the operator was already defined.  This
flexibility allows you to add mathematical rules that do what you want
them to do, but can produce odd or erroneous behaviour if you are not
careful.

You can declare operators from inside PROCEDUREs, as long as they are
not local variables.  Operators defined inside procedures are global.
A formal parameter may be declared as an operator, and has the effect
of declaring the calling variable as the operator.

\endsection
\xitem[Operator precedence]
Operator precedence                                     (page 39, 41)

\endsection
\item[ORDER]
ORDER                                                   (pages 101, 114)

The ORDER declaration changes the order of precedence of kernels for
display purposes only.

        ORDER identifier{,identifier}

kernel must be a valid KERNEL or OPERATOR name complete with argument.

Examples:
x + y + z + cos(a);                  COS(A) + X + Y + Z
order z,y,x,cos(a);
x + y + z + cos(a);                  Z + Y + X + COS(A)
                                      2            2
(x + y)**2;                          Y  + 2*Y*X + X
order nil;
                                           2                 2
(z + cos(z))**2;                     COS(Z)  + 2*COS(Z)*Z + Z

ORDER affects the printing order of the identifiers only; internal
order is unchanged.  Change internal order of evaluation with the
declaration KORDER.  You can use ORDER to feature variables or
functions you are particularly interested in.

Declarations made with ORDER are cumulative: kernels in new order
declarations are ordered behind those in previous declarations, and
previous declarations retain their relative order.  Of course,
specific kernels named in new declarations are removed from previous
ones and given the new priority.  Return to the standard canonical
printing order with the statement ORDER NIL.

The print order specified by ORDER commands is not in effect if the
switch PRI is off.

\endsection
\xitem[ordering exterior form]
ordering 
      exterior form                                     (page 268)

\endsection
\xitem[ordinary differential equations]
ordinary differential equations                         (page 349)

\endsection
\item[ORDP]
ORDP                                                    (pages 46, 92)

The ORDP logical operator returns TRUE if its first argument is
ordered ahead of its second argument in canonical internal ordering,
or is identical to it.

        ORDP(expression1,expression2)

expression1 and expression2 can be any valid REDUCE scalar expression.

Examples:
if ordp(x**2 + 1,x**3 + 3) then write "yes" else write "no";           no 
if ordp(101,100) then write "yes" else write "no";                     yes 
if ordp(x,x) then write "yes" else write "no";                         yes

Logical operators can only be used in conditional expressions, such as 
IF...THEN...ELSE and WHILE...DO.

\endsection
\item[ORTHOVEC]
ORTHOVEC                                                (pages 184, 353)

Author:  James W. Eastwood

A  Package  for  the  Manipulation  of  Scalars  and Vectors.

ORTHOVEC is  a collection of  REDUCE procedures and  operations which
provide a simple-to-use  environment for the manipulation  of scalars
and  vectors.   Operations  include  addition, subtraction,  dot  and
cross  products,  division,  modulus,  div,  grad,  curl,  laplacian,
differentiation, integration, and Taylor expansion.

\endsection
\item[OUT]
OUT                                                     (pages 153, 154)

The OUT command directs output to the filename that is its argument,
until another OUT changes the output file, or SHUT closes it.
        OUT filename or OUT "pathname " or OUT T

filename must be in the current directory, or be a valid complete
file description for your system.  If the file name is not
in the current directory, quote marks are needed around the file name.
If the file already exists, a message is printed allowing you to decide
whether to supersede the contents of the file with new material.


To restore output to the terminal, type OUT T, or SHUT the
file.  When you use OUT T, the file remains available, and if you
open it again (with another OUT), new material is appended rather
than overwriting.

To write a file using OUT that can be input at a later time, the
switch NAT must be turned off, so that the standard linear form
is saved that can be read in by IN.  If NAT is on, exponents
are printed on the line above the expression, which causes trouble
when REDUCE tries to read the file.

There is a slight complication if you are using the OUT command from
inside a file to create another file.  The ECHO switch is normally
off at the top-level and on while reading files (so you can see what is
being read in).  If you create a file using OUT at the top-level,
the result lines are printed into the file as you want them.  But if you
create such a file from inside a file, the ECHO switch is on, and
every line is echoed, first as you typed it, then as REDUCE parsed it, and
then once more for the file.  Therefore, when you create a file from
a file, you need to turn ECHO off explicitly before the OUT
command, and turn it back on when you SHUT the created file, so your
executing file echoes as it should.  This behaviour also means that as you
watch the file execute, you cannot see the lines that are being put into
the OUT file.  As soon as you turn ECHO on, you can see
output again.

\endsection
\item[OUTPUT]
OUTPUT                                                  (page 100)

When OUTPUT is off, no output is printed from any REDUCE calculation.
The calculations have their usual effects other than printing.  Default is
ON.


Turn output OFF if you do not wish to see output when executing
large files, or to save the time REDUCE spends formatting large expressions
for display.  Results are still available with WS, or in their
assigned variables. 

\endsection
\xitem[Output]
Output                                                  (pages 105, 110)

\endsection
\xitem[Output declaration]
Output declaration                                      (pages 100, 101)

\endsection
\item[OVERVIEW]
OVERVIEW

When OVERVIEW is on, the amount of detail reported by the factoriser
switches TRFAC and TRALLFAC is reduced.


\endsection
\item[PART]
PART                                                    (pages 49, 113, 116)
The operator PART permits the extraction of various parts or
operators of expressions and LISTS.

        PART(expression,integer{,integer})

expression can be any valid REDUCE expression or a list, integer may
be an expression that evaluates to a positive or negative integer or
0.  A positive integer n picks up the nth term, counting from the
first term toward the end.  A negative integer n picks up the nth
term, counting from the back toward the front.  The integer 0 picks up
the operator (which is LIST when the expression is a list).

Examples:
                                    2  3
part((x + y)**5,4);             10*X *Y

                                 2
part((x + y)**5,4,2);           X

part((x + y)**5,4,2,1);         X
part((x + y)**5,0);             PLUS 
                                   4
part((x + y)**5,-5);            5*x *y

                                 5      4         3  2                 4    5
part((x + y)**5,4) := sin(x);   x  + 5*x *y + 10*x *y  + sin(x) + 5*x*y  + y

alist := {x,y,{aa,bb,cc},x**2*sqrt(y)};
                                ALIST := {X,
                                          Y,
                                          {AA,BB,CC},
                                                   2
                                          SQRT(Y)*X }
part(alist,3,2);                BB 
part(alist,4,0);                TIMES

Additional integer arguments after the first one examine the terms
recursively, as shown above.  In the third line, the fourth term is
picked from the original polynomial, 10x^2y^3, then the second term
from that, x^2, and finally the first component, x.  If an integer's
absolute value is too large for the appropriate expression, a message
is given.

PART works on the form of the expression as printed, or as it would
have been printed at that point of the calculation, bearing in mind
the current switch settings.  It is important to realise that the
switch settings change the operation of PART.  PRI must be on when
PART is used.

When PART is used on a polynomial expression that has minus signs, the
+ is always returned as the top-level operator.  The minus is found as
a unary operator attached to the negative term.

PART can also be used to change the relevant part of the expression or
list as shown in the sixth example line.  The PART operator returns the
changed expression, though original expression is not changed.  You can
also use PART to change the operator.

\endsection
\xitem[partial differentiation]
partial differentiation                                 (page 251)

\endsection
\item[PAUSE]
PAUSE                                                   (page 160))
The PAUSE command, given in an interactive file, stops operation and
asks if you want to continue or not.

Examples:
An interactive file is running, and at some point you see the
question 
                                   Cont? (Y or N) 
If you type y {Return}
the file continues to run until the next pause or the end.
If you type n {Return} 

you will get a numbered REDUCE prompt, and be allowed to enter and
execute any REDUCE statements.  If you later wish to continue with the
file, type
        cont; 
and the file resumes.

To use PAUSE in your own interactive files, type

PAUSE;

in the file wherever you want it.

PAUSE does not allow you to continue without typing either Y or N.
Its use is to slow down scrolling of interactive files, or to let you
change parameters or switch settings for the calculations.

If you have stopped an interactive file at a PAUSE, and do not wish to
resume the file, type END;.  This does not end the REDUCE session, but
stops input from the file.  A second END; ends the REDUCE session.
However, if you have pauses from more than one file stacked up, an
END; brings you back to the top level, not the file directly above.

A PAUSE typed from the terminal has no effect.

\endsection
\xitem[PCLASS]
PCLASS                                                  (pages 379, 380, 383)

\endsection
\xitem[Percent sign]
Percent sign                                            (page 38)

\endsection
\item[PERIOD]
PERIOD                                                  (page 111)

When PERIOD is on, periods are added after integers in
Fortran-compatible output (when FORT is on).  There is no effect
when FORT is off.  Default is ON.

\endsection
\item[PF]
PF                                                      (page 83)

        PF(expression,variable)

PF transforms expression into a LIST of partial fractions with respect
to the main variable, variable. PF does a complete partial fraction
decomposition, and as the algorithms used are fairly unsophisticated
(factorisation and the extended Euclidean algorithm), the code may be
unacceptably slow in complicated cases.

Examples:
                                    2      - 2         2
pf(2/((x+1)^2*(x+2)),x);        {-------,-------,--------------}
                                  x + 2   x + 1    2
                                                  x  + 2*x + 1
off exp; 
pf(2/((x+1)^2*(x+2)),x);
                                    2      - 2       2
pf(2/((x+1)^2*(x+2)),x);        {-------,-------,----------}
                                  x + 2   x + 1          2
                                                  (x + 1)

                                        2
for each j in ws sum j;         ------------------
                                                2
                                 (x + 2)*(x + 1)

If you want the denominators in factored form, turn EXP off, as shown
in the second example above.  As shown in the final example, the FOR
EACH construct can be used to recombine the terms.  Alternatively, one
can use the operations on lists to extract any desired term.

\endsection
\xitem[PFORM command]
PFORM command                                           (page 271)

\endsection
\xitem[PFORM statement]
PFORM statement                                         (page 249)

\endsection
\item[PI]
PI                                                      (page 37)

The identifier PI is reserved for use as the circular constant.
Its value is given by 3.14159265358..., which REDUCE gives to the current
decimal precision when REDUCE is in a floating-point mode.


PI may be used as a looping variable in a FOR statement,
or as a local variable in a PROCEDURE.  Its value in such cases will be
taken from the local environment.

\endsection
\xitem[PLOT]
PLOT                                                    (page 181)

\endsection
\item[POCHHAMMER]
POCHHAMMER                                              (pages 185, 394)

The POCHHAMMER operator implements the Pochhammer notation 
(shifted factorial).

        POCHHAMMER(expression,expression)

Examples:
load_package specfn;                    (SPECFN)
pochhammer(17,4);                        116280 

                                          FACTORIAL(2*Z)
pochhammer(1/2,z);                      -------------------
                                                  2*Z
                                         2   *FACTORIAL(Z)

A number of complex rules for POCHHAMMER are inactive, because they
cause a huge system load in algebraic mode. If one wants to use more
rules for the simplification of Pochhammer's notation, one can do:
        let special!*pochhammer!*rules;

\endsection
\item[POLYGAMMA]
POLYGAMMA                                               (pages 185, 395)

The POLYGAMMA operator returns the Polygamma function.

   Polygamma(n,x) := df(Psi(z),z,n);

        POLYGAMMA(integer,expression)

Examples:
        load_package specfn;    (SPECFN)
                                 PI  - 6
        Polygamma(1,2);         ---------
                                    6
        on rounded; 
        Polygamma(1,2.35);      0.52849689109

The POLYGAMMA function is used for simplification of the ZETA function
for some arguments.

\endsection
\xitem[Polynomial]
Polynomial                                              (page 119)

\endsection
\xitem[Polynomial equations]
Polynomial equations                                    (page 181)

\endsection
\xitem[POSITIVE]
POSITIVE                                                (page 368)

\endsection
\xitem[power series]
power series                                            (page 413)

\endsection
\xitem[power series arithmetic]
power series 
      arithmetic                                        (page 422)
      composition                                       (page 420)
      differentiation                                   (page 422)
      of integral                                       (page 415)
      of user defined function                          (page 415)

\endsection
\item[PRECEDENCE]
PRECEDENCE                                              (page 94)

The PRECEDENCE declaration attaches a precedence to an infix operator.

        PRECEDENCE operator, known_operator

operator should have been declared an operator but may be a REDUCE
identifier that is not already an operator, array, or matrix.
known_operator must be a system infix operator or have had its
precedence already declared.

Examples:
operator f,h;
precedence f,+;
precedence h,*; 
a + f(1,2)*c;                         (1 F 2)*C + A
a + h(1,2)*c;                         1 H 2*C + A
a*1 f 2*c;                            A F 2*C
a*1 h 2*c;                            1 H 2*A*C

The operator whose precedence is being declared is inserted into the
infix operator precedence list at the next higher place than
known-operator.

Attaching a precedence to an operator has the side effect of declaring
the operator to be infix.  If the identifier argument for PRECEDENCE
has not been declared to be an operator, an attempt to use it causes
an error message.  After declaring it to be an operator, it becomes an
infix operator with the precedence previously given.  Infix operators
may be used in prefix form; if they are used in infix form, a space
must be left on each side of the operator to avoid ambiguity.
Declared infix operators are always binary.

To see the infix operator precedence list, enter symbolic mode and
type PRECLIS!*;.  The lowest precedence operator is listed first.

All prefix operators have precedence higher than infix operators.

\endsection
\item[PRECISE]
PRECISE                                                 (page 78)

When the PRECISE switch is on, simplification of roots of even
powers returns absolute values, a more precise answer mathematically.

Examples:
sqrt(x**2);                          X
(x**2)**(1/4);                       SQRT(X)
on precise;
sqrt(x**2);                          ABS(X)
(x**2)**(1/4);                       SQRT(ABS(X))

In many types of mathematical work, simplification of powers and surds
can proceed by the fastest means of simplifying the exponents
arithmetically.  When it is important to you that the positive root be
returned, turn PRECISE on.  One situation where this is important is
when graphing square-root expressions such as sqrt(x^2+y^2) to avoid a
spike caused by REDUCE simplifying sqrt(y^2) to y when x is zero.

\endsection
\item[PRECISION]
PRECISION                                               (pages 132, 374)

The PRECISION declaration sets the number of decimal places used when
ROUNDED is on.  Default is system dependent, and normally about 12.

        PRECISION(integer) or PRECISION integer

integer must be a positive integer.  When integer is 0, the current
precision is displayed, but not changed.  There is no upper limit, but
precision of greater than several hundred causes unpleasantly slow
operation on numeric calculations.

Examples:
on rounded;
7/9;                                0.777777777778
precision 20;                       20
7/9;                                0.77777777777777777778
sin(pi/4);                          0.7071067811865475244

Trailing zeroes are dropped, so sometimes fewer than 20 decimal places
are printed as in the last example.  Turn on the switch FULLPREC if
you want to print all significant digits.  The ROUNDED mode carries
calculations to two more places than given by PRECISION, and rounds
off.

\endsection
\item[PREDUCE]
PREDUCE                                                 (page 308)

        PREDUCE(p, {exp, ... }[,vars])

where p is an expression, and {exp, ... } is a list of expressions or
equations and vars is an optional list of variables (see IDEAL
parameters).

PREDUCE computes the remainder of EXP modulo the given set of
polynomials resp. equations.  This result is unique (canonical) only
if the given set is a GROEBNER basis under the current TERM order.

see also: PREDUCET operator.

\endsection
\item[PREDUCET]
PREDUCET                                                (page 311)

        PREDUCE(p,{v=exp...}[,vars])

where p is an expression, v are kernels (simple or indexed variables),
EXP are polynomials and optional vars is a variable list (see IDEAL
parameters).

PREDUCET computes the remainder of p modulo {exp,...} similar to
PREDUCE, but the result is an equation which expresses the remainder
as combination of the polynomials.

Example:

   gb2 := {g1=2*x - y + 1,g2=9*y**2  - 2*y - 199}$
   preducet(q=x**2,gb2);

                         - 16*Y + 208= - 18*X*G1 - 9*Y*G1 + 36*Q + 9*G1 - G2


\endsection
\xitem[Prefix]
Prefix                                                  (pages 71, 93, 95)

\endsection
\xitem[Prefix operator]
Prefix operator                                         (page 38, 39)

\endsection
\item[PRET]
PRET                                                    (pages 217, 218)

When PRET is on, input is printed in standard REDUCE format and then
evaluated.

Examples:
on pret;
(x+1)^3;                        (x + 1)**3;
                                 3      2
                                X  + 3*X  + 3*X + 1

procedure fac(n);
   if not (fixp(n) and n>=0)
     then rederr "Choose nonneg. integer only"
    else for i := 0:n-1 product i+1;
                                procedure fac n;
                                   if not (fixp n and n>=0)
                                     then rederr "Choose nonneg. integer only"
                                    else for i := 0:n - 1 product i + 1;

                                FAC

fac 5;                          fac 5;
                                120

Note that all input is converted to lower case except strings (which
keep the same case) all operators with a single argument have had the
parentheses removed, and all infix operators have had a space added on
each side.  In addition, syntactical constructs like IF...THEN...ELSE
are printed in a standard format.

\endsection
\xitem[PRETTYPRINT]
PRETTYPRINT                                             (page 218)

\endsection
\xitem[Prettyprinting]
Prettyprinting                                          (pages 217, 218)

\endsection
\xitem[PRGEN]
PRGEN                                                   (page 378)

\endsection
\item[PRI]
PRI                                                     (page 101)

When PRI is on, the declarations ORDER and FACTOR can
be used, and the switches ALLFAC, DIV, RAT, 
and REVPRI take effect when they are on.  Default is ON.


Printing of expressions is faster with PRI off.  The expressions are
then returned in one standard form, without any of the display options that
can be used to feature or display various parts of the expression.  You can
also gain insight into REDUCE's representation of expressions with
PRI off.

\endsection
\item[PRIMEP]
PRIMEP                                                  (page 46)

        PRIMEP(expression) or PRIMEP simple_expression

If expression evaluates to a integer, PRIMEP returns TRUE if
expression is a prime number and NIL otherwise.  If expression does
not have an integer value, a type error occurs.

Examples:
if primep 3 then write "yes" else write "no";    YES 
if primep a then 1;                              ***** A invalid as integer

\endsection
\item[PRINT_PRECISION]
PRINT_PRECISION                                         (page 133)

        PRINT_PRECISION(integer) or PRINT_PRECISION integer

In ROUNDED mode, numbers are normally printed to the specified
precision.  If the user wishes to print such numbers with less
precision, the printing precision can be set by the declaration
PRINT_PRECISION.

Examples:
on rounded;
1/3;                     0.333333333333
print_precision 5;
1/3                      0.33333

\endsection
\item[PROCEDURE]
PROCEDURE                                               (page 169)

The PROCEDURE command allows you to define a mathematical operation as a
function with arguments.
        PROCEDURE identifier (arg{,arg});body

The option may be ALGEBRAIC or SYMBOLIC, indicating the mode under
which the procedure is executed, or REAL or INTEGER, indicating the
type of answer expected.  The default is algebraic.  Real or integer
procedures are subtypes of algebraic procedures; type-checking is done
on the results of integer procedures, but not on real procedures (in
the current REDUCE release). identifier may be any valid REDUCE
identifier that is not already a procedure name, operator, ARRAY or
MATRIX.  arg is a formal parameter that may be any valid REDUCE
identifier.  body is a single statement (a GROUP or BLOCK statement
may be used) with the desired activities in it.

Examples:

procedure fac(n);
   if not (fixp(n) and n>=0)
     then rederr "Choose nonneg. integer only"
    else for i := 0:n-1 product i+1;
                                        FAC
fac(0);                                 1
fac(5);                                 120
fac(-5);                                ***** choose nonneg. integer only

Procedures are automatically declared as operators upon definition.
When REDUCE has parsed the procedure definition and successfully
converted it to a form for its own use, it prints the name of the
procedure.  Procedure definitions cannot be nested.  Procedures can
call other procedures, or can recursively call themselves.  Procedure
identifiers can be cleared as you would clear an operator.  Unlike LET
statements, new definitions under the same procedure name replace the
previous definitions completely.

Be careful not to use the name of a system operator for your own
procedure.  REDUCE may or may not give you a warning message.  If you
redefine a system operator in your own procedure, the original
function of the system operator is lost for the remainder of the
REDUCE session.

Procedures may have none, one, or more than one parameter.  A REDUCE
parameter is a formal parameter only; the use of x as a parameter in a
PROCEDURE definition has no connection with a value of x in the REDUCE
session, and the results of calling a procedure have no effect on the
value of x.  If a procedure is called with x as a parameter, the
current value of x is used as specified in the computation, but is not
changed outside the procedure.  Making an assignment statement by :=
with a formal parameter on the left-hand side only changes the value
of the calling parameter within the procedure.

Using a LET statement inside a procedure always changes the value
globally: a LET with a formal parameter makes the change to the
calling parameter.  LET statements cannot be made on local variables
inside BEGIN...END BLOCKS.  When CLEAR statements are used on formal
parameters, the calling variables associated with them are cleared
globally too.  The use of LET or CLEAR statements inside procedures
should be done with extreme caution.

Arrays and operators may be used as parameters to procedures.  The
body of the procedure can contain statements that appropriately
manipulate these arguments.  Changes are made to values of the calling
arrays or operators.  Simple expressions can also be used as
arguments, in the place of scalar variables.  Matrices may not be used
as arguments to procedures.

A procedure that has no parameters is called by the procedure name,
immediately followed by empty parentheses.  The empty parentheses may
be left out when writing a procedure with no parameters, but must
appear in a call of the procedure.  If this is a nuisance to you, use
a LET statement on the name of the procedure (i.e., LET NOARGS =
NOARGS()) after which you can call the procedure by just its name.

Procedures that have a single argument can leave out the parentheses
around it both in the definition and procedure call.  (You can use the
parentheses if you wish.)  Procedures with more than one argument must
use parentheses, with the arguments separated by commas.

Procedures often have a BEGIN...END block in them. Inside the block,
local variables are declared using SCALAR, REAL or INTEGER
declarations.  The declarations must be made immediately after the
word BEGIN, and if more than one type of declaration is made, they are
separated by semicolons.  REDUCE currently does no type checking on
local variables; REAL and INTEGER are treated just like SCALAR.
Actions take place as specified in the statements inside the block
statement.  Any identifiers that are not formal parameters or local
variables are treated as global variables, and activities involving
these identifiers are global in effect.

If a return value is desired from a procedure call, a specific RETURN
command must be the last statement executed before exiting from the
procedure.  If no RETURN is used, a procedure returns a zero or no
value.

Procedures are often written in a file using an editor, then the file
is input using the command IN.  This method allows easy changes in
development, and also allows you to load the named procedures whenever
you like, by loading the files that contain them.

\endsection
\xitem[Procedure body]
Procedure body                                          (pages 171--173)

\endsection
\xitem[Procedure heading]
Procedure heading                                       (page 170)

\endsection
\item[PROD]
PROD operator                                           (page 403)

The operator  PROD returns
the indefinite or definite  product of a given expression.

        
PROD(expr,k[,lolim [,uplim ]])


where expr is the expression to be multiplied, k is the
control variable (a KERNEL), and lolim and uplim
uplim are the optional lower and upper limits. If uplim is
not supplied the upper limit is taken as k. The GOSPER
algorithm is used. If  there is  no closed  form solution,  the operator 
returns the input unchanged.

Examples:
prod(k/(k-2),k);                k*( - k + 1)

\endsection
\item[PRODUCT]
PRODUCT                                                 (page 57, 58)

See the FOR loop construction.

\endsection
\xitem[Program]
Program                                                 (page 38)

\endsection
\xitem[Program structure]
Program structure                                       (page 33)

\endsection
\xitem[Proper statement]
Proper statement                                        (pages 48, 53, 54)

\endsection
\xitem[PRSYS]
PRSYS                                                   (pages 378, 382)

\endsection
\xitem[PS]
PS                                                      (page 188)

\endsection
\xitem[PS operator]
PS operator                                             (page 414)

\endsection
\xitem[PSCHANGEVAR operator]
PSCHANGEVAR operator                                    (page 418)

\endsection
\xitem[PSCOMPOSE operator]
PSCOMPOSE operator                                      (page 420)

\endsection
\xitem[PSDEPVAR operator]
PSDEPVAR operator                                       (page 418)

\endsection
\xitem[PSEXPANSIONPT operator]
PSEXPANSIONPT operator                                  (page 418)

\endsection
\xitem[PSEXPLIM operator]
PSEXPLIM operator                                       (pages 414, 416)

\endsection
\xitem[PSFUNCTION operator]
PSFUNCTION operator                                     (page 418)

\endsection
\item[PSI]
PSI                                                     (pages 185, 395)

The PSI operator returns the Psi (or DiGamma) function.

   Psi(x) := df(Gamma(z),z)/ Gamma (z)

        GAMMA(expression)

Examples:
        load_package specfn;
                                                 1
                                 2*LOG(2) + PSI(---) + PSI(1) + 3
                                                 2
        Psi(3);                 ----------------------------------
                                                2

        on rounded; 
        - Psi(1);                 0.577215664902

Euler's constant can be found as  - Psi(1). 

\endsection
\xitem[PSINTCONST (shared)]
PSINTCONST (shared)                                     (page 415)

\endsection
\xitem[PSORDER operator]
PSORDER operator                                        (page 417)

\endsection
\xitem[PSORDLIM operator]
PSORDLIM operator                                       (page 416)

\endsection
\xitem[PSREVERSE operator]
PSREVERSE operator                                      (page 419)

\endsection
\xitem[PSSETORDER operator]
PSSETORDER operator                                     (page 417)

\endsection
\xitem[PSSUM operator]
PSSUM operator                                          (page 421)

\endsection
\xitem[PSTERM operator]
PSTERM operator                                         (page 417)

\endsection
\xitem[Puiseux expansion]
Puiseux expansion                                       (page 419)

\endsection
\xitem[PUTCSYSTEM command]
PUTCSYSTEM command                                      (page 235)

\endsection
\xitem[Quadrature]
Quadrature                                              (page 182)

\endsection
\item[QUIT]
QUIT                                                    (page 70)

The QUIT command ends the REDUCE session, returning control to the
program (e.g., the operating system) that called REDUCE.  When you are
at the top level, the QUIT command exits REDUCE. BYE is a synonym for
QUIT.

\endsection
\xitem[QUOTE]
QUOTE                                                   (page 193)

\endsection
\xitem[RANDOM]
RANDOM                                                  (page 74)

\endsection
\xitem[RANDOM_NEW_SEED]
RANDOM_NEW_SEED                                         (page 75)

\endsection
\item[RANK]
RANK                                                    (page 167)

        RANK(matrix_expression)
RANK calculates the rank of its matrix argument.

Examples:
        rank mat((a,b,c),(d,e,f));       2

The argument to RANK can also be a LIST of lists, interpreted either
as a row matrix or a set of equations.  If that form of input is
chosen, the vectors in the result will be represented by lists as
well.  This additional input syntax facilitates the use of RANK in
applications different from classical linear algebra.

\endsection
\item[RAT]
RAT                                                     (page 104)

When the RAT switch is on, and kernels have been selected to display
with the FACTOR declaration, the denominator is printed with each
term rather than one common denominator at the end of an expression.

Examples:                                             3
                                 SIN(Y)*X + SIN(Y) + X
(x+1)/x + x**2/sin y;           ------------------------
                                        SIN(Y)*X
factor x;
                                  3
                                 X  + X*SIN(Y) + SIN(Y)
(x+1)/x + x**2/sin y;           ------------------------
                                        X*SIN(Y)
on rat;
                                    2
                                   X            -1
(x+1)/x + x**2/sin y;           -------- + 1 + X
                                 SIN(Y)

The RAT switch only has effect when the PRI switch is on.
When PRI is off, regardless of the setting of RAT, the
printing behaviour is as if RAT were off.  RAT only has
effect upon the display of expressions, not their internal form.

\endsection
\item[RATARG]
RATARG                                                  (pages 115, 128)

When RATARG is on, rational expressions can be given to operators
such as COEFF and LTERM that normally require
polynomials in one of their arguments.  When RATARG is off, rational
expressions cause an error message.

Examples:                               3      2    3
                                       X  + X*Y  + Y
aa := x/y**2 + 1/x + y/x**2;    AA := ----------------
                                            2  2
                                           X *Y         
                                        3      2    3   
                                       X  + X*Y  + Y
coeff(aa,x);                    ***** ---------------- invalid as POLYNOMIAL
                                            2  2
                                           X *Y
on ratarg;
                                  Y    1        1
coeff(aa,x);                    {----,----,0,-------}
                                   2    2      2  2
                                  X    X      X *Y

\endsection
\item[RATIONAL]
RATIONAL                                                (page 132)

When RATIONAL is on, polynomial expressions with rational coefficients
are produced.

Examples:
                                 2*X + 3*Y
x/2 + 3*y/4;                    -----------
                                     4
                                  2
                                 X  + 5*X + 17
(x**2 + 5*x + 17)/2;            ---------------
                                       2
on rational;
                                 1        3
x/2 + 3y/4;                     ---*(X + ---*Y)
                                 2        2

                                 1    2
(x**2 + 5*x + 17)/2;            ---*(X  + 5*X + 17)
                                 2

By using RATIONAL, polynomial expressions with rational coefficients
can be used in some commands that expect polynomials.  With RATIONAL
off, such a polynomial becomes a rational expression, with denominator
the least common multiple of the denominators of the rational number
coefficients.

\endsection
\xitem[Rational coefficient]
Rational coefficient                                    (page 132)

\endsection
\xitem[Rational function]
Rational function                                       (page 119)

\endsection
\item[RATIONALIZE]
RATIONALIZE                                             (page 135)

When the RATIONALIZE switch is on, denominators of rational expressions
that contain complex numbers or root expressions are simplified by 
multiplication by their conjugates.

Examples:
                                               SQRT(3) + 1
qq := (1+sqrt(3))/(sqrt(3)-7);          QQ := -------------
                                               SQRT(3) - 7
on rationalize;
                                          - 4*SQRT(3) - 5
qq;                                     ------------------
                                                23
                                          2/3      1/3
                                         6    - 4*6    + 16
2/(4 + 6**(1/3));                       --------------------
                                                 35
on complex;
                                         1 - 2*i
(i-1)/(i+3);                            ---------
                                            5


\endsection
\item[RATPRI]
RATPRI                                                  (page 104)

When the RATPRI switch is on, rational expressions and fractions are
printed as two lines separated by a fraction bar, rather than in a linear
style.  Default is ON.

Examples:
                                 3
3/17;                           ----
                                 17
                                 3*B + 2*Y
2/b + 3/y;                      -----------
                                    B*Y
off ratpri;
3/17;                           3/17
2/b + 3/y;                      (3*B + 2*Y)/(B*Y)

\endsection
\xitem[RATROOT]
RATROOT                                                 (page 373)

\endsection
\item[REAL]
REAL                                                    (page 61)

The REAL declaration must be made immediately after a BEGIN (or other
variable declaration such as INTEGER and SCALAR) and declares local
integer variables.  They are initialised to zero.

        REAL identifier{,identifier}

identifier may be any valid REDUCE identifier, except T or NIL.

Real variables remain local, and do not share values with variables of
the same name outside the BEGIN...END block.  When the block is
finished, the variables are removed.  You may use the words INTEGER or
SCALAR in the place of REAL.  REAL does not indicate type-checking by
the current REDUCE; it is only for your own information.  Declaration
statements must immediately follow the BEGIN, without a semicolon
between BEGIN and the first variable declaration.

Any variables used inside a BEGIN...END BLOCK that were not declared
SCALAR, REAL or INTEGER are global, and any change made to them inside
the block affects their global value.  Any array or matrix declared
inside a block is always global.

\endsection
\xitem[Real]
Real                                                    (pages 34, 35)

\endsection
\xitem[Real coefficient]
Real coefficient                                        (page 132)

\endsection
\item[REALROOTS]
REALROOTS                                               (pages 369, 370)

The operator REALROOTS finds that real roots of a polynomial to an
accuracy that is sufficient to separate them and which is a minimum of
6 decimal places.

        REALROOTS(p)
        REALROOTS(p,from,to)

where p is a univariate polynomial.  The optional parameters from and
to classify an interval: if given, exactly the real roots in this
interval will be returned. from and to can also take the values
INFINITY or -INFINITY.  If omitted all real roots will be returned.
Result is a LIST of equations which represent the roots of the
polynomial at the given accuracy.

Examples:
        realroots(x^5-2);                               {X=1.1487}
        realroots(x^3-104*x^2+403*x-300,2,infinity);    {X=3.0,X=100.0}
        realroots(x^3-104*x^2+403*x-300,-infinity,2);   {X=1}

The minimal accuracy of the result values is controlled by ROOTACC.

\endsection
\xitem[REDERR]
REDERR                                                  (page 173)

\endsection
\item[REDUCT]
REDUCT                                                  (page 131)
The REDUCT operator returns the remainder of its expression after the
leading term is removed.

        REDUCT(expression,kernel)

expression is ordinarily a polynomial. If RATARG is on, a rational
expression may also be used, otherwise an error results.  kernel must
be a KERNEL.

Examples:
                                               3
reduct((x+y)**3,x);                     (x + y)

reduct(x + sin(x)**3,sin(x));           x
                                              3
reduct(x + sin(x)**3,y);                sin(x)  + x

If the expression does not contain the kernel, REDUCT returns the
expression.

\endsection
\xitem[side relations]
relations 
      side                                              (page 241)

\endsection
\item[REMAINDER]
REMAINDER                                               (page 126)
The REMAINDER operator returns the remainder after its first
argument is divided by its second argument.

        REMAINDER(expression,expression)

expression can be any valid REDUCE polynomial, and is not limited
to numeric values.

Examples:
remainder(13,6);                                   1 
remainder(x**2 + 3*x + 2,x+1);                     0  
remainder(x**3 + 12*x + 4,x**2 + 1);               11*X + 4 
remainder(sin(2*x),x*y);                           SIN(2*X)

If the first argument to REMAINDER contains a denominator not equal to
1, an error occurs.

\endsection
\item[REMFAC]
REMFAC                                                  (page 102)

The REMFAC declaration removes the special factoring treatment of its
arguments that was declared with FACTOR.

REMFAC kernel{,kernel}

kernel must be a KERNEL or OPERATOR name that was declared as special
with the FACTOR declaration.

\endsection
\xitem[REMFORDER command]
REMFORDER command                                       (pages 268, 271)

\endsection
\item[REMIND]
REMIND                                                  (page 206)

The REMIND declaration removes the special status of its arguments
as indices, which was set in the INDEX declaration, in
high-energy physics calculations.
        REMIND identifier{,identifier}

identifier must have been declared to be of type INDEX.

\endsection
\xitem[RENOSUM command]
RENOSUM command                                         (pages 262, 271)

\endsection
\item[REPART]
REPART                                                  (pages 72, 73, 75)

        REPART(expression) or REPART simple_expression

This operator returns the real part of an expression, if that argument
has an numerical value.  A non-numerical argument is returned as an
expression in the operators REPART and IMPART.

Examples:
repart(1+i);                             1 
repart(a+i*b);                           REPART(A) - IMPART(B)

\endsection
\item[REPEAT]
REPEAT                                                  (pages 60, 61, 63, 65)

The REPEAT command causes repeated execution of a statement UNTIL
the given  condition is found to be true.  The statement is always executed
at least once.
        REPEAT statement UNTIL condition

statement can be a single statement, GROUP statement, or
a BEGIN...END BLOCK.  condition must be a logical
operator that evaluates to rue or nil.

Examples:
<<m := 4; repeat <<write 100*x*m;m := m-1>> until m = 0>>;
                                        400*X
                                        300*X
                                        200*X
                                        100*X

<<m := -1; repeat <<write m; m := m-1>> until m <= 0>>;
                                        -1

REPEAT must always be followed by an UNTIL with a condition.  Be
careful not to generate an infinite loop with a condition that is
never true.  In the second example, if the condition had been M = 0,
it would never have been true since M already had value -2 when the
condition was first evaluated.

\endsection
\xitem[Reserved variable]
Reserved variable                       (pages 36, 37)

\endsection
\item[REST]
REST                                                            (page 50)

The REST operator returns a LIST containing all but the first element of
the list it is given.
        REST(list) or REST list


list must be a non-empty list, but need not have more than one element.

Examples:
alist := {a,b,c,d};                     ALIST := {A,B,C,D};
rest alist;                             {B,C,D}
blist := {x,y,{aa,bb,cc},z};            BLIST := {X,Y,{AA,BB,CC},Z}
second rest blist;                      {AA,BB,CC}
clist := {c};                           CLIST := C
rest clist;                             {}

\endsection
\xitem[RESULT]
RESULT                                  (page 378)

\endsection
\item[RESULTANT]
RESULTANT                                               (page 126)
The RESULTANT operator computes the resultant of two polynomials with
respect to a given variable.  If the resultant is 0, the polynomials
have a root in common.
  RESULTANT(expression,expression,kernel)

expression must be a polynomial containing kernel ;
kernel must be a KERNEL.

Examples:
resultant(x**2 + 2*x + 1,x+1,x);                              0 
resultant(x**2 + 2*x + 1,x-3,x);                              16 
resultant(z**3 + z**2 + 5*z + 5,
          z**4 - 6*z**3 + 16*z**2 - 30*z + 55,
          z);                                                 0 
resultant(x**3*y + 4*x*y + 10,y**2 + 6*y + 4,y);       
                                    6      4       3       2
                                4*(x  + 8*x  - 15*x  + 16*x  - 60*x + 25)

The resultant is the determinant of the Sylvester matrix, formed from the
coefficients of the two polynomials in the following way:

Given two polynomials: 

    n       n-1 
 a x  + a1 x     + ... + an

and
    m       m-1 
 b x  + b1 x     + ... + bm

form the  (m+n)x(m+n-1) Sylvester matrix by the following means:

   0.......0 a  a1 .......... an
   0....0 a  a1 .......... an  0
       .    .   .   .  
   a0 a1 .......... an 0.......0
   0.......0 b  b1 .......... bm
   0....0 b  b1 .......... bm  0
       .    .   .   .  
   b  b1 .......... bm 0.......0  

If the determinant of this matrix is 0, the two polynomials have a
common root.  Finding the resultant of large expressions is
time-consuming, due to the time needed to find a large determinant.

The sign conventions RESULTANT uses are those given in the article,
``Computing in Algebraic Extensions,'' by R.  Loos, appearing in
Computer Algebra--Symbolic and Algebraic Computation, 2nd ed., edited
by B.  Buchberger, G.E.  Collins and R.  Loos, and published by

Springer-Verlag, 1983.

These are:
  resultant(p(x),q(x),x) = (-1)^{deg p(x)*deg q(x)} * resultant(q(x),p(x),x),
  resultant(a,p(x),x)    = a^{deg p(x)},
  resultant(a,b,x)       = 1

where p(x) and q(x) are polynomials which have x as a variable, and
a and b are free of x.

Error messages are given if RESULTANT is given a non-polynomial
expression, or a non-kernel variable.

\endsection
\item[RETRY]
RETRY                                                   (page 157)
The RETRY command allows you to retry the latest statement that resulted
in an error message.

Examples:
matrix a; 
det a;                                    ***** Matrix A not set 
a := mat((1,2),(3,4));                    A(1,1) := 1
                                          A(1,2) := 2
                                          A(2,1) := 3
                                          A(2,2) := 4
retry;                                    -2

RETRY remembers only the most recent statement that resulted in an
error message.  It allows you to stop and fix something obvious, then
continue on your way without retyping the original command.

\endsection
\item[RETURN]
RETURN                                                  (pages 62--64)

The RETURN command causes a value to be returned from inside a
BEGIN...END BLOCK.
        BEGIN statements RETURN (expression)
        END

statements can be any valid REDUCE statements.  The value of
expression is returned.

Examples:
begin write "yes"; return a end;        yes
                                        A
procedure dumb(a);
  begin if numberp(a) then return a 
        else return 10 end;
                                        DUMB
dumb(x);                                10
dumb(-5);                               -5
procedure dumb2(a);
  begin c := a**2 + 2*a + 1; 
        d := 17; c*d; return end;
                                        DUMB2
dumb2(4);
c;                                      25
d;                                      17

Note in DUMB2 above that the assignments were made as requested, but
the product C*D cannot be accessed.  Changing the procedure to read
RETURN C*D would remedy this problem.

The RETURN statement is always the last statement executed before
leaving the block.  If RETURN has no argument, the block is exited but
no value is returned.  A block statement does not need a RETURN ; the
statements inside terminate in their normal fashion without one.  In
that case no value is returned, although the specified actions inside
the block take place.

The RETURN command can be used inside <<...>> GROUP statements and
IF...THEN...ELSE commands that are inside BEGIN...END BLOCKs.  It is
not valid in these constructions that are not inside a BEGIN...END
block. It is not valid inside FOR, REPEAT...UNTIL or WHILE...DO loops
in any construction.  To force early termination from loops, the GO
TO(GOTO) command must be used.  When you use nested block statements,
a RETURN from an inner block exits returning a value to the
next-outermost block, rather than all the way to the outside.

\endsection
\item[REVERSE]
REVERSE                                                 (page 51)

The REVERSE operator returns a LIST that is the reverse of the list it
is given.
        REVERSE(list) or REVERSE list

list must be a LIST.

Examples:
                                               2  3
aa := {c,b,a,{x**2,z**3},y};    AA := {C,B,A,{X ,Z },Y}
                                     2  3
reverse aa;                     {Y,{X ,Z},A,B,C}
                                         2  3
reverse(q . reverse aa);        {C,B,A,{X ,Z },Y,Q}

REVERSE and CONS can be used together to add a new element to the end
of a list (. adds its new element to the beginning).  The REVERSE
operator uses a noticeable amount of system resources, especially if
the list is long.  If you are doing much heavy-duty list manipulation,
you should probably design your algorithms to avoid much reversing of
lists.  A moderate amount of list reversing is no problem.

\endsection
\item[REVGRADLEX]
REVGRADLEX                                              (page 293)

The terms are ordered first with their total degree (degree sum), and
if the total degree is identical the comparison is the inverse of LEX
term order.  With GROEBNER and GROEBNERF calculations this term order
is similar to GRADLEX term order; it is known as most efficient
ordering with respect to computing time.

\endsection
\item[REVPRI]
REVPRI                                                  (page 105)

When the REVPRI switch is on, terms are printed in reverse order from
the normal printing order.

Examples:
                                           5    2
x**5 + x**2 + 18 + sqrt(y);     SQRT(Y) + X  + X  + 18

a + b + c + w;                  A + B + C + W

on revpri;
                                      2    5
x**5 + x**2 + 18 + sqrt(y);     17 + X  + X  + SQRT(Y)

a + b + c + w;                  W + C + B + A

Turn REVPRI on when you want to display a polynomial in ascending
rather than descending order.

\endsection
\item[RHS]
RHS                                                     (page 47)
The RHS operator returns the right-hand side of an EQUATION, such as
those returned in a LIST by SOLVE.

        RHS(equation) or RHS equation

equation must be an equation of the form left-hand side = right-hand side.

Examples:
 roots := solve(x**2 + 6*x*y + 5x + 3y**2,x);

                                                  2
                                      - (SQRT(24*Y  + 60*Y + 25) + 6*Y + 5)
                        ROOTS := {X=----------------------------------------,
                                                       2

                                                      2
                                     SQRT(24*Y  + 60*Y + 25) - 6*Y - 5
                                  X=-----------------------------------}
                                                     2

root1 := rhs first roots;
                                   - (SQRT(24*Y  + 60*Y + 25) + 6*Y + 5)
                        ROOT1 := ----------------------------------------
                                                    2
root2 := rhs second roots;
                                           2
                                  SQRT(24*Y  + 60*Y + 25) - 6*Y - 5
                        ROOT2 := -----------------------------------
                                                  2

An error message is given if RHS is applied to something other than an
equation.

\endsection
\xitem[Riemann Zeta Function]
Riemann Zeta Function                                   (pages 185, 395)

\endsection
\xitem[RIEMANNCONX command]
RIEMANNCONX command                                     (pages 267, 271)

\endsection
\xitem[Riemannian Connections]
Riemannian Connections                                  (page 267)

\endsection
\xitem[Rlisp]
Rlisp                                                   (page 213)

\endsection
\item[RLISP88]
RLISP88                                                 (page 204)

Rlisp '88 is a superset of the Rlisp that has been traditionally used
for the support of REDUCE.  It is fully documented in the book Marti,
J.B., ``RLISP '88: An Evolutionary Approach to Program Design and
Reuse'', World Scientific, Singapore (1993).  It supports different
looping constructs from the traditional Rlisp, and treats ``-'' as a
letter unless separated by spaces.  Turning on the switch RLISP88
converts to Rlisp '88 parsing conventions in symbolic mode, and
enables the use of Rlisp '88 extensions.  Turning off the switch
reverts to the traditional Rlisp and the previous mode (SYMBOLIC or
ALGEBRAIC) in force before RLISP88 was turned on.

\endsection
\item[RLROOTNO]
RLROOTNO                                                (page 369)

The function RLROOTNO computes the number of real roots of p  in the
specified region, but does not find the roots.

        RLROOTNO(expression)
        RLROOTNO(expression, POSITIVE)
        RLROOTNO(expression, NEGATIVE)
        RLROOTNO(expression, lo, hi)

For more details on the specification of an interval, see ISOLATER.

Examples:
        load_package roots;
        rlrootno (x^3-3x^2+2x+10);              1
        rlrootno(x^3-3x^2+2x+10,positive);      0
\endsection
\xitem[root finding]
root finding                                            (page 367)

\endsection
\item[ROOT_OF]
ROOT_OF                                                 (pages 85, 86)

When the operator SOLVE is unable to find an explicit solution or if
that solution would be too complicated, the result is presented as
formal root expression using the internal operator ROOT_OF and a new
local variable. An expression with a top level ROOT_OF is implicitly a
list with an unknown number of elements since we can't always know how
many solutions an equation has. If a substitution is made into such an
expression, closed form solutions can emerge. If this occurs, the
ROOT_OF construct is replaced by an operator ONE_OF. At this point it
is of course possible to transform the result if the original SOLVE
operator expression into a standard SOLVE solution. To effect this,
the operator EXPAND_CASES can be used.

Examples:                                      7     2
solve(a*x^7-x^2+1,x);           {x=root_of(a*x_  - x_  + 1,x_)}
sub(a=0,ws);                    {x=one_of(1,-1)}
expand_cases ws;                {x=1,x=-1}

The components of ROOT_OF and ONE_OF expressions can be processed as
usual with operators ARGLENGTH and PART.

\endsection
\item[ROOT_MULTIPLICITES]
ROOT_MULTIPLICITES

The ROOT_MULTIPLICITIES variable is set to the list of the
multiplicities of the roots of an equation by the SOLVE operator.


SOLVE returns its solutions in a list.  The multiplicities of
each solution are put in the corresponding locations of the list
ROOT_MULTIPLICITIES.

\endsection
\xitem[ROOT_VAL]
ROOT_VAL                                                (page 370)

\endsection
\item[ROOTACC]
ROOTACC                                                 (page 373)

The operator ROOTACC allows you to set the accuracy up to which the
roots package computes its results.

        ROOTACC(n)

Here n is an integer value. The internal accuracy of the ROOTS package
is adjusted to a value of MAX(6,N). The default value is 6.

\endsection
\xitem[ROOTMSG]
ROOTMSG                                                 (page 373)

\endsection
\xitem[ROOTPREC]
ROOTPREC                                                (page 374)

\endsection
\item[ROOTS]
ROOTS                                                   (pages 184, 369, 370)

The operator ROOTS is the main top level function of the roots
package.  It will find all roots, real and complex, of the polynomial
p to an accuracy that is sufficient to separate them and which is a
minimum of 6 decimal places.

        ROOTS(p)

where p is a univariate polynomial. Result is a LIST of equations
which represent the roots of the polynomial at the given accuracy. In
addition, ROOTS stores separate lists of real roots and complex roots
in the global variables ROOTSREAL and ROOTSCOMPLEX.

Examples:

        roots(x^5-2);            {X=-0.929316 + 0.675188*I,
                                  X=-0.929316 - 0.675188*I,
                                  X=0.354967 + 1.09248*I,
                                  X=0.354967 - 1.09248*I, 
                                  X=1.1487}

The minimal accuracy of the result values is controlled by 
ROOTACC.

\endsection
\xitem[ROOTS package]
ROOTS package                                           (page 367)

\endsection
\xitem[ROOTS_AT_PREC]
ROOTS_AT_PREC                                           (page 370)

\endsection
\item[ROOTSCOMPLEX]
ROOTSCOMPLEX                                            (page 369)

When the operator ROOTS is called the complex roots are collected in
the global variable ROOTSCOMPLEX as LIST.

\endsection
\item[ROOTSREAL]
ROOTSREAL                                               (page 369)

When the operator ROOTS is called the real roots are collected in the
global variable ROOTREAL as LIST.

\endsection
\item[ROUND]
ROUND                                                   (page 75)

        ROUND(expression)

If its argument has a numerical value, ROUND rounds it to the nearest
integer.  For non-numeric arguments, the value is an expression in the
original operator.

Examples:
round 3.4;                       3 
round 3.5;                       4 
round a;                         ROUND(A)

\endsection
\item[ROUNDALL]
ROUNDALL                                                (page 133)

In ROUNDED mode, rational numbers are normally converted to a
floating point representation.  If ROUNDALL is off, this conversion
does not occur.  ROUNDALL is normally ON.

Examples:
on rounded;
1/2;                    0.5 
off roundall;
                         1
1/2;                    ---
                         2

\endsection
\item[ROUNDBF]
ROUNDBF                                                 (page 133)

When ROUNDED is on, the normal defaults cause underflows to be
converted to zero.  If you really want the small number that results
in such cases, ROUNDBF can be turned on.

Examples:
on rounded;
exp(-100000.1^2);               0
on roundbf;
exp(-100000.1^2);               1.18441281937E-4342953505

If a polynomial is input in ROUNDED mode at the default precision into
any ROOTS function, and it is not possible to represent any of the
coefficients of the polynomial precisely in the system floating point
representation, the switch ROUNDBF will be automatically turned on.
All rounded computation will use the internal bigfloat representation
until the user subsequently turns ROUNDBF off. (A message is output to
indicate that this condition is in effect.)

\endsection
\item[ROUNDED]
ROUNDED                                 (pages 36, 44, 78, 108, 132, 372)

When ROUNDED is on, floating-point arithmetic is enabled, with
precision initially at a system default value, which is usually 12
digits.  The precise number can be found by the command PRECISION(0).

Examples:
pi;                                      PI

                                          5
35/217;                                  ----
                                          31
on rounded;
pi;                                      3.14159265359

35/217;                                  0.161

sqrt(3);                                 1.73205080756

If more than the default number of decimal places are required, use the
PRECISION command to set the required number.

\endsection
\item[Rule lists]
Rule lists                                              (page 147)

A RULE is an instruction to replace an algebraic expression
or a part of an expression by another one. 
        lhs => rhs or
        lhs => rhs WHEN cond
lhs is an algebraic expression used as search pattern and
rhs is an algebraic expression which replaces matches of
rhs. => is the operator REPLACE.

lsh can contain free variables which are preceded by a tilde ~ in
their leftmost position in lhs.  If a rule has a WHEN cond part it
will fire only if the evaluation of cond has a result TRUE.  cond may
contain references to free variables of lhs.

Rules can be collected in a LIST which then forms a RULE LIST. RULE
LISTS can be used to collect algebraic knowledge for a specific
evaluation context.

RULES and RULE LISTS are globally activated and deactivated by LET,
FORALL, CLEARRULES.  For a single evaluation they can be locally
activate by WHERE.  The active rules for an operator can be visualised
by SHOWRULES.

Examples:
operator f,g,h;
let f(x) => x^2;
                                                 2
f(x);                                           X
g_rules:={g(~n,~x)=>h(n/2,x) when evenp n,
g(~n,~x)=>h((1-n)/2,x) when not evenp n}$
let g_rules;
g(3,x);                                         H(-1,X)

\endsection
\item[SAVEAS]
SAVEAS                                                  (page 99))
The SAVEAS command saves the current workspace under the name of its
argument.

        SAVEAS identifier

identifier can be any valid REDUCE identifier.

Examples:

(The numbered prompts are shown below, unlike in most examples)
1: solve(x^2-3);                {x=sqrt(3),x= - sqrt(3)}
2: saveas rts(0)$
3: rts(0);                      {x=sqrt(3),x= - sqrt(3)}

SAVEAS works only for the current workspace, the last algebraic
expression produced by REDUCE.  This allows you to save a result that
you did not assign to an identifier when you originally typed the
input.  For access to previous output use WS.

\endsection
\xitem[savesfs]
savesfs                                                 (page 393)

\endsection
\item[SAVESTRUCTR]
SAVESTRUCTR                                             (page 113)

When SAVESTRUCTR is on, results of the STRUCTR command are returned as
a list whose first element is the representation for the expression
and the remaining elements are equations showing the relationships of
the generated variables.

Examples:
off exp;

structr((x+y)^3 + sin(x)^2);    ANS3
                                   where
                                                  3       2
                                      ANS3 := ANS1  + ANS2

                                      ANS2 := SIN(X)

                                      ANS1 := X + Y

ans3;                           ANS3
on savestructr;
                                                       3       2
structr((x+y)^3 + sin(x)^2);    {ANS3,ANS3=ANS1  + ANS2 ,ANS2=SIN(X),ANS1=X + Y}
                                       3         2
ans3 where rest ws;             (X + Y)  + SIN(X)

In normal operation, STRUCTR is only a display command.  With
SAVESTRUCTR on, you can access the various parts of the expression
produced by STRUCTR.

The generic system names use the stem ANS.  You can change this to your
own stem by the command VARNAME.  REDUCE adds integers to this stem
to make unique identifiers.

\endsection
\xitem[Saving an expression]
Saving an expression                                    (page 111)

\endsection
\item[SCALAR]
SCALAR                                                  (pages 61, 62)

The SCALAR declaration must be made immediately after a BEGIN (or
other variable declaration such as INTEGER and REAL) and declares
local scalar variables.  They are initialised to 0.

        SCALAR identifier{,identifier}

identifier may be any valid REDUCE identifier, except T or NIL.

Scalar variables remain local, and do not share values with variables
of the same name outside the BEGIN...END BLOCK.  When the block is
finished, the variables are removed.  You may use the words REAL or
INTEGER in the place of SCALAR.  REAL and INTEGER do not indicate
type-checking by the current REDUCE; they are only for your own
information.  Declaration statements must immediately follow the
BEGIN, without a semicolon between BEGIN and the first variable
declaration.

Any variables used inside BEGIN...END blocks that were not declared
SCALAR, REAL or INTEGER are global, and any change made to them inside
the block affects their global value.  Arrays declared inside a block
are always global.

\endsection
\xitem[Scalar]
Scalar                                                  (page 43)

\endsection
\xitem[SCALEFACTORS operator]
SCALEFACTORS operator                                   (page 234)

\endsection
\item[SCIENTIFIC_NOTATION]
SCIENTIFIC_NOTATION                                     (page 34)

        SCIENTIFIC_NOTATION(m) or SCIENTIFIC_NOTATION(m,n)

m and n are positive integers.  SCIENTIFIC_NOTATION controls the
output format of floating point numbers.  At the default settings, any
number with five or less digits before the decimal point is printed in
a fixed-point notation, e.g., 12345.6.  Numbers with more than five
digits are printed in scientific notation, e.g., 1.234567E+5.
Similarly, by default, any number with eleven or more zeros after the
decimal point is printed in scientific notation.

When SCIENTIFIC_NOTATION is called with the numerical argument m a
number with more than m digits before the decimal point, or m or more
zeros after the decimal point, is printed in scientific notation.
When SCIENTIFIC_NOTATION is called with a list {m, n}, a number with
more than m digits before the decimal point, or n or more zeros after
the decimal point is printed in scientific notation.

Examples:

on rounded;
12345.6;                12345.6

123456.5;               1.234565e+5

0.00000000000000012;    1.2e-16

scientific_notation 20; {5,11}

5: 123456.7;            123456.7

0.00000000000000012;    0.00000000000000012

\endsection
\item[SCOPE]
SCOPE                                                   (page 185)

Author:  J.A. van Hulzen

REDUCE Source Code Optimization Package.

SCOPE is  a package  for the  production of  an optimised  form of  a
set  of expressions.    It  applies an  heuristic  search for  common
(sub)expressions  to  almost  any set  of  proper  REDUCE  assignment
statements.    The output  is obtained  as a  sequence of  assignment
statements.  GENTRAN is used to facilitate expression output.

\endsection
\xitem[SDER(I)]
SDER(I)                                                 (page 379)

\endsection
\item[SEC]
SEC                                                     (pages 76, 78)

The SEC operator returns the secant of its argument.

        SEC(expression) or SEC simple_expression

expression is any valid scalar REDUCE expression, simple_expression is
a single identifier or begins with a prefix operator name.

Examples:
sec abc;                             SEC(ABC) 
sec(pi);                             -1 
sec 4;                               SEC(4) 
on rounded; 
sec(4);                              - 1.52988565647 
sec log 5;                           - 25.8852966005

SEC returns a numeric value only if ROUNDED is on. Then the secant is
calculated to the current degree of floating point precision.

\endsection
\item[SECH]
SECH                                                    (pages 76, 78)

The SECH operator returns the hyperbolic secant of its argument.

        SECH(expression) or SECH simple_expression

expression is any valid scalar REDUCE expression, simple_expression is
a single identifier or begins with a prefix operator name.

Examples:
sech abc;                            SECH(ABC) 
sech(0);                             1 
sech 4;                              SECH(4) 
on rounded; 
sech(4);                             0.0366189934737 
sech log 5;                          0.384615384615

SECH returns a numeric value only if ROUNDED is on. Then the
expression is calculated to the current degree of floating point
precision.

\endsection
\item[SECOND]
SECOND                                                  (page 50)

The SECOND operator returns the second element of a list.
        SECOND(list) or SECOND list

list must be a list with at least two elements, to avoid an error
message.

Examples:
alist := {a,b,c,d};                ALIST := {A,B,C,D}
second alist;                      B
blist := {x,{aa,bb,cc},z};         BLIST := {X,{AA,BB,CC},Z}
second second blist;               BB

\endsection
\xitem[Selector]
Selector                                                (page 198)

\endsection
\xitem[Semicolon]
Semicolon                                               (page 53)

\endsection
\item[SET]
SET                                                     (pages 55, 83)

The SET operator is used for assignments when you want both sides of
the assignment statement to be evaluated.

        SET(restricted_expression,expression)

expression can be any REDUCE expression; restricted_expression
must be an identifier or an expression that evaluates to an identifier.

Examples:
a := y;                                  A := Y
                                              2
set(a,sin(x^2));                         SIN(X )
                                              2
a;                                       SIN(X )
                                              2
y;                                       SIN(X )

a := b + c;                              A := B + C

set(a-c,z);                              Z

b;                                       Z

Using an ARRAY or MATRIX reference as the first argument to SET has
the result of setting the contents of the designated element to SET's
second argument.  You should be careful to avoid unwanted side effects
when you use this facility.

\endsection
\item[SETMOD]
SETMOD                                                  (page 134)

The SETMOD command sets the modulus value for subsequent MODULAR
arithmetic.

        SETMOD integer

integer must be positive, and greater than 1.  It need not be a prime
number.

Examples:
setmod 6;                                    1 
on modular; 
16;                                          4
                                              2 
x^2 + 5x + 7;                                X  + 5*X + 1 
                                              X
x/3;                                         ---
                                              3
setmod 2;                                    6 
                                              4
(x+1)^4;                                     X  + 1 
x/3;                                         X

SETMOD returns the previous modulus, or 1 if none has been set before.
SETMOD only has effect when MODULAR is on.

Modular operations are done only on numbers such as coefficients of
polynomials, not on the exponents.  The modulus need not be prime.
Attempts to divide by a power of the modulus produces an error
message, since the operation is equivalent to dividing by 0.  However,
dividing by a factor of a non-prime modulus does not produce an error
message.

\endsection
\xitem[SGN indeterminate sign]
SGN 
      indeterminate sign                                (page 257)

\endsection
\item[SHARE]
SHARE                                                   (page 197)

The SHARE declaration allows access to its arguments by both
algebraic and symbolic modes.

        SHARE identifier{,identifier}

identifier can be any valid REDUCE identifier.

Programming in SYMBOLIC as well as algebraic mode allows you a wider
range of techniques than just algebraic mode alone.  Expressions do
not cross the boundary since they have different representations,
unless the SHARE declaration is used.  For more information on using
symbolic mode, see the REDUCE User's Manual, and the Standard Lisp
Report.

You should be aware that a previously-declared array is destroyed by
the SHARE declaration.  Scalar variables retain their values.  You can
share a declared MATRIX that has not yet been dimensioned so that it
can be used by both modes.  Values that are later put into the matrix
are accessible from symbolic mode too, but not by the usual matrix
reference mechanism.  In symbolic mode, a matrix is stored as a list
whose first element is MAT, and whose next elements are the rows of
the matrix stored as lists of the individual elements.  Access in
symbolic mode is by the operators FIRST, SECOND, THIRD and REST.

\endsection
\item[SHOWRULES]
SHOWRULES                                               (page 150)

        SHOWRULES(expression) or  SHOWRULES simple_expression

SHOWRULES returns in RULE-LIST form any OPERATOR rules associated with
its argument.

Examples:
showrules log;                  {log(e) => 1,

                                 log(1) => 0,

                                      ~x
                                 log(e  ) => ~x,

                                                    1
                                 df(log(~x),~x) => ----}
                                                    ~x

Such rules can then be manipulated further as with any LIST.  For example
RHS FIRST WS; has the value 1.

An operator may have properties that cannot be displayed in such a form,
such as the fact it is an odd function, or has a definition defined as a 
procedure.

\endsection
\item[SHOWTIME]
SHOWTIME                                                (page 70)

The SHOWTIME command prints the elapsed system time since the last
call of this command or since the beginning of the session, if it has
not been called before.

Examples:
showtime;                                   Time: 1020 ms 
                                                    2
factorize(x^4 - 8x^4 + 8x^2 - 136x - 153);  {X - 9,X  + 17,X + 1} 
showtime;                                   Time: 920 ms

The time printed is either the elapsed cpu time or the elapsed wall
clock time, depending on your system.  SHOWTIME allows you to see the
system time resources REDUCE uses in its calculations.  Your time
readings will of course vary from this example according to the system
you use.

\endsection
\item[SHUT]
SHUT                                                    (pages 153--155)

The SHUT command closes output files.
        SHUT filename{,filename}

filename must have been a file opened by OUT.


A file that has been opened by OUT must be SHUT before it is
brought in by IN.  Files that have been opened by OUT should
always be SHUT before the end of the REDUCE session, to avoid either
loss of information or the printing of extraneous information into the file.  
In most systems, terminating a session by BYE closes all open
output files.

\endsection
\xitem[Side effect]
Side effect                                             (page 48)

\endsection
\xitem[side relations]
side relations                                          (page 241)

\endsection
\item[SIGN]
SIGN                                                    (page 75)

        SIGN expression

SIGN tries to evaluate the sign of its argument. If this is possible
SIGN returns one of 1, 0 or -1.  Otherwise, the result is the original
form or a simplified variant.

Examples:
        sign(-5)                   -1
        sign(-a^2*b)               -SIGN(B)

Even powers of formal expressions are assumed to be positive only as long
as the switch COMPLEX is off.

\endsection
\xitem[SIGNATURE command]
SIGNATURE command                                       (page 271)

\endsection
\xitem[Simplification]
Simplification                                          (pages 44, 97)

\endsection
\xitem[SIMPSYS]
SIMPSYS                                                 (pages 378, 380, 383)

\endsection
\item[SIN]
SIN                                                     (pages 76, 78)

The SIN operator returns the sine of its argument.

        SIN(expression) or SIN simple_expression

expression is any valid scalar REDUCE expression, simple_expression is
a single identifier or begins with a prefix operator name.

Examples:
sin aa;                              SIN(AA) 
sin(pi/2);                           1 
on rounded; 
sin 3;                               0.14112000806 
sin(pi/2);                           1.0

SIN returns a numeric value only if ROUNDED is on.  Then the sine is
calculated to the current degree of floating point precision.  The
argument in this case is assumed to be in radians.

\endsection
\item[SINH]
SINH                                                    (pages 76, 78)

The SINH operator returns the hyperbolic sine of its argument.  The
derivative of SINH and some simple transformations are known to the
system.

        SINH(expression) or SINH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression. simple_expression must be a single identifier or
begin with a prefix operator name.

Examples:
sinh b;                                SINH(B) 
sinh(0);                               0
                                               2
df(sinh(x**2),x);                      2*COSH(X )*X 
                                        COSH(4*X)
int(sinh(4*x),x);                      -----------
                                            4
on rounded; 
sinh 4;                                27.2899171971


You may attach further functionality by defining its inverse (see
ASINH).  A numeric value is not returned by SINH unless the switch
ROUNDED is on and its argument evaluates to a number.

\endsection
\xitem[SMACRO]
SMACRO                                                  (page 196)

\endsection
\item[SOLVE]
SOLVE                                                   (pages 84, 85, 90, 181)

The SOLVE operator solves a single algebraic EQUATION or a system of
simultaneous equations.

        SOLVE(expression [ , kernel]) or

        SOLVE({expression,...} [ ,{ kernel ,...}] )
 
If the number of equations equals the number of distinct kernels, the
optional kernel argument(s) may be omitted.  expression is either a
scalar expression or an EQUATION.  When more than one expression is
given, the LIST of expressions is surrounded by curly braces.  The
optional list of KERNELs follows, also in curly braces.

Examples:
sss := solve(x^2 + 7);                  Unknown: X
                                        SSS := {X= - SQRT(7)*I,
                                        X=SQRT(7)*I}
rhs first sss;                          - SQRT(7)*I 
solve(sin(x^2*y),y);
                                            PI*(2*ARBINT(1) + 1)
                                        {Y=----------------------,
                                                      2
                                                     X

                                            2*ARBINT(1)*PI
                                         Y=----------------}
                                                   2
                                                  X

off allbranch; 
solve(sin(x**2*y),y);                    {Y=0} 
solve({3x + 5y = -4,2*x + y = -10},{x,y});    - 46     22
                                        {{x=-------,y=----}}
                                               7       7
solve({x + a*y + z,2x + 5},{x,y});            - 5      - 2*z + 5
                                        {{x=------,y=------------}}
                                              2          2*a
ab := (x+2)^2*(x^6 + 17x + 1);
                                    8      7      6       3       2
                             ab := x  + 4*x  + 4*x  + 17*x  + 69*x  + 72*x + 4

                                          6
www := solve(ab,x);          {X=ROOT_OF(X_  + 17*X_ + 1),X=-2} 
root_multiplicities;         {1,2}

Results of the SOLVE operator are returned as EQUATIONS in a LIST.
You can use the usual list access methods (FIRST, SECOND, THIRD, REST
and PART) to extract the desired equation, and then use the operators
RHS and LHS to access the right-hand or left-hand expression of the
equation.  When SOLVE is unable to solve an equation, it returns the
unsolved part as the argument of ROOT_OF, with the variable renamed to
avoid confusion, as shown in the last example above.

For one equation, SOLVE uses square-free factorisation, roots of
unity, and the known inverses of the LOG, SIN, COS, ACOS, ASIN, and
exponentiation operators.  The quadratic, cubic and quartic formulas
are used if necessary, but these are applied only when the switch
FULLROOTS is set on; otherwise or when no closed form is available the
result is returned as ROOT_OF expression. The switch TRIGFORM
determines which type of cubic and quartic formula is used.  The
multiplicity of each solution is given in a list as the system
variable ROOT_MULTIPLICITIES.  For systems of simultaneous linear
equations, matrix inversion is used.  For nonlinear systems, the
Groebner basis method is used.

Linear equation system solving is influenced by the switch CRAMER.

Singular systems can be solved when the switch SOLVESINGULAR is on,
which is the default setting.  A message is given if the system of
equations is inconsistent.

Related: ALLBRANCH switch, FULLROOTS switch, ROOTS operator, ROOT_OF
operator, TRIGFORM switch.

\endsection
\item[SOLVESINGULAR]
SOLVESINGULAR                                           (page 89)

When SOLVESINGULAR is on, singular or under determined systems of
linear equations are solved, using arbitrary real, complex or integer
variables in the answer.  Default is ON.

Examples:
                                             - ARBCOMPLEX(1)
solve({2x + y,4x + 2y},{x,y});          {{X=------------------,Y=ARBCOMPLEX(1)}}
                                                    2

                                             8*arbcomplex(2)
solve({7x + 15y - z,x - y - z},{x,y,z});{{x=-----------------,
                                                   11

                                              - 3*ARBCOMPLEX(2)
                                          Y=--------------------,
                                                     11

                                          Z=ARBCOMPLEX(2)}}

off solvesingular;
solve({2x + y,4x + 2y},{x,y});          ***** SOLVE given singular equations
solve({7x + 15y - z,x - y - z},{x,y,z});***** SOLVE given singular equations

The integer following the identifier ARBCOMPLEX above is assigned by
the system, and serves to identify the variable uniquely.  It has no other
significance.

\endsection
\xitem[SORTOUTODE]
SORTOUTODE                                              (page 350)

\endsection
\xitem[SPACEDIM command]
SPACEDIM command                                        (pages 251, 271)

\endsection
\item[SPDE]
SPDE                                                    (page 185)

Author: Fritz Schwartz

The package SPDE provides a set of functions which may be used to
determine the symmetry group of Lie- or point-symmetries of a given system of
partial differential equations.  In many cases the determining system is
solved completely automatically.  In other cases the user has to provide
additional input information for the solution algorithm to terminate.


\endsection
\xitem[SPECFN]
SPECFN                                                  (page 185)

\endsection
\xitem[SPECFN package]
SPECFN package                                          (page 391)

\endsection
\xitem[SPECFN2]
SPECFN2                                                 (page 187)

\endsection
\xitem[spherical coordinates]
spherical coordinates                                   (pages 265, 355)

\endsection
\item[SPLIT_FIELD]
SPLIT_FIELD function                                    (page 227)

SPLIT_FIELD is part of the ARNUM package for algebraic numbers.  It
calculates a primitive element of minimal degree for which a given
polynomial splits into linear factors.  The algorithm as described by
Trager.

Example:
        load arnum;
        split!_field(x**3-3*x+7);

        *** Splitting field is generated by:

          6        4        2
        A5  - 18*A5  + 81*A5  + 1215



                 4          2
        {1/126*A5  - 5/42*A5  - 1/2*A5 + 2/7,


                   4          2
         - (1/63*A5  - 5/21*A5  + 4/7),


                4          2
        1/126*A5  - 5/42*A5  + 1/2*A5 + 2/7}


        for each j in ws product (x-j);

         3
        X  - 3*X + 7


\endsection
\item[SPUR]
SPUR                                                    (page 210)

The SPUR declaration removes the special exemption from trace
calculations that was declared by NOSPUR, in high-energy physics
calculations.
        SPUR line-id{,line-id}

line-id must be a line-identifier that has previously been declared
NOSPUR.

\endsection
\xitem[SQFRF]
SQFRF                                                   (page 373)

\endsection
\item[SQRT]
SQRT                                                    (pages 76, 78)

The SQRT operator returns the square root of its argument.

        SQRT(expression)

expression can be any REDUCE scalar expression.

Examples:
sqrt(16*a^3);                 4*SQRT(A)*A 
sqrt(17);                     SQRT(17) 
on rounded; 
sqrt(17);                     4.12310562562 
off rounded;                                                             2
sqrt(a*b*c^5*d^3*27);         3*SQRT(D)*SQRT(C)*SQRT(B)*SQRT(A)*SQRT(3)*C *D

SQRT checks its argument for squared factors and removes them.

Numeric values for square roots that are not exact integers are given
only when ROUNDED is on.

Please note that SQRT(A**2) is given as A, which may be incorrect if A
eventually has a negative value.  If you are programming a calculation
in which this is a concern, you can turn on the PRECISE switch, which
causes the absolute value of the square root to be returned.

\endsection
\xitem[Standard form]
Standard form                                           (page 198)

\endsection
\xitem[Standard quotient]
Standard quotient                                       (page 198)

\endsection
\xitem[Statement]
Statement                                               (page 53)

\endsection
\xitem[Stirling Numbers]
Stirling Numbers                                        (page 185, 394)

\endsection
\item[STIRLING1]
STIRLING1                                               (pages 185, 394)

The STIRLING1 operator returns the Stirling Numbers S(n,m) of the
first kind, i.e. the number of permutations of n symbols which have
exactly m cycles (divided by (-1)**(n-m)).

        STIRLING1(integer,integer)

Examples:
        load_package specfn;                    (SPECFN)
        Stirling1 (17,4);                       -87077748875904 
                                                  - GAMMA(N + 1)
        Stirling1 (n,n-1);                      -----------------
                                                 2*GAMMA(N - 1)

The operator STIRLING1 evaluates the Stirling numbers of the first
kind by rulesets for special cases or by a computing the closed form,
which is a series involving the operators BINOMIAL and STIRLING2.

\endsection
\item[STIRLING2]
STIRLING2                                               (pages 185, 394)

The STIRLING1 operator returns the Stirling Numbers S(n,m) of the 
second kind, i.e. the number of ways of partitioning a set of n elements
into m non-empty subsets.

        STIRLING2(integer,integer)

Examples:
        load_package specfn;                    (SPECFN)
        Stirling2 (17,4);                       694337290 
                                                  GAMMA(N + 1)
        Stirling2 (n,n-1);                      ----------------
                                                 2*GAMMA(N - 1)

The operator STIRLING2 evaluates the Stirling numbers of the second
kind by rulesets for special cases or by a computing the closed form.

\endsection
\item[String]
String                                                  (page 37))
A STRING is any collection of characters enclosed in double quotation
marks (").  It may be used as an argument for a variety of commands
and operators, such as IN, REDERR and WRITE.
Examples:
write "this is a string";          this is a string 
write a, " ", b, " ",c,"!";        A B C!

\endsection
\item[STRUCTR]
STRUCTR                                                 (pages 112, 113)

The STRUCTR operator breaks its argument expression into named
subexpressions.

        STRUCTR(expression [,identifier[,identifier ...]])

expression may be any valid REDUCE scalar expression.  identifier may
be any valid REDUCE IDENTIFIER.  The first identifier is the stem for
subexpression names, the second is the name to be assigned to the
structured expression.

Examples:
structr(sqrt(x**2 + 2*x) + sin(x**2*z));        ANS1*ANS3 + ANS2

                                                   WHERE

                                                             1/2
                                                    ANS3 := X

                                                                 2
                                                    ANS2 := SIN(X *Z)

                                                                   1/2
                                                    ANS1 := (X + 2)

ans3;                                           ANS3 
on fort; 
structr((x+1)**5 + tan(x*y*z),var,aa);  
                                VAR1=TAN(X*Y*Z)
                                AA=VAR1+X**5+5.*X**4+10.*X**3+10.*X**2+5.*X+1.

The second argument to STRUCTR is optional.  If it is not given, the
default stem ANS is used by REDUCE to construct names for the
subexpression.  The names are only for display purposes: REDUCE does
not store the names and their values unless the switch SAVESTRUCTR is
on.

If a third argument is given, the structured expression as a whole is
named by this argument, when FORT is on.  The expression is not stored
under this name.  You can send these structured Fortran expressions to
a file with the OUT command.

\endsection
\xitem[Structuring]
Structuring                                             (page 97)

\endsection
\xitem[Struve Functions]
Struve Functions                                        (pages 185, 397)

\endsection
\item[STRUVEH]
STRUVEH                                                 (pages 185, 397)

The STRUVEH operator returns Struve's H function.

        STRUVEH(order,argument)

Examples:
load_package specfn;                            (SPECFN)
        
                                                     3
                                                  - BESSELJ(---,X)
                                                             2
struveh(-3/2,x);                                -------------------
                                                         I


There is currently no numeric support for the operator STRUVEH.

\endsection
\item[STRUVEL]
STRUVEL                                                 (pages 185, 397)

The STRUVEL operator returns the modified Struve L function .

        STRUVEL(order,argument)

Examples:
        load_package specfn;            (SPECFN);
                                                 3
        struvel(-3/2,x);                BESSELI(---,X)
                                                 2

There is currently no numeric support for the operator STRUVEL.

\endsection
\xitem[Sturm Sequences]
Sturm Sequences                                         (page 369)

\endsection
\item[SUB]
SUB                                                     (page 137)

The SUB operator substitutes a new expression for a kernel in an
expression.

        SUB(kernel=expression {,kernel=expression} expression)
 or 
        SUB({kernel=expression, kernel=EXPRESSION},expression})

kernel must be a KERNEL, expression can be any REDUCE scalar
expression.

Examples:
sub(x=3,y=4,(x+y)**3);                    343 
x;                                        X 
sub({cos=sin,sin=cos},cos a+sin b}        COS(B) + SIN(A)

Note in the second example that operators can be replaced using the
SUB operator.

\endsection
\xitem[SUCH THAT]
SUCH THAT                                               (page 142)

\endsection
\item[SUM]
SUM                                                     (pages 57, 58, 187)

The operator  SUM returns
the indefinite or definite  summation of a given expression.

        
SUM(expr,k[,lolim [,uplim ]])


where expr is the expression to be added, k is the
control variable (a KERNEL), and lolim and uplim
uplim are the optional lower and upper limits. If uplim is
not supplied the upper limit is taken as k. The GOSPER
algorithm is used. If  there is  no closed  form solution,  the operator 
returns the input unchanged.

Examples:
                         2   2
sum(4n**3,n);           N *(N  + 2*N + 1)

sum(2a+2k*r,k,0,n-1);   N*(2*A + N*R - R)

\endsection
\xitem[SUM-SQ]
SUM-SQ                                                  (page 404)

\endsection
\xitem[SVEC]
SVEC                                                    (page 355)

\endsection
\xitem[Switch]
Switch                                                  (pages 68, 69)

\endsection
\item[SYMBOLIC]
SYMBOLIC                                                (page 191)

The SYMBOLIC command changes REDUCE's mode of operation to symbolic.
When SYMBOLIC is followed by an expression, that expression is
evaluated in symbolic mode, but REDUCE's mode is not changed.  It is
equivalent to the LISP command.

Examples:
symbolic;                           NIL 
cdr '(a b c);                       (B C) 
algebraic; 
x + symbolic car '(y z);            X + Y

\endsection
\xitem[Symbolic mode]
Symbolic mode                                   (pages 191, 193, 197, 198)

\endsection
\xitem[Symbolic procedure]
Symbolic procedure                                      (page 196)

\endsection
\item[SYMMETRIC]
SYMMETRIC                                               (page 93)

When an operator is declared SYMMETRIC, its arguments are reordered
to conform to the internal ordering of the system.  

        SYMMETRIC identifier{,identifier}

identifier is an identifier that has been declared an operator.

Examples:
operator m,n;
symmetric m,n;
m(y,a,sin(x));                          M(SIN(X),A,Y)
n(z,m(b,a,q));                          N(M(A,B,Q),Z)

If identifier has not been declared to be an operator, the flag
SYMMETRIC is still attached to it.  When identifier is subsequently
used as an operator, the message 
        DECLARE identifier OPERATOR ? (Y OR N) 
is printed.  If the user replies Y, the symmetric property of the
operator is used.

\endsection
\xitem[system precision]
system precision                                        (page 374)

\endsection
\item[T]
T                                                       (page 37)

The constant T stands for the truth value true.  It cannot be used as
a scalar variable in a BLOCK, as a looping variable in a FOR statement
or as an OPERATOR name.

\endsection
\item[TAN]
TAN                                                     (pages 76, 78, 81)

The TAN operator returns the tangent of its argument.

        TAN(expression) or TAN simple_expression

expression is any valid scalar REDUCE expression, simple_expression is
a single identifier or begins with a prefix operator name.

Examples:
tan a;                                TAN(A) 
tan(pi/3);                            SQRT(3)
on rounded;
tan(pi/3);                            1.73205080757

TAN returns a numeric value only if ROUNDED is on.  Then the tangent
is calculated to the current degree of floating point accuracy.

When ON ROUNDED is in force, no check is made to see if the argument
to TAN is a multiple of pi/2, for which the tangent goes to positive
or negative infinity.  (Of course, since REDUCE uses a fixed-point
representation of pi/2, it produces a large but not infinite number).
You need to make a check for multiples of pi/ in any program you use
that might possibly ask for the tangent of such a quantity.

\endsection
\xitem[tangent vector]
tangent vector                                          (page 252)

\endsection
\item[TANH]
TANH                                                    (pages 76, 78)

The TANH operator returns the hyperbolic tangent of its argument.  The
derivative of TANH and some simple transformations are known to the
system.

        TANH(expression) or TANH simple_expression

expression may be any scalar REDUCE expression, not an array, matrix
or vector expression. simple_expression must be a single identifier or
begin with a prefix operator name.

Examples:
tanh b;                                TANH(B) 
tanh(0);                               0 
                                                      2
df(tanh(x*y),x);                       Y*( - TANH(X*Y)  + 1)
                                            2*X
int(tanh(x),x);                        LOG(E    + 1) - X
on rounded; 
tanh 2;                                0.964027580076

You may attach further functionality by defining its inverse (see
ATANH).  A numeric value is not returned by TANH unless the switch
ROUNDED is on and its argument evaluates to a number.

\endsection
\item[TAYLOR]
TAYLOR                                                  (page 188, 406)

The TAYLOR operator is used for expanding an expression into a Taylor
series.

TAYLOR(expression, var, expression, number)
TAYLOR(expression, var, expression, number {,var, expression, number})

expression can be any valid REDUCE algebraic expression.  var must be
a KERNEL, and is the expansion variable.  The expression following it
denotes the point about which the expansion is to take place. number
must be a non-negative integer and denotes the maximum expansion
order.  If more than one triple is specified TAYLOR will expand its
first argument independently with respect to all the variables.  Note
that once the expansion has been done it is not possible to calculate
higher orders.

Instead of a KERNEL, var may also be a list of kernels.  In this case
expansion will take place in a way so that the sum of the degrees of
the kernels does not exceed the maximum expansion order.  If the
expansion point evaluates to the special identifier INFINITY, TAYLOR
tries to expand in a series in 1/var.

The expansion is performed variable per variable, i.e. in the example
below by first expanding exp(x^2+y^2) with respect to x and then
expanding every coefficient with respect to y.

Examples:
                                           2    2    2  2      3  3
taylor(e^(x^2+y^2),x,0,2,y,0,2);      1 + Y  + X  + Y *X  + O(X ,Y )

                                           2    2          3
taylor(e^(x^2+y^2),{x,y},0,2);        1 + Y  + X  + O({X,Y} )

taylor(x*y/(x+y),x,0,2,y,0,2);        ***** Not a unit in argument to quottaylor

Note that it is not generally possible to apply the standard REDUCE
operators to a Taylor kernel.  For example, PART, COEFF, or COEFFN
cannot be used.  Instead, the expression at hand has to be converted
to standard form first using the TAYLORTOSTANDARD operator.

Differentiation of a Taylor expression is possible.  If you
differentiate with respect to one of the Taylor variables the order
will decrease by one.

Substitution is a bit restricted: Taylor variables can only be
replaced by other kernels.  There is one exception to this rule: you
can always substitute a Taylor variable by an expression that
evaluates to a constant.  Note that REDUCE will not always be able to
determine that an expression is constant: an example is sin(acos(4)).

Only simple taylor kernels can be integrated. More complicated
expressions that contain Taylor kernels as parts of themselves are
automatically converted into a standard representation by means of the
TAYLORTOSTANDARD operator.  In this case a suitable warning is
printed.

\endsection
\xitem[TAYLOR package]
TAYLOR package                                          (page 405)

\endsection
\xitem[Taylor series arithmetic]
Taylor series 
      arithmetic                                        (page 407)
      differentiation                                   (page 408)
      integration                                       (page 408)
      reversion                                         (page 408)
      substitution                                      (page 408)

\endsection
\item[TAYLORAUTOCOMBINE]
TAYLORAUTOCOMBINE switch                                (page 408)

If you set TAYLORAUTOCOMBINE to ON, REDUCE automatically combines
Taylor expressions during the simplification process.  This is
equivalent to applying TAYLORCOMBINE to every expression that contains
Taylor kernels.  Default is ON.

\endsection
\item[TAYLORAUTOEXPAND]
TAYLORAUTOEXPAND switch                                 (pages 408, 409)

TAYLORAUTOEXPAND makes Taylor expressions ``contagious'' in the sense
that TAYLORCOMBINE tries to Taylor expand all non-Taylor
subexpressions and to combine the result with the rest.  Default is
OFF.

\endsection
\item[TAYLORCOMBINE]
TAYLORCOMBINE                                           (page 407)

This operator tries to combine all Taylor kernels found in its
argument into one.  Operations currently possible are:

Addition, subtraction, multiplication, and division.
Roots, exponentials, and logarithms.
Trigonometric and hyperbolic functions and their inverses.

Examples:
                                                 1   2      3
hugo := taylor(exp(x),x,0,2);   HUGO := 1 + X + ---*X  + O(X )
                                                 2
                                       3
taylorcombine log hugo;         X + O(X )

                                          1   2      3
taylorcombine(hugo + x);        (1 + X + ---*X  + O(X )) + X
                                          2
on taylorautoexpand;
                                           1   2      3
taylorcombine(hugo + x);        1 + 2*X + ---*X  + O(X )
                                           2

Application of unary operators like LOG and ATAN will nearly always
succeed.  For binary operations their arguments have to be Taylor
kernels with the same template.  This means that the expansion
variable and the expansion point must match.  Expansion order is not
so important, different order usually means that one of them is
truncated before doing the operation.

If TAYLORKEEPORIGINAL is set to ON and if all Taylor kernels in its
argument have their original expressions kept TAYLORCOMBINE will also
combine these and store the result as the original expression of the
resulting Taylor kernel.  There is also the switch TAYLORAUTOEXPAND.

There are a few restrictions to avoid mathematically undefined
expressions: it is not possible to take the logarithm of a Taylor
kernel which has no terms (i.e. is zero), or to divide by such a
beast.  There are some provisions made to detect singularities during
expansion: poles that arise because the denominator has zeros at the
expansion point are detected and properly treated, i.e. the Taylor
kernel will start with a negative power.  (This is accomplished by
expanding numerator and denominator separately and combining the
results.)  Essential singularities of the known functions (see above)
are handled correctly.

\endsection
\item[TAYLORKEEPORIGINAL]
TAYLORKEEPORIGINAL                             (pages 406, 407, 409, 411)

TAYLORKEEPORIGINAL, if set to ON, forces the TAYLOR and all Taylor
kernel manipulation operators to keep the original expression,
i.e. the expression that was Taylor expanded.  All operations
performed on the Taylor kernels are also applied to this expression
which can be recovered using the operator TAYLORORIGINAL.  Default is
OFF.

\endsection
\item[TAYLORORIGINAL]
TAYLORORIGINAL                                          (pages 411, 412)

TAYLORORINAL can recover the original expression (the one that was
expanded) from the Taylor kernel that is given as its argument.

                TAYLORORIGINAL(expression)
                TAYLORORIGINAL simple_expression

Examples:
                                                 1   2      3
hugo := taylor(exp(x),x,0,2);   HUGO := 1 + X + ---*X  + O(X )
                                                 2
taylororiginal hugo;            
        ***** Taylor kernel doesn't have an original part in taylororiginal

on taylorkeeporiginal;
                                                 1   2      3
hugo := taylor(exp(x),x,0,2);   HUGO := 1 + X + ---*X  + O(X )
                                                 2
                                 X
taylororiginal hugo;            E

An error is signalled if the argument is not a Taylor kernel or if the
original expression was not kept, i.e. if TAYLORKEEPORIGINAL was set
OFF during expansion.

\endsection
\item[TAYLORPRINTORDER]
TAYLORPRINTORDER switch                                 (page 409)

TAYLORPRINTORDER, if set to ON, causes the remainder to be printed in
big-O notation.  Otherwise, three dots are printed.  Default is
ON.

\endsection
\item[TAYLORPRINTTERMS]
TAYLORPRINTTERMS                                        (pages 406, 412)

Only a certain number of (non-zero) coefficients are printed. If there
are more, an expression of the form N TERMS is printed to indicate how
many non-zero terms have been suppressed.  The number of terms printed
is given by the value of the shared algebraic variable
TAYLORPRINTTERMS.  Allowed values are integers and the special
identifier ALL. The latter setting specifies that all terms are to be
printed. The default setting is 5.

Examples:
taylor(e^(x^2+y^2),x,0,4,y,0,4);
                     2    1   4    2    2  2                  5  5
                1 + Y  + ---*Y  + X  + Y *X  + (4 TERMS) + O(X ,Y )
                          2
taylorprintterms := all;
                ALL
taylor(e^(x^2+y^2),x,0,4,y,0,4);
                     2    1   4    2    2  2    1   4  2    1   4    1   2  4
                1 + y  + ---*y  + x  + y *x  + ---*y *x  + ---*x  + ---*y *x
                          2                     2           2        2

                    1   4  4      5  5
                 + ---*y *x  + O(x ,y )
                    4

\endsection
\item[TAYLORREVERT]
TAYLORREVERT                                            (page 411)

TAYLORREVERT allows reversion of a Taylor series of a function f,
i.e., to compute the first terms of the expansion of the inverse of f
from the expansion of f.

        TAYLORREVERT(expression, var, var)

The first argument must evaluate to a Taylor kernel with the second
argument being one of its expansion variables.

Examples:
                                     2      6
taylor(u - u**2,u,0,5);         U - U  + O(U )
                                     2      3      4       5      6
taylorrevert(ws,u,x);           X + X  + 2*X  + 5*X  + 14*X  + O(X )

\endsection
\item[TAYLORSERIESP]
TAYLORSERIESP                                           (page 407)

The TAYLORSERIESP operator may be used to determine if its argument is
a Taylor kernel.

                TAYLORSERIESP(expression)
                TAYLORSERIESP simple_expression

Examples:
                                                                 1   2      3
hugo := taylor(exp(x),x,0,2);                   HUGO := 1 + X + ---*X  + O(X )
                                                                 2
if taylorseriesp hugo then OK;                  OK
if taylorseriesp(hugo + y) then OK else NO;     NO

Note that this operator is subject to the same restrictions as, e.g.,
ORDP or NUMBERP, i.e. it may only be used in boolean expressions in IF
or LET statements.
\endsection
\item[TAYLORTEMPLATE]
TAYLORTEMPLATE                                          (pages 407, 412)

The template of a Taylor kernel, i.e. the list of all variables with
respect to which expansion took place together with expansion point
and order can be extracted using

                TAYLORTEMPLATE(expression)
                TAYLORTEMPLATE simple_expression

The operator returns a list of lists with the three elements
(VAR,VAR0,ORDER).  An error is signalled if the argument is not a
Taylor kernel.

Examples:
                                                         1   2      3
hugo := taylor(exp(x),x,0,2);           HUGO := 1 + X + ---*X  + O(X )
                                                         2
taylortemplate hugo;                    {{X,0,2}}

\endsection
\item[TAYLORTOSTANDARD]
TAYLORTOSTANDARD                                        (page 407)

The TAYLORTOSTANDARD operator converts all Taylor kernels in its
argument into standard form and resimplifies the result.

                        TAYLORTOSTANDARD(expression)
                        TAYLORTOSTANDARD simple_expression

Examples:
                                                 1   2      3
hugo := taylor(exp(x),x,0,2);   HUGO := 1 + X + ---*X  + O(X )
                                                 2
                                  2
                                 X  + 2*X + 2
taylortostandard hugo;          --------------
                                      2
\endsection
\xitem[Terminator]
Terminator                                              (page 53)

\endsection
\item[THIRD]
THIRD                                                   (page 50)

The THIRD operator returns the third item of a LIST.
        THIRD(list) or THIRD list



list must be a list containing at least three items to avoid an error
message.

Examples:
alist := {a,b,c,d};                ALIST := {A,B,C,D}
third alist;                       C
blist := {x,{aa,bb,cc},y,z};       BLIST := {X,{AA,BB,CC},Y,Z};
third second blist;                CC
third blist;                       Y

\endsection
\item[TIME]
TIME                                                    (page 68)

When TIME is on, the system time used in executing each REDUCE
statement is printed after the answer is printed.

Examples:
on time;                                Time: 4940 ms
                                                  2
df(sin(x**2 + y),y);                    COS(X  + Y )
                                        Time: 180 ms
solve(x**2 - 6*y,x);                    {X= - SQRT(Y)*SQRT(6),
                                         X=SQRT(Y)*SQRT(6)}
                                        Time: 320 ms

When TIME is first turned on, the time since the beginning of the
REDUCE session is printed.  After that, the time used in computation,
(usually in milliseconds, though this is system dependent) is printed
after the results of each command.  Idle time or time spent typing in
commands is not counted.  If TIME is turned off, the first reading
after it is turned on again gives the time elapsed since it was turned
off.  The time printed is CPU or wall clock time, depending on the
system.

\endsection
\item[TORDER]
TORDER                                                  (pages 296, 315, 316)

The operator TORDER sets the actual term order.

1. simple term order:
        TORDER m

where m is the name of a term order mode LEX term order, GRADLEX term
order, REVGRADLEX term order or another implemented parameterless
mode.

2. stepped term order:
        TORDER m,n
        TORDER {m,n}
  
where m is the name of a two step term order, one of GRADLEXGRADLEX
term order, GRADLEXREVGRADLEX term order, LEXGRADLEX term order or
LEXREVGRADLEX term order, and n is a positive integer.

3. weighted term order
        TORDER WEIGHTED, n,n,...
        TORDER WEIGHTED, {n,n,...}

where the n are positive integers, see weighted term order.

TORDER sets the term order mode.   The default mode is LEX. The
previous order mode is returned.

\endsection
\item[TP]
TP                                                      (page 165)

The TP operator returns the transpose of its MATRIX
 argument.
        TP identifier or  TP(identifier)

identifier must be a matrix, which either has had its dimensions set
in its declaration, or has had values put into it by MAT.

Examples:
matrix m,n;
m := mat((1,2,3),(4,5,6))$
n := tp m;                      N(1,1) := 1
                                N(1,2) := 4
                                N(2,1) := 2
                                N(2,2) := 5
                                N(3,1) := 3
                                N(3,2) := 6

In an assignment statement involving TP, the matrix identifier on the
left-hand side is redimensioned to the correct size for the transpose.

\endsection
\item[TPS]
TPS                                                     (pages 188, 330)

Authors:  Alan Barnes and Julian Padget

A Truncated Power Series Package.

This  package implements  formal  Laurent  series expansions  in  one
variable using the domain mechanism of REDUCE.  This means that power
series objects  can be added,  multiplied, differentiated etc.,  like
other first class  objects in the system.   A lazy  evaluation scheme
is used  and thus terms  of the series  are not evaluated  until they
are required  for printing or for  use in calculating terms  in other
power  series.    The  series  are  extendible giving  the  user  the
impression that the full  infinite series is being manipulated.   The
errors that  can sometimes occur using  series that are  truncated at
some fixed  depth (for  example when  a term  in the required  series
depends  on terms  of an  intermediate series  beyond the  truncation
depth) are thus avoided.

\endsection
\xitem[TRA]
TRA                                                     (page 178)

\endsection
\item[TRACE]
TRACE                                                   (page 166)

The TRACE operator finds the trace of its MATRIX argument.
        TRACE(expression) or TRACE simple_expression

expression or simple_expression must evaluate to a square
matrix.

Examples:
matrix a;
a := mat((x1,y1),(x2,y2))$
trace a;                                X1 + Y2

The trace is the sum of the entries along the diagonal of a square matrix.
Given a non-matrix expression, or a non-square matrix, TRACE returns
an error message.

\endsection
\xitem[tracing EXCALC]
tracing 
      EXCALC                                            (page 266)
      ODESOLVE                                          (page 351)
      ROOTS package                                     (page 373)
      SPDE package                                      (page 380)
      SUM package                                       (page 404)

\endsection
\item[TRALLFAC]
TRALLFAC

When TRALLFAC is on, a more detailed trace of factoriser calls is
generated.


The TRALLFAC switch takes precedence over TRFAC if they are
both on. TRFAC gives a factorisation trace with less detail in it.
When the FACTOR switch is on also, all input polynomials are sent to
the factoriser automatically and trace information is generated.  The
OUT command saves the results of the factoring, but not the trace.


\endsection
\item[TRFAC]
TRFAC                                                   (page 122)

When TRFAC is on, a narrative trace of any calls to the factoriser is
generated.  Default is OFF.


When the switch FACTOR is on, and TRFAC is on, every input
polynomial is sent to the factoriser, and a trace generated.  With
FACTOR off, only polynomials that are explicitly factored with the
command FACTORIZE generate trace information.

The OUT command saves the results of the factoring, but not
the trace.  The TRALLFAC switch gives trace information to a
greater level of detail.

\endsection
\item[TRGROEB]
TRGROEB                                                 (pages 299, 303)

If TRGROEB is on, intermediate H polynomials are printed during a
GROEBNER or GROEBNERF calculation.

\endsection
\xitem[TRGROEB1]
TRGROEB1                                                (pages 299, 303)

\endsection
\xitem[TRGROEBR]
TRGROEBR                                                (page 304)

\endsection
\item[TRGROEBS]
TRGROEBS                                                (pages 299, 303)

If TRGROEBS is on, intermediate H and S polynomials are printed during
a GROEBNER or GROEBNERF calculation.

\endsection
\item[TRIGFORM]
TRIGFORM                                                (page 87)

When FULLROOTS is on, SOLVE will compute the
roots of a cubic or quartic polynomial is closed form. When 
TRIGFORM is on, the roots will be expressed by trigonometric
forms. Otherwise nested surds are used. Default is ON.

\endsection
\item[TRINT]
TRINT                                                   (page 178)

When TRINT is on, a narrative tracing various steps in the
integration process is produced.

The OUT command saves the results of the integration, but not the
trace.

\endsection
\item[TRNONLNR]
TRNONLNR

When TRNONLNR is on, a narrative tracing various steps in
the process for solving non-linear equations is produced.


TRNONLNR can only be used after the solve package has been loaded
(e.g., by an explicit call of LOAD_PACKAGE).  The OUT
command saves the results of the equation solving, but not the trace.

\endsection
\xitem[TRODE]
TRODE                                                   (page 351)

\endsection
\xitem[TRROOT]
TRROOT                                                  (page 373)

\endsection
\xitem[TRSUM]
TRSUM                                                   (page 404)

\endsection
\xitem[truncated power series]
truncated power series                                  (page 413)

\endsection
\xitem[TVECTOR command]
TVECTOR command                                         (pages 249, 271)

\endsection
\xitem[U(ALFA)]
U(ALFA)                                                 (page 379)

\endsection
\xitem[U(ALFA]
U(ALFA,I)                                               (page 379)

\endsection
\item[UNTIL]
UNTIL                                                   (page 57)

See the FOR loop construction.
\endsection
\xitem[User packages]
User packages                                           (page 177)

\endsection
\xitem[VARDF]
VARDF                                                   (pages 257, 271)

\endsection
\xitem[Variable]
Variable                                                (page 36)

\endsection
\xitem[Variable elimination]
Variable elimination                                    (page 181)

\endsection
\xitem[variational derivative]
variational derivative                                  (page 257)

\endsection
\item[VARNAME]
VARNAME                                                 (pages 111, 112)

The declaration VARNAME instructs REDUCE to use its argument as the
default Fortran (when FORT is on) or STRUCTR identifier and identifier
stem, rather than using ANS.

        VARNAME identifier

identifier can be any combination of one or more alphanumeric
characters.  Try to avoid REDUCE reserved words.

Examples:
varname ident;                        IDENT
on fort;
x**2 + 1;                             IDENT=X**2+1.

off fort,exp;                               3
structr(((x+y)**2 + z)**3);           IDENT2
                                            where
                                                               2
                                               IDENT2 := IDENT1  + Z
                                               IDENT1 := X + Y

EXP was turned off so that STRUCTR could show the structure.  If EXP
had been on, the expression would have been expanded into a
polynomial.

\endsection
\xitem[VDF]
VDF                                                     (page 359)

\endsection
\xitem[VEC command]
VEC command                                             (page 232)

\endsection
\item[VECDIM]
VECDIM                                                  (page 212)

The SPUR declaration removes the special exemption from trace
calculations that was declared by NOSPUR, in high-energy physics
calculations.
        SPUR line-id{,line-id}

line-id must be a line-identifier that has previously been declared
NOSPUR.

\endsection
\item[VECTOR]
VECTOR (High Energy Physics)                            (page 208)

The VECTOR declaration declares that its arguments are of type VECTOR.
        VECTOR identifier{,identifier}

identifier must be a valid REDUCE identifier.  It may have already
been used for a matrix, array, operator or scalar variable.  After an
identifier has been declared to be a vector, it may not be used as a
scalar variable.

Vectors are special entities for high-energy physics calculations.
You cannot put values into their coordinates; they do not have
coordinates.  They are legal arguments for the high-energy physics
operators EPS, G and . (dot).  Vector variables are used to represent
gamma matrices and gamma matrices contracted with Lorentz 4-vectors,
since there are no Dirac variables per se in the system.  Vectors do
follow the usual vector rules for arithmetic operations: + and -
operate upon two or more vectors, producing a vector; * and / cannot
be used between vectors; the scalar product is represented by the
. operator; and the product of a scalar and vector expression is well
defined, and is a vector.

You can represent components of vectors by including representations
of unit vectors in your system.  For instance, letting E0 represent
the unit vector (1,0,0,0), the command

V1.E0 := 0;

would set up the substitution of zero for the first component of the
vector V1.

Identifiers that are declared by the INDEX and MASS declarations are
automatically declared to be vectors.

The following errors can occur in calculations using the high energy
physics package:

A REPRESENTS ONLY GAMMA5 IN VECTOR EXPRESSIONS
You have tried to use A in some way other than gamma5 in a high-energy
physics expression.

GAMMA5 NOT ALLOWED UNLESS VECDIM IS 4
You have used gamma_5 in a high-energy physics computation involving a
vector dimension other than 4.

ID HAS NO MASS
One of the arguments to MSHELL has had no mass assigned to it, in
high-energy physics calculations.

MISSING ARGUMENTS FOR G OPERATOR
A line symbol is missing in a gamma matrix expression in high-energy physics
calculations.

UNMATCHED INDEX list
The parser has found unmatched indices during the evaluation of a
gamma matrix expression in high-energy physics calculations.

\endsection
\xitem[vector]
vector ,  integration 233
      addition                                          (page 356)
      cross product                                     (page 357)
      differentiation                                   (page 233)
      division                                          (page 357)
      dot product                                       (page 357)
      exponentiation                                    (page 357)
      inner product                                     (page 357)
      modulus                                           (page 357)
      multiplication                                    (page 357)
      subtraction                                       (page 356)

\endsection
\xitem[vector algebra]
vector algebra                                          (page 231)

\endsection
\xitem[VECTORADD]
VECTORADD                                               (page 356)

\endsection
\xitem[VECTORCROSS]
VECTORCROSS                                             (page 357)

\endsection
\xitem[VECTORDIFFERENCE]
VECTORDIFFERENCE                                        (page 356)

\endsection
\xitem[VECTOREXPT]
VECTOREXPT                                              (page 357)

\endsection
\xitem[VECTORMINUS]
VECTORMINUS                                             (page 356)

\endsection
\xitem[VECTORPLUS]
VECTORPLUS                                              (page 356)

\endsection
\xitem[VECTORQUOTIENT]
VECTORQUOTIENT                                          (page 357)

\endsection
\xitem[VECTORRECIP]
VECTORRECIP                                             (page 357)

\endsection
\xitem[VECTORTIMES]
VECTORTIMES                                             (page 357)

\endsection
\xitem[VERBOSELOAD switch]
VERBOSELOAD switch                                      (page 409)

\endsection
\xitem[VINT]
VINT                                                    (page 360)

\endsection
\xitem[VMOD]
VMOD                                                    (page 357)

\endsection
\xitem[VMOD operator]
VMOD operator                                           (page 233)

\endsection
\xitem[VOLINT]
VOLINT                                                  (page 360)

\endsection
\xitem[VOLINTEGRAL function]
VOLINTEGRAL function                                    (page 237)

\endsection
\xitem[VOLINTORDER vector]
VOLINTORDER vector                                      (page 237)

\endsection
\xitem[VORDER]
VORDER                                                  (page 359)

\endsection
\xitem[VOUT]
VOUT                                                    (page 355)

\endsection
\xitem[VSTART]
VSTART                                                  (page 354)

\endsection
\xitem[VTAYLOR]
VTAYLOR                                                 (page 359)

\endsection
\xitem[wedge]
wedge                                                   (page 271)

\endsection
\item[WEIGHT]
WEIGHT                                                  (page 152)

The WEIGHT command is used to attach weights to kernels for asymptotic
constraints.

        WEIGHT kernel = number

kernel must be a REDUCE KERNEL, number must be a positive integer, not
0.

Examples:                               4      3        2  2        3    4
a := (x+y)**4;                    A := X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y
weight x=2,y=3;
wtlevel 8; 
                                   4
a;                                X
wtlevel 10;
                                    2     2             2
a;                                 X *(6*Y  + 4*X*Y  + X )
int(x**2,x);                      ***** X invalid as KERNEL

Weights and WTLEVEL are used for asymptotic constraints, where
higher-order terms are considered insignificant.

Weights are originally equivalent to 0 until set by a WEIGHT command.
To remove a weight from a kernel, use the CLEAR command.  Weights once
assigned cannot be changed without clearing the identifier.  Once a
weight is assigned to a kernel, it is no longer a kernel and cannot be
used in any REDUCE commands or operators that require kernels, until
the weight is cleared.  Note that terms are ordered by greatest
weight.

The weight level of the system is set by WTLEVEL, initially at 2.
Since no kernels have weights, no effect from WTLEVEL can be seen.
Once you assign weights to kernels, you must set WTLEVEL correctly for
the desired operation.  When weighted variables appear in a term,
their weights are summed for the total weight of the term (powers of
variables multiply their weights).  When a term exceeds the weight
level of the system, it is discarded from the result expression.

\endsection
\xitem[weighted ordering]
weighted ordering                                       (page 316)

\endsection
\item[WHEN]
WHEN                                                    (page 147)

The WHEN operator is used inside a RULE to make the
execution of the rule depend on a boolean condition which is
evaluated at execution time. For the use see RULE. 

\endsection
\item[WHERE]
WHERE                                                   (page 148)

The WHERE operator provides an infix notation for one-time
substitutions for kernels in expressions.

        expression WHERE kernel = expression{,kernel = expression}

expression can be any REDUCE scalar expression, kernel must be a
KERNEL. Alternatively a RULE or a RULE LIST can be a member of the
right-hand part of a WHERE expression.

Examples:
x**2 + 17*x*y + 4*y**2 where x=1,y=2;        
                                        51
for i := 1:5 collect x**i*q where q= for j := 1:i product j;
                                              2    3     4      5
                                        {X,2*X ,6*X ,24*X ,120*X }
                                         2    3
x**2 + y + z where z=y**3,y=3;          X  + Y  + 3

Substitution inside a WHERE expression has no effect upon the values
of the kernels outside the expression.  The WHERE operator has the
lowest precedence of all the infix operators, which are lower than
prefix operators, so that the substitutions apply to the entire
expression preceding the WHERE operator.  However, WHERE is applied
before command keywords such as THEN, REPEAT, or DO.

A RULE or a RULE SET in the right-hand part of the WHERE expression
act as if the rules were activated by LET immediately before the
evaluation of the expression and deactivated by CLEARRULES immediately
afterwards.

WHERE gives you a natural notation for auxiliary variables in
expressions.  As the second example shows, the substitute expression
can be a command to be evaluated.  The substitute assignments are made
in parallel, rather than sequentially, as the last example shows.  The
expression resulting from the first round of substitutions is not
reexamined to see if any further such substitutions can be made.
WHERE can also be used to define auxiliary variables in PROCEDURE
definitions.

\endsection
\item[WHILE]
WHILE                                                   (pages 59, 61, 63, 65)

The WHILE command causes a statement to be repeatedly executed until a
given condition is true.  If the condition is initially false, the
statement is not executed at all.

        WHILE condition DO statement

condition is given by a logical operator, statement must be a single
REDUCE statement, or a GROUP (<<...>>) or BEGIN...END block.

Examples:
a := 10;                                   A := 10
while a <= 12 do <<write a; a := a + 1>>;  10
                                           11
                                           12
while a < 5 do <<write a; a := a + 1>>;    .... nothing is printed

\endsection
\xitem[WHITTAKERM]
WHITTAKERM                                              (pages 185, 397)

\endsection
\item[WHITTAKERW]
WHITTAKERW                                              (pages 185, 397)

The WHITTAKERW operator returns Whittaker's W function.

        WHITTAKERW(parameter,parameter,argument)

Examples:
load_package specfn;                    (SPECFN)
                                                            1
                                         4*SQRT(2)*KUMMERU(---,5,2)
                                                            2
WhittakerW(2,2,2);                      ----------------------------
                                                     E

Whittaker's W function is one of the Confluent Hypergeometric functions.
For reference see the HYPERGEOMETRIC operator.

\endsection
\xitem[Workspace]
Workspace                                               (page 99)

\endsection
\item[WRITE]
WRITE                                                   (page 105))

The WRITE command explicitly writes its arguments to the output device
(terminal or file).

        WRITE item{,item}

item can be an expression, an assignment or a STRING enclosed in
double quotation marks (").

Examples:
write a, sin x, "this is a string";             ASIN(X)this is a string 
write a," ",sin x," this is a string";          A SIN(X) this is a string 
if not numberp(a) then write "the symbol ",a;   the symbol A 
array m(10); 
for i := 1:5 do write m(i) := 2*i;            
                                                M(1) := 2
                                                M(2) := 4
                                                M(3) := 6
                                                M(4) := 8
                                                M(5) := 10
m(4);                                           8

The items specified by a single WRITE statement print on a single line
unless they are too long.  A printed line is always ended with a carriage
return, so the next item printed starts a new line.

When an assignment statement is printed, the assignment is also made.
This allows you to get feedback on filling slots in an array with a
FOR statement, as shown in the last example above.

\endsection
\item[WS]
WS                                                      (pages 29, 158)

The WS operator alone returns the last result; WS with a number
argument returns the results of the REDUCE statement executed after
that numbered prompt.

        WS or WS(number)

number must be an integer between 1 and the current REDUCE prompt number.

Examples:
(In the following examples, unlike most others, the numbered
prompt is shown.)
1: df(sin y,y);     COS(Y) 
                          2
2: ws^2;            COS(Y)

3: df(ws 1,y);      -SIN(Y)

WS and WS(number) can be used anywhere the expression they stand for
can be used.  Calling a number for which no result was produced, such
as a switch setting, will give an error message.

The current workspace always contains the results of the last REDUCE
command that produced an expression, even if several input statements
that do not produce expressions have intervened.  For example, if you
do a differentiation, producing a result expression, then change
several switches, the operator WS; returns the results of the
differentiation.  The current workspace (WS) can also be used inside
files, though the numbered workspace contains only the IN command that
input the file.

There are three history lists kept in your REDUCE session.  The first
stores raw input, suitable for the statement editor.  The second
stores parsed input, ready to execute and accessible by INPUT.  The
third stores results, when they are produced by statements, which are
accessible by the WS n operator.  If your session is very long,
storage space begins to fill up with these expressions, so it is a
good idea to end the session once in a while, saving needed
expressions to files with the SAVEAS and OUT commands.

An error message is given if a reference number has not yet been used.

\endsection
\item[WTLEVEL]
WTLEVEL                                                 (page 152)

In conjunction with WEIGHT, WTLEVEL is used to implement asymptotic
constraints.  Default value is 2.

        WTLEVEL integer

integer is a positive integer that is the greatest weight term to be
retained in expressions involving kernels with weight assignments.

Examples:                               4      3        2  2        3    4
(x+y)**4;                              X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y
weight x=2,y=3;
wtlevel 8;
                                        4
(x+y)**4;                              X
wtlevel 10;
                                        2     2            2
(x+y)**4;                              X *(6*Y  + 4*X*Y + X )
int(x**2,x);                           ***** X invalid as KERNEL

WTLEVEL is used in conjunction with the command WEIGHT to enable
asymptotic constraints.  Weight of a term is computed by multiplying
the weights of each variable in it by the power to which it has been
raised, and adding the resulting weights for each variable.  If the
weight of the term is greater than WTLEVEL, the term is dropped from
the expression, and not used in any further computation involving the
expression.

Once a weight has been attached to a KERNEL, it is no longer
recognised by the system as a kernel, though still a variable.  It
cannot be used in REDUCE commands and operators that need kernels.
The weight attachment can be undone with a CLEAR command. WTLEVEL can
be changed as desired.

\endsection
\xitem[X(I)]
X(I)                                                    (page 379)

\endsection
\xitem[XI(I)]
XI(I)                                                   (page 379)

\endsection
\item[XPND command]
XPND command                                            (pages 253, 254, 271)

(Part of the EXCALC package)

There are two forms of the XPND command, which controls the use of the
product rule for the d operator and the expansion into partial
derivatives.  The default for both these is ON.

        xpnd d;
        xpnd @;

Example:
        load_package excalc;            *** ^ redefined
                                        (excalc)
        pform x=0,y=k,z=m;
                                              K
        d(y^z);                         ( - 1) *Y^d Z + d Y^Z

        noxpnd d;
        d(y^z);                         d(Y^Z)


See also NOXPND

\endsection
\item[ZETA]
ZETA                                                    (pages 185, 395)

The ZETA operator returns Riemann's Zeta function, 

  Zeta (z) := sum(1/(k**z),k,1,infinity)

                ZETA(expression)

Examples:
        load_package specfn;           (SPECFN)
                                           2
                                         PI
        Zeta(2);                        -----
                                          6
        on rounded; 
        Zeta 1.01;                     100.577943338

Numerical computation for the Zeta function for arguments close to 1
are tedious, because the series is converging very slowly. In this
case a formula (e.g. found in Bender/Orzag: Advanced Mathematical
Methods for Scientists and Engineers, McGraw-Hill) is used.

No numerical approximation for complex arguments is done.

\endsection
\xitem[ZETA(ALFA,I)]
ZETA(ALFA,I)                                            (page 379)

\endsection
