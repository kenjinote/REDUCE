
<a name=r38_0150>

<title>EXPREAD</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>EXPREAD</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>expread</em>() 
<P>
<P>
<P>
<em>expread</em>reads one well-formed expression from the current input 
buffer and returns its value. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
expread(); a+b; 

  A + B

</tt></pre><p>
<a name=r38_0151>

<title>FACTORIZE</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>FACTORIZE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>factorize</em> operator factors a given expression into a list of 
{factor,power} pairs. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>factorize</em>(&lt;expression&gt;) 
<P>
<P>
<P>
&lt;expression&gt; should be a polynomial, otherwise an error will result. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>

fff := factorize(x^3 - y^3); 

         2          2
  		  {{X  + X*Y + Y ,1},{X - Y,1}} 


fac1 := first fff; 

             2          2
  FAC1 := {{X  + X*Y + Y ,1} 


factorize(x^15 - 1); 

       8    7    6    5    4
   {{ X  - X  + X  - X  + X  - X + 1,1},
     4    3    2
   {X  + X  + X  + X + 1,1},
     2
   {X  + X + 1,1},
   {X - 1,1}}


lastone := part(ws,length ws); 

  	LASTONE := {X - 1,1} 


setmod 2; 

  1 


on modular; 

factorize(x^15 - 1); 

     4    3    2
  {{X  + X  + X  + X + 1,1},
     4    3
   {X  + X  + 1,1},
     4
   {X  + X + 1,1},
      2
   { X  + X + 1,1},
   {X + 1,1}}

</tt></pre><p>The <em>factorize</em> command returns the factor,power pairs as a
 
<a href=r38_0050.html#r38_0053>list</a>. 
You can therefore use the usual list access methods (
<a href=r38_0001.html#r38_0046>first</a>, 

<a href=r38_0050.html#r38_0063>second</a>, 
<a href=r38_0050.html#r38_0066>third</a>, 
<a href=r38_0050.html#r38_0057>rest</a>, 
<a href=r38_0150.html#r38_0157>length</a> and 

<a href=r38_0150.html#r38_0169>part</a>) to extract these pairs. 
<P>
<P>
If the &lt;expression&gt; given to <em>factorize</em> is an integer, it will be 

factored into its prime components. To factor any integer factor of a 
non-numerical expression, the switch 
<a href=r38_0250.html#r38_0296>ifactor</a> should be turned on. 
Its default is off. 
<a href=r38_0250.html#r38_0296>ifactor</a> has effect only when factoring is 
explicitly done by <em>factorize</em>, not when factoring is automatically 
done with the 
<a href=r38_0250.html#r38_0287>factor</a> switch. If full factorization is not 
needed the switch 
<a href=r38_0300.html#r38_0301>limitedfactors</a> allows you to reduce the 
computing time of calls to <em>factorize</em>. 
<P>
<P>
Factoring can be done in a modular domain by calling <em>factorize</em> when 

<a href=r38_0300.html#r38_0305>modular</a> is on. You can set the modulus with t
he 
<a href=r38_0100.html#r38_0104>setmod</a> 
command. The last example above shows factoring modulo 2. 
<P>
<P>
For general comments on factoring, see comments under the switch 

<a href=r38_0250.html#r38_0287>factor</a>. 
<P>
<P>
<P>

<a name=r38_0152>

<title>HYPOT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>HYPOT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
<P>
<P>
 <P> <H3> 
syntax: </H3>
hypot(&lt;expression&gt;,&lt;expression&gt;) 
<P>
<P>
<P>
If <em>rounded</em> is on, and the two arguments evaluate to numbers, this 
operator returns the square root of the sums of the squares of the 
arguments in a manner that avoids intermediate overflow. In other cases, 
an expression in the original operator is returned. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
hypot(3,4); 

  HYPOT(3,4) 


on rounded; 

ws; 

  5.0 


hypot(a,b); 

  HYPOT(A,B)

</tt></pre><p>
<a name=r38_0153>

<title>IMPART</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>IMPART</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>impart</em>(&lt;expression&gt;) or <em>impart</em> &lt;simple\_expression
&gt; 
<P>
<P>
<P>
This operator returns the imaginary part of an expression, if that 
argument has an numerical value. A non-numerical argument is returned as 
an expression in the operators 
<a href=r38_0150.html#r38_0173>repart</a> and <em>impart</em>. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>
impart(1+i); 

  1 


impart(a+i*b); 

  REPART(B) + IMPART(A)

</tt></pre><p><P>
<P>

<a name=r38_0154>

<title>INT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>INT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>int</em> operator performs analytic integration on a variety of 
functions. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>int</em>(&lt;expression&gt;,&lt;kernel&gt;) 
<P>
<P>
<P>
&lt;expression&gt; can be any scalar expression. involving polynomials, log 
functions, exponential functions, or tangent or arctangent expressions. 
<em>int</em> attempts expressions involving error functions, dilogarithms 
and other trigonometric expressions. Integrals involving algebraic 
extensions (such as square roots) may not succeed. &lt;kernel&gt; must be a 
REDUCE 
<a href=r38_0001.html#r38_0002>kernel</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
int(x**3 + 3,x); 

      3
  X*(X  + 12)
  ----------- 
       4



int(sin(x)*exp(2*x),x);
 

     2*X
    E   *(COS(X) - 2*SIN(X))
  - ------------------------ 
               5


int(1/(x^2-2),x);
 

  SQRT(2)*(LOG( - SQRT(2) + X) - LOG(SQRT(2) + X))
  ------------------------------------------------ 
                         4


int(sin(x)/(4 + cos(x)**2),x);
 

         COS(X)
    ATAN(------)
           2
  - ------------ 
         2



int(1/sqrt(x^2-x),x); 

      SQRT(X)*SQRT(X - 1)
  INT(-------------------,X)
              2
             X -X

</tt></pre><p>Note that REDUCE couldn't handle the last integral with its defaul
t 
integrator, since the integrand involves a square root. However, 
the integral can be found using the 
<a href=r38_0250.html#r38_0265>algint</a> package. 
Alternatively, you could add a rule using the 
<a href=r38_0150.html#r38_0199>let</a> statement 
to evaluate this integral. 
<P>
<P>
The arbitrary constant of integration is not shown. Definite integrals can 
be found by evaluating the result at the limits of integration (use 

<a href=r38_0300.html#r38_0330>rounded</a>) and subtracting the lower from the h
igher. Evaluation can 
be easily done by the 
<a href=r38_0150.html#r38_0182>sub</a> operator. 
<P>
<P>
When <em>int</em> cannot find an integral it returns an expression 
involving formal <em>int</em> expressions unless the switch 

<a href=r38_0250.html#r38_0288>failhard</a> has been set. If not all of the expr
ession 
can be integrated, the switch 
<a href=r38_0300.html#r38_0311>nolnr</a> controls whether a partially 
integrated result should be returned or not. 
<P>
<P>
<P>
<P>

<a name=r38_0155>

<title>INTERPOL</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>INTERPOL</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
<em>interpol</em>generates an interpolation polynomial. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
interpol(&lt;values&gt;,&lt;variable&gt;,&lt;points&gt;) 
<P>
<P>
<P>
&lt;values&gt; and &lt;points&gt; are 
<a href=r38_0050.html#r38_0053>list</a>s of equal length and 
&lt;variable&gt; is an algebraic expression (preferably a 
<a href=r38_0001.html#r38_0002>kernel</a>). 
The interpolation polynomial is generated in the given variable of degree 
length(&lt;values&gt;)-1. The unique polynomial <em>f</em> is defined by the 
property that for corresponding elements <em>v</em> of &lt;values&gt; and 
<em>p</em> of &lt;points&gt; the relation <em>f(p)=v</em> holds. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
f := for i:=1:4 collect(i**3-1); 

  F := 0,7,26,63 


p := {1,2,3,4}; 

  P := 1,2,3,4 


interpol(f,x,p); 

   3
  X  - 1

</tt></pre><p>The Aitken-Neville interpolation algorithm is used which guarantee
s a 
stable result even with rounded numbers and an ill-conditioned problem. 
<P>
<P>
<P>

<a name=r38_0156>

<title>LCOF</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LCOF</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>lcof</em> operator returns the leading coefficient of a given expression
 
with respect to a given variable. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>lcof</em>(&lt;expression&gt;,&lt;kernel&gt;) 
<P>
<P>
<P>
&lt;expression&gt; is ordinarily a polynomial. If 
<a href=r38_0300.html#r38_0322>ratarg</a> is on, 
a rational expression may also be used, otherwise an error results. 
&lt;kernel&gt; must be a 
<a href=r38_0001.html#r38_0002>kernel</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
lcof((x+2*y)**5,y); 

  32 


lcof((x + y*sin(x))**2 + cos(x)*sin(x)**2,sin(x));
			 


        2
  COS(X)  + Y 


lcof(x**2 + 3*x + 17,y); 

   2
  X  + 3*X + 17

</tt></pre><p>If the kernel does not appear in the expression, <em>lcof</em> ret
urns the 
expression. 
<P>
<P>
<P>

<a name=r38_0157>

<title>LENGTH</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LENGTH</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>length</em> operator returns the number of items in a 
<a href=r38_0050.html#r38_0053>list</a>, the 
number of 
terms in an expression, or the dimensions of an array or matrix. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>length</em>(&lt;expr&gt;) or <em>length</em> &lt;expr&gt; 
<P>
<P>
<P>
&lt;expr&gt; can be a list structure, an array, a matrix, or a scalar expression
. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
alist := {a,b,{ww,xx,yy,zz}}; 

  ALIST := {A,B,{WW,XX,YY,ZZ}} 


length alist; 

  3  


length third alist; 

  4  


dlist := {d}; 

  DLIST := {D} 


length rest dlist; 

  0  


matrix mmm(4,5); 

length mmm; 

  {4,5} 


array aaa(5,3,2); 

length aaa; 

  {6,4,3} 


eex := (x+3)**2/(x-y); 

          2
         X  + 6*X + 9
  EEX := ------------ 
            X - Y


length eex; 

  5

</tt></pre><p>An item in a list that is itself a list only counts as one item. A
n error 
message will be printed if <em>length</em> is called on a matrix which has 
not had its dimensions set. The <em>length</em> of an array includes the 
zeroth element of each dimension, showing the full number of elements 
allocated. (Declaring an array A with n elements 
allocates A(0),A(1),...,A(n).) The 
<em>length</em> of an expression is the total number of additive terms 
appearing in the numerator and denominator of the expression. Note that 
subtraction of a term is represented internally as addition of a negative 
term. 
<P>
<P>
<P>

<a name=r38_0158>

<title>LHS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LHS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>lhs</em> operator returns the left-hand side of an 
<a href=r38_0001.html#r38_0045>equation</a>, 
such as those 
returned in a list by 
<a href=r38_0150.html#r38_0179>solve</a>. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>lhs</em>(&lt;equation&gt;) or <em>lhs</em> &lt;equation&gt; 
<P>
<P>
<P>
<P>
&lt;equation&gt; must be an equation of the form 
<P>
<P>
<em>left-hand side</em><em>=</em><em>right-hand side</em>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
polly := (x+3)*(x^4+2x+1); 

            5      4      2
  POLLY := X  + 3*X  + 2*X  + 7*X + 3 


pollyroots := solve(polly,x); 

  POLLYROOTS := {X=ROOT F(X3 - X2 + X + 1,X ,
                       O                   )
                 X=-1,
                 X=-3}


variable := lhs first pollyroots; 

  VARIABLE := X

</tt></pre><p>
<a name=r38_0159>

<title>LIMIT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LIMIT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
LIMITS is a fast limit package for REDUCE for functions which are 
continuous except for computable poles and singularities, based on 
some earlier work by Ian Cohen and John P. Fitch. The Truncated 
Power Series package is used for non-critical points, at which 
the value of the function is the constant term in the expansion 
around that point. l'Hopital's rule is used in critical cases, 
with preprocessing of 1-1 forms and reformatting of product forms 
in order to apply l'Hopital's rule. A limited amount of bounded 
arithmetic is also employed where applicable. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>limit</em>(&lt;expr&gt;,&lt;var&gt;,&lt;limpoint&gt;) or 
<P>
<P>
<em>limit!+</em>(&lt;expr&gt;,&lt;var&gt;,&lt;limpoint&gt;) or 
<P>
<P>
<em>limit!-</em>(&lt;expr&gt;,&lt;var&gt;,&lt;limpoint&gt;) 
<P>
<P>
<P>
where &lt;expr&gt; is an expression depending of the variable &lt;var&gt; 
(a 
<a href=r38_0001.html#r38_0002>kernel</a>) and &lt;limpoint&gt; is the limit poi
nt. 
If the limit depends upon the direction of approach to the &lt;limpoint&gt;, 
the operators <em>limit!+</em> and <em>limit!-</em> may be used. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
limit(x*cot(x),x,0);

  0


limit((2x+5)/(3x-2),x,infinity);

  2
  --
  3

</tt></pre><p>
<a name=r38_0160>

<title>LPOWER</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LPOWER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>lpower</em> operator returns the leading power of an expression with 
respect to a kernel. 1 is returned if the expression does not depend on 
the kernel. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>lpower</em>(&lt;expression&gt;,&lt;kernel&gt;) 
<P>
<P>
<P>
&lt;expression&gt; is ordinarily a polynomial. If 
<a href=r38_0300.html#r38_0322>ratarg</a> is on, 
a rational expression may also be used, otherwise an error results. 
&lt;kernel&gt; must be a 
<a href=r38_0001.html#r38_0002>kernel</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
lpower((x+2*y)**6,y); 

   6
  Y  


lpower((x + cos(x))**8 + df(x**2,x),cos(x));
			 


        8
  COS(X)  


lpower(x**3 + 3*x,y); 

  1

</tt></pre><p>
<a name=r38_0161>

<title>LTERM</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LTERM</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>lterm</em> operator returns the leading term of an expression with 
respect to a kernel. The expression is returned if it does not depend on 
the kernel. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>lterm</em>(&lt;expression&gt;,&lt;kernel&gt;) 
<P>
<P>
<P>
&lt;expression&gt; is ordinarily a polynomial. If 
<a href=r38_0300.html#r38_0322>ratarg</a> is on, 
a rational expression may also be used, otherwise an error results. 
&lt;kernel&gt; must be a 
<a href=r38_0001.html#r38_0002>kernel</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
lterm((x+2*y)**6,y); 

      6
  64*Y  


lterm((x + cos(x))**8 + df(x**2,x),cos(x));
			 


        8
  COS(X)  


lterm(x**3 + 3*x,y); 

   3
  X  + 3X

</tt></pre><p>
<a name=r38_0162>

<title>MAINVAR</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MAINVAR</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>mainvar</em> operator returns the main variable (in the system's 
internal representation) of its argument. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>mainvar</em>(&lt;expression&gt;) 
<P>
<P>
<P>
<P>
&lt;expression&gt; is usually a polynomial, but may be any valid REDUCE 
scalar expression. In the case of a rational function, the main variable 
of the numerator is returned. The main variable returned is a 

<a href=r38_0001.html#r38_0002>kernel</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
test := (a + b + c)**2; 

           2                    2            2
  TEST := A  + 2*A*B + 2*A*C + B  + 2*B*C + C  


mainvar(test); 

  A 


korder c,b,a; 

mainvar(test); 

  C 


mainvar(2*cos(x)**2); 

  COS(X) 


mainvar(17); 

  0

</tt></pre><p>The main variable is the first variable in the canonical ordering 
of 
kernels. Generally, alphabetically ordered functions come first, then 
alphabetically ordered identifiers (variables). Numbers come last, and as 
far as <em>mainvar</em> is concerned belong in the family <em>0</em>. The 
canonical ordering can be changed by the declaration 
<a href=r38_0150.html#r38_0198>korder</a>, as 
shown above. 
<P>
<P>
<P>

<a name=r38_0163>

<title>MAP</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MAP</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>map</em> operator applies a uniform evaluation pattern 
to all members of a composite structure: a 
<a href=r38_0300.html#r38_0345>matrix</a>, 
a 
<a href=r38_0050.html#r38_0053>list</a> or the arguments of an 
<a href=r38_0200.html#r38_0211>operator</a> expression. 
The evaluation pattern can be a 
unary procedure, an operator, or an algebraic expression with 
one free variable. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>map</em>(&lt;function&gt;,&lt;object&gt;) 
<P>
<P>
<P>
&lt;object&gt; is a list, a matrix or an operator expression. 
<P>
<P>
&lt;function&gt; is 
the name of an operator for a single argument: the operator 
is evaluated once with each element of &lt;object&gt; as its single argument, 
<P>
<P>
or an algebraic expression with exactly one 
<a href=r38_0050.html#r38_0061>free variable</a>, that is 
a variable preceded by the tilde symbol: the expression 
 is evaluated for each element of &lt;object&gt; where the element is 
 substituted for the free variable, 
<P>
<P>
or a replacement 
<a href=r38_0050.html#r38_0060>rule</a> of the form 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>var</em>=&gt; <em>rep</em> 
<P>
<P>
<P>
where &lt;var&gt; is a variable (a &lt;kernel&gt; without subscript) 
 and &lt;rep&gt; is an expression which contains &lt;var&gt;. 
 Here <em>rep</em> is evaluated for each element of &lt;object&gt; where 
 the element is substituted for <em>var</em>. <em>var</em> may be 
 optionally preceded by a tilde. 
<P>
<P>
The rule form for &lt;function&gt; is needed when more than 
one free variable occurs. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
map(abs,{1,-2,a,-a}); 

  1,2,abs(a),abs(a) 


map(int(~w,x), mat((x^2,x^5),(x^4,x^5))); 


          [  3     6 ]
          [ x     x  ]
          [----  ----]
          [ 3     6  ]
          [          ]
          [  5     6 ]
          [ x     x  ]
          [----  ----]
  	[ 5     6  ]


map(~w*6, x^2/3 = y^3/2 -1); 

     2     3
  2*x =3*(y -2)

</tt></pre><p>You can use <em>map</em> in nested expressions. It is not allowed 
to 
apply <em>map</em> for a non-composed object, e.g. an identifier or a number. 
<P>
<P>
<P>

<a name=r38_0164>

<title>MKID</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MKID</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
 <P>
<P>
The <em>mkid</em> command constructs an identifier, given a stem and an identifi
er 
or an integer. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>mkid</em>(&lt;stem&gt;,&lt;leaf&gt;) 
<P>
<P>
<P>
&lt;stem&gt; can be any valid REDUCE identifier that does not include escaped 
special characters. &lt;leaf&gt; may be an integer, including one given by a 
local variable in a 
<a href=r38_0001.html#r38_0047>for</a> loop, or any other legal group of 
characters. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
mkid(x,3); 

  X3 


factorize(x^15 - 1); 

  {X - 1,
    2
   X  + X + 1,
    4    3    2
   X  + X  + X  + X + 1,
    8    7    5    4    3
   X  - X  + X  - X  + X   - X + 1}



for i := 1:length ws do write set(mkid(f,i),part(ws,i));
	 


   8    7    5    4    3
  X  - X  + X  - X  + X  - X + 1
   4    3    2
  X  + X  + X  + X + 1
   2
  X  + X + 1
  X - 1

</tt></pre><p>You can use <em>mkid</em> to construct identifiers from inside pro
cedures. This 
allows you to handle an unknown number of factors, or deal with variable 
amounts of data. It is particularly helpful to attach identifiers to the 
answers returned by <em>factorize</em> and <em>solve</em>. 
<P>
<P>
<P>

<a name=r38_0165>

<title>NPRIMITIVE</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NPRIMITIVE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>nprimitive</em>(&lt;expression&gt;) or <em>nprimitive</em> 
 &lt;simple\_expression&gt; 
<P>
<P>
<P>
This operator returns the numerically-primitive part of any scalar 
expression. In other words, any overall integer factors in the expression 
are removed. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
nprimitive((2x+2y)^2); 

   2            2
  X  + 2*X*Y + Y  


nprimitive(3*a*b*c); 

  3*A*B*C

</tt></pre><p>
<a name=r38_0166>

<title>NUM</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUM</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>num</em> operator returns the numerator of its argument. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>num</em>(&lt;expression&gt;) or <em>num</em> &lt;simple\_expression&gt; 
<P>
<P>
<P>
&lt;expression&gt; can be any valid REDUCE scalar expression. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
num(100/6); 

  50 


num(a/5 + b/6); 

  6*A + 5*B 


num(sin(x)); 

  SIN(X)

</tt></pre><p><em>num</em>returns the numerator of the expression after it has b
een simplified 
by REDUCE. As seen in the examples, this includes putting sums of rational 
expressions over a common denominator, and reducing common factors where 
possible. If the expression is not a rational expression, it is returned 
unchanged. 
<P>
<P>
<P>

<a name=r38_0167>

<title>ODESOLVE</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ODESOLVE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>odesolve</em> package is a solver for ordinary differential 
equations. At the present time it has still limited capabilities: 
<P>
<P>
1. it can handle only a single scalar equation presented as an 
 algebraic expression or equation, and 
<P>
<P>
2. it can solve only first-order equations of simple types, linear 
 equations with constant coefficients and Euler equations. 
<P>
<P>
These solvable types are exactly those for which Lie symmetry 
techniques give no useful information. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>odesolve</em>(&lt;expr&gt;,&lt;var1&gt;,&lt;var2&gt;) 
<P>
<P>
<P>
<P>
&lt;expr&gt; is a single scalar expression such that &lt;expr&gt;=0 
is the ordinary differential equation (ODE for short) to be solved, or 
is an equivalent 
<a href=r38_0001.html#r38_0045>equation</a>. 
<P>
<P>
&lt;var1&gt; is the name of the dependent variable, 
&lt;var2&gt; is the name of the independent variable. 
<P>
<P>
A differential in &lt;expr&gt; is expressed using the 
<a href=r38_0100.html#r38_0148>df</a> 
operator. Note that in most cases you must declare explicitly 
&lt;var1&gt; to depend of &lt;var2&gt; using a 
<a href=r38_0150.html#r38_0192>depend</a> 
declaration -- otherwise the derivative might be evaluated to 
zero on input to <em>odesolve</em>. 
<P>
<P>
The returned value is a list containing the equation giving the general 
solution of the ODE (for simultaneous equations this will be a 
list of equations eventually). It will contain occurrences of 
the operator <em>arbconst</em> for the arbitrary constants in the general 
solution. The arguments of <em>arbconst</em> should be new. 
A counter <em>!!arbconst</em> is used to arrange this. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
depend y,x;

% A first-order linear equation, with an initial condition

ode:=df(y,x) + y * sin x/cos x - 1/cos x$

odesolve(ode,y,x); 

  {y=arbconst(1)*cos(x) + sin(x)}

</tt></pre><p>
<a name=r38_0168>

<title>ONE_OF</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ONE\_OF</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>type</b><P>
<P>
 
The operator <em>one_of</em> is used to represent an indefinite choice 
of one element from a finite set of objects. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>
x=one_of{1,2,5}
</tt></pre><p>this equation encodes that x can take one of the values 
1,2 or 5<p><pre><tt>
</tt></pre><p> 
REDUCE generates a <em>one_of</em> form in cases when an implicit 
<em>root_of</em> expression could be converted to an explicit solution set. 
A <em>one_of</em> form can be converted to a <em>solve</em> solution using 

<a href=r38_0100.html#r38_0149>expand_cases</a>. See 
<a href=r38_0150.html#r38_0176>root_of</a>. 
<P>
<P>

<a name=r38_0169>

<title>PART</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>PART</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>part</em> permits the extraction of various parts or 
operators of expressions and 
<a href=r38_0050.html#r38_0053>list</a><em>s</em>. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>part</em>(&lt;expression,integer&gt;{,&lt;integer&gt;}*) 
<P>
<P>
<P>
&lt;expression&gt; can be any valid REDUCE expression or a list, 
integer may be an expression that evaluates to a positive or negative 
integer or 0. A positive integer &lt;n&gt; picks up the n th term, 
counting from the first term toward the end. A negative integer n 
picks up the n th term, counting from the back toward the front. The 
integer 0 picks up the operator (which is <em>LIST</em> when the expression 
is a 
<a href=r38_0050.html#r38_0053>list</a>). 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
part((x + y)**5,4); 

      2  3
  10*X *Y  


part((x + y)**5,4,2); 

   2
  X  


part((x + y)**5,4,2,1); 

  X 


part((x + y)**5,0); 

  PLUS 


part((x + y)**5,-5); 

        4
  5*X *Y  


part((x + y)**5,4) := sin(x); 

   5      4         3  2                 4    5
  X  + 5*X *Y + 10*X *Y  + SIN(X) + 5*X*Y  + Y  


alist := {x,y,{aa,bb,cc},x**2*sqrt(y)}; 


                                        2
  			 ALIST := {X,Y,{AA,BB,CC},SQRT(Y)*X } 


part(alist,3,2); 

  BB 


part(alist,4,0); 

  TIMES

</tt></pre><p>Additional integer arguments after the first one examine the 
terms recursively, as shown above. In the third line, the fourth term 
is picked from the original polynomial, 10x^2y^3, 
then the second term from that, x^2, and finally the first 
component, x. If an integer's absolute value is too large for 
the appropriate expression, a message is given. 
<P>
<P>
<em>part</em>works on the form of the expression as printed, or as it would 
have been printed at that point of the calculation, bearing in mind the 
current switch settings. It is important to realize that the switch settings 
change the operation of <em>part</em>. 
<a href=r38_0300.html#r38_0319>pri</a> must be on when 
<em>part</em> is used. 
<P>
<P>
When <em>part</em> is used on a polynomial expression that has minus signs, the 

<em>+</em> is always returned as the top-level operator. The minus is found 
as a unary operator attached to the negative term. 
<P>
<P>
<em>part</em>can also be used to change the relevant part of the expression or 
list as shown in the sixth example line. The <em>part</em> operator returns the 

changed expression, though original expression is not changed. You can 
also use <em>part</em> to change the operator. 
<P>
<P>
<P>

<a name=r38_0170>

<title>PF</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>PF</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
pf(&lt;expression&gt;,&lt;variable&gt;) 
<P>
<P>
<P>
<em>pf</em>transforms &lt;expression&gt; into a 
<a href=r38_0050.html#r38_0053>list</a> of partial fraction 
s 
with respect to the main variable, &lt;variable&gt;. <em>pf</em> does a 
complete partial fraction decomposition, and as the algorithms used are 
fairly unsophisticated (factorization and the extended Euclidean 
algorithm), the code may be unacceptably slow in complicated cases. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>
pf(2/((x+1)^2*(x+2)),x); 

      2    -2        2
  	{-----,-----,------------} 
    X + 2 X + 1  2
                X  + 2*X + 1


off exp; 

pf(2/((x+1)^2*(x+2)),x);
 

     2    - 2     2
  {-----,-----,--------} 
   X + 2 X + 1        2
               (X + 1)


for each j in ws sum j; 

         2
  ----------------
                2
  ( + 2)*(X + 1)

</tt></pre><p><P>
<P>
If you want the denominators in factored form, turn 
<a href=r38_0250.html#r38_0284>exp</a> off, as 
shown in the second example above. As shown in the final example, the 

<a href=r38_0001.html#r38_0047>for</a> <em>each</em> construct can be used to re
combine the terms. 
Alternatively, one can use the operations on lists to extract any desired 
term. 
<P>
<P>
<P>

<a name=r38_0171>

<title>PROD</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>PROD</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>prod</em> returns 
the indefinite or definite product of a given expression. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>prod</em>(&lt;expr&gt;,&lt;k&gt;[,&lt;lolim&gt; [,&lt;uplim&gt; ]]) 
<P>
<P>
<P>
<P>
where &lt;expr&gt; is the expression to be multiplied, &lt;k&gt; is the 
control variable (a 
<a href=r38_0001.html#r38_0002>kernel</a>), and &lt;lolim&gt; and &lt;uplim&gt; 

uplim are the optional lower and upper limits. If &lt;uplim&gt; is 
not supplied the upper limit is taken as &lt;k&gt;. The 
Gosper algorithm is used. If there is no closed form solution, 
the operator returns the input unchanged. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
prod(k/(k-2),k);

  k*( - k + 1)

</tt></pre><p>
<a name=r38_0172>

<title>REDUCT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>REDUCT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>reduct</em> operator returns the remainder of its expression after the 
leading term with respect to the kernel in the second argument is removed. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>reduct</em>(&lt;expression&gt;,&lt;kernel&gt;) 
<P>
<P>
<P>
&lt;expression&gt; is ordinarily a polynomial. If 
<a href=r38_0300.html#r38_0322>ratarg</a> is on, 
a rational expression may also be used, otherwise an error results. 
&lt;kernel&gt; must be a 
<a href=r38_0001.html#r38_0002>kernel</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
reduct((x+y)**3,x); 

        2            2
  Y*(3*X  + 3*X*Y + Y ) 


reduct(x + sin(x)**3,sin(x)); 

  X 


reduct(x + sin(x)**3,y); 

  0

</tt></pre><p>If the expression does not contain the kernel, <em>reduct</em> ret
urns 0. 
<P>
<P>
<P>

<a name=r38_0173>

<title>REPART</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>REPART</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>repart</em>(&lt;expression&gt;) or <em>repart</em> &lt;simple\_expression
&gt; 
<P>
<P>
<P>
This operator returns the real part of an expression, if that argument has an 
numerical value. A non-numerical argument is returned as an expression in 
the operators <em>repart</em> and 
<a href=r38_0150.html#r38_0153>impart</a>. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>
repart(1+i); 

  1 


repart(a+i*b); 

  REPART(A) - IMPART(B)

</tt></pre><p><P>
<P>

<a name=r38_0174>

<title>RESULTANT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>RESULTANT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>resultant</em> operator computes the resultant of two polynomials with 
respect to a given variable. If the resultant is 0, the polynomials have 
a root in common. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>resultant</em>(&lt;expression&gt;,&lt;expression&gt;,&lt;kernel&gt;) 
<P>
<P>
<P>
&lt;expression&gt; must be a polynomial containing &lt;kernel&gt; ; 
&lt;kernel&gt; must be a 
<a href=r38_0001.html#r38_0002>kernel</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
resultant(x**2 + 2*x + 1,x+1,x); 

  0 


resultant(x**2 + 2*x + 1,x-3,x); 

  16 


resultant(z**3 + z**2 + 5*z + 5,
          z**4 - 6*z**3 + 16*z**2 - 30*z + 55,
          z);
 

  0 


resultant(x**3*y + 4*x*y + 10,y**2 + 6*y + 4,y); 


   6       5        4        3        2
  Y  + 18*Y  + 120*Y  + 360*Y  + 480*Y  + 288*Y + 64

</tt></pre><p>The resultant is the determinant of the Sylvester matrix, formed f
rom the 
coefficients of the two polynomials in the following way: 
<P>
<P>
Given two polynomials: 
<P>
<P>
<p><pre><tt>
    n       n-1 
 a x  + a1 x     + ... + an

</tt></pre><p>and 
<P>
<P>
<p><pre><tt>
    m       m-1 
 b x  + b1 x     + ... + bm

</tt></pre><p>form the (m+n)x(m+n-1) Sylvester matrix by the following means: 
<P>
<P>
<p><pre><tt>
   0.......0 a  a1 .......... an
   0....0 a  a1 .......... an  0
       .    .   .   .  
   a0 a1 .......... an 0.......0
   0.......0 b  b1 .......... bm
   0....0 b  b1 .......... bm  0
       .    .   .   .  
   b  b1 .......... bm 0.......0  

</tt></pre><p>If the determinant of this matrix is 0, the two polynomials have a
 common 
root. Finding the resultant of large expressions is time-consuming, due 
to the time needed to find a large determinant. 
<P>
<P>
The sign conventions <em>resultant</em> uses are those given in the article, 
``Computing in Algebraic Extensions,'' by R. Loos, appearing in 
&lt;Computer Algebra--Symbolic and Algebraic Computation&gt;, 2nd ed., 
edited by B. Buchberger, G.E. Collins and R. Loos, and published by 
Springer-Verlag, 1983. 
These are: 
<P>
<P>
<p><pre><tt>
  resultant(p(x),q(x),x) = (-1)^{deg p(x)*deg q(x)} * resultant(q(x),p(x),x),
  resultant(a,p(x),x)    = a^{deg p(x)},
  resultant(a,b,x)       = 1
</tt></pre><p>where p(x) and q(x) are polynomials which have x as a variable, an
d 
a and b are free of x. 
<P>
<P>
Error messages are given if <em>resultant</em> is given a non-polynomial 
expression, or a non-kernel variable. 
<P>
<P>
<P>

<a name=r38_0175>

<title>RHS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>RHS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>rhs</em> operator returns the right-hand side of an 
<a href=r38_0001.html#r38_0045>equation</a>, 
such as those returned in a 
<a href=r38_0050.html#r38_0053>list</a> by 
<a href=r38_0150.html#r38_0179>solve</a>. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>rhs</em>(&lt;equation&gt;) or <em>rhs</em> &lt;equation&gt; 
<P>
<P>
<P>
&lt;equation&gt; must be an equation of the form left-hand side = right-hand 
side. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
roots := solve(x**2 + 6*x*y + 5x + 3y**2,x); 


                              2
                     SQRT(24*Y  + 60*Y + 25) + 6*Y + 5
      ROOTS := {X= - ---------------------------------,
                                     2
                             2
                    SQRT(24*Y  + 60*Y + 25) - 6*Y - 5
                 X= ---------------------------------}
                                    2


root1 := rhs first roots; 

                      2
             SQRT(24*Y  + 60*Y + 25) + 6*Y + 5
  ROOT1 := - --------------------------------- 
                             2


root2 := rhs second roots; 

                    2
           SQRT(24*Y  + 60*Y + 25) - 6*Y - 5
  ROOT2 := ----------------------------------
                           2

</tt></pre><p>An error message is given if <em>rhs</em> is applied to something 
other than an 
equation. 
<P>
<P>
<P>

<a name=r38_0176>

<title>ROOT_OF</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ROOT\_OF</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
When the operator 
<a href=r38_0150.html#r38_0179>solve</a> is unable to find an explicit solution 

or if that solution would be too complicated, the result is presented 
as formal root expression using the internal operator <em>root_of</em> 
and a new local variable. An expression with a top level <em>root_of</em> 
is implicitly a list with an unknown number of elements since we 
can't always know how many solutions an equation has. If a 
substitution is made into such an expression, closed form solutions 
can emerge. If this occurs, the <em>root_of</em> construct is 
replaced by an operator 
<a href=r38_0150.html#r38_0168>one_of</a>. At this point it is 
of course possible to transform the result if the original <em>solve</em> 
operator expression into a standard <em>solve</em> solution. To 
effect this, the operator 
<a href=r38_0100.html#r38_0149>expand_cases</a> can be used. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
solve(a*x^7-x^2+1,x);

                 7     2
  {x=root_of(a*x_  - x_  + 1,x_)}


sub(a=0,ws);

  {x=one_of(1,-1)}


expand_cases ws;

  x=1,x=-1

</tt></pre><p>The components of <em>root_of</em> and <em>one_of</em> expressions
 can be 
processed as usual with operators 
<a href=r38_0100.html#r38_0140>arglength</a> and 
<a href=r38_0150.html#r38_0169>part</a>. 
A higher power of a <em>root_of</em> expression with a polynomial 
as first argument is simplified by using the polynomial as a side relation. 
<P>
<P>

<a name=r38_0177>

<title>SELECT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SELECT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>select</em> operator extracts from a list 
or from the arguments of an n--ary operator elements corresponding 
to a boolean predicate. The predicate pattern can be a 
unary procedure, an operator or an algebraic expression with 
one 
<a href=r38_0050.html#r38_0061>free variable</a>. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>select</em>(&lt;function&gt;,&lt;object&gt;) 
<P>
<P>
<P>
&lt;object&gt; is a 
<a href=r38_0050.html#r38_0053>list</a>. 
<P>
<P>
&lt;function&gt; is 
the name of an operator for a single argument: the operator 
 is evaluated once with each element of &lt;object&gt; as its single argument, 
<P>
<P>
or an algebraic expression with exactly one 
<a href=r38_0050.html#r38_0061>free variable</a>, that is 
a variable preceded by the tilde symbol: the expression 
 is evaluated for each element of &lt;object&gt; where the element is 
 substituted for the free variable, 
<P>
<P>
or a replacement 
<a href=r38_0050.html#r38_0060>rule</a> of the form 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>var</em>=&gt; <em>rep</em> 
<P>
<P>
<P>
where &lt;var&gt; is a variable (a &lt;kernel&gt; without subscript) 
 and &lt;rep&gt; is an expression which contains &lt;var&gt;. 
 Here <em>rep</em> is evaluated for each element of &lt;object&gt; where 
 the element is substituted for <em>var</em>. <em>var</em> may be 
 optionally preceded by a tilde. 
<P>
<P>
The rule form for &lt;function&gt; is needed when more than 
one free variable occurs. The evaluation result of &lt;function&gt; is 
interpreted as 
<a href=r38_0100.html#r38_0109>boolean value</a> corresponding to the convention
s of 
REDUCE. The result value is built with the leading operator of the 
input expression. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>
  select( ~w&gt;0 , {1,-1,2,-3,3}) 

  {1,2,3} 


  q:=(part((x+y)^5,0):=list)

  select(evenp deg(~w,y),q);

    5      3   2       4
  {x  ,10*x  *y  ,5*x*y  }


  select(evenp deg(~w,x),2x^2+3x^3+4x^4);


    2   4
  2x +4x

</tt></pre><p><P>
<P>

<a name=r38_0178>

<title>SHOWRULES</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SHOWRULES</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>showrules</em>(&lt;expression&gt;) or 
 <em>showrules</em> &lt;simple\_expression&gt; 
<P>
<P>
<P>
<em>showrules</em>returns in 
<a href=r38_0050.html#r38_0060>rule</a><em>-list</em> form any 

<a href=r38_0200.html#r38_0211>operator</a> rules associated with its argument. 

<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
showrules log; 

  {LOG(E) =&gt; 1,
   LOG(1) =&gt; 0,
        ~X
   LOG(E   ) =&gt; ~X,
                     1
   DF(LOG(~X),~X) =&gt; --}
                     ~X

</tt></pre><p>Such rules can then be manipulated further as with any 
<a href=r38_0050.html#r38_0053>list</a>. For 
example 
<em>rhs first ws;</em> has the value 1. 
<P>
<P>
An operator may have properties that cannot be displayed in such a form, 
such as the fact it is an 
<a href=r38_0200.html#r38_0208>odd</a> function, or has a definition defined 
as a procedure. 
<P>
<P>
<P>

<a name=r38_0179>

<title>SOLVE</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SOLVE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>solve</em> operator solves a single algebraic 
<a href=r38_0001.html#r38_0045>equation</a> or a 
system of simultaneous equations. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>solve</em>(&lt;expression&gt; [ , &lt;kernel&gt;]) or 
<P>
<P>
<em>solve</em>({&lt;expression&gt;,...} [ ,{ &lt;kernel&gt; ,...}] ) 
<P>
<P>
 <P>
<P>
If the number of equations equals the number of distinct kernels, the 
optional kernel argument(s) may be omitted. &lt;expression&gt; is either a 
scalar expression or an 
<a href=r38_0001.html#r38_0045>equation</a>. 
When more than one expression is given, 
the 
<a href=r38_0050.html#r38_0053>list</a> of expressions is surrounded by curly br
aces. 
The optional list 
of 
<a href=r38_0001.html#r38_0002>kernel</a>s follows, also in curly braces. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
sss := solve(x^2 + 7); 

  Unknown: X
  SSS := {X= - SQRT(7)*I,
          X=SQRT(7)*I}


rhs first sss; 

  - SQRT(7)*I 


solve(sin(x^2*y),y); 

     2*ARBINT(1)*PI
  {Y=---------------
            2
           X
     PI*(2*ARBINT(1) + 1)
   Y=--------------------}
               2
              X


off allbranch; 

solve(sin(x**2*y),y); 

  {Y=0} 


solve({3x + 5y = -4,2*x + y = -10},{x,y});
 


         22   46
  {{X= - --,Y=--}} 
         7    7


solve({x + a*y + z,2x + 5},{x,y});
 


         5      2*Z - 5
  {{X= - -,Y= - -------}} 
         2        2*A


ab := (x+2)^2*(x^6 + 17x + 1);
 

         8      7      6       3       2
  AB := X  + 4*X  + 4*X  + 17*X  + 69*X  + 72*X + 4 


www := solve(ab,x); 

  {X=ROOT F(X6 + 17*X + 1),X=-2} 
         O            


root_multiplicities; 

  {1,2}

</tt></pre><p>Results of the <em>solve</em> operator are returned as 
<a href=r38_0001.html#r38_0045>equation</a><em>s</em> 
in a 
<a href=r38_0050.html#r38_0053>list</a>. 
You can use the usual list access methods (
<a href=r38_0001.html#r38_0046>first</a>, 

<a href=r38_0050.html#r38_0063>second</a>, 
<a href=r38_0050.html#r38_0066>third</a>, 
<a href=r38_0050.html#r38_0057>rest</a> and 
<a href=r38_0150.html#r38_0169>part</a>) to 
extract the desired equation, and then use the operators 
<a href=r38_0150.html#r38_0175>rhs</a> and 

<a href=r38_0150.html#r38_0158>lhs</a> to access the right-hand or left-hand exp
ression of the 
equation. When <em>solve</em> is unable to solve an equation, it returns the 
unsolved part as the argument of <em>root_of</em>, with the variable renamed 
to avoid confusion, as shown in the last example above. 
<P>
<P>
For one equation, <em>solve</em> uses square-free factorization, roots of 
unity, and the known inverses of the 
<a href=r38_0050.html#r38_0088>log</a>, 
<a href=r38_0250.html#r38_0259>sin</a>, 

<a href=r38_0200.html#r38_0249>cos</a>, 
<a href=r38_0200.html#r38_0236>acos</a>, 
<a href=r38_0200.html#r38_0244>asin</a>, and 
exponentiation operators. The quadratic, cubic and quartic formulas are 
used if necessary, but these are applied only when the switch 

<a href=r38_0250.html#r38_0292>fullroots</a> is set on; otherwise or when no clo
sed form is available 
the result is returned as 

<a href=r38_0150.html#r38_0176>root_of</a> expression. The switch 
<a href=r38_0300.html#r38_0336>trigform</a> 
determines which type of cubic and quartic formula is used. 
The multiplicity of each solution is given in a list as 
the system variable 
<a href=r38_0001.html#r38_0017>root_multiplicities</a>. For systems of 
simultaneous linear equations, matrix inversion is used. For nonlinear 
systems, the Groebner basis method is used. 
<P>
<P>
Linear equation system solving is influenced by the switch 
<a href=r38_0250.html#r38_0276>cramer</a>. 
<P>
<P>
Singular systems can be solved when the switch 
<a href=r38_0300.html#r38_0332>solvesingular</a> is 
on, which is the default setting. An empty list is returned the system of 
equations is inconsistent. For a linear inconsistent system with parameters 
the variable 
<a href=r38_0001.html#r38_0016>requirements</a> constraints 
conditions for the system to become consistent. 
<P>
<P>
For a solvable linear and polynomial system with parameters 
the variable 
<a href=r38_0001.html#r38_0005>assumptions</a> 
contains a list side relations for the parameters: the solution is 
valid only as long as none of these expressions is zero. 
<P>
<P>
If the switch 
<a href=r38_0300.html#r38_0339>varopt</a> is on (default), the system rearranges
 the 
variable sequence for minimal computation time. Without <em>varopt</em> 
the user supplied variable sequence is maintained. 
<P>
<P>
If the solution has free variables (dimension of the solution is greater 
than zero), these are represented by 
<a href=r38_0100.html#r38_0139>arbcomplex</a> expressions 
as long as the switch 
<a href=r38_0250.html#r38_0268>arbvars</a> is on (default). Without 
<em>arbvars</em> no explicit equations are generated for free variables. 
<P>
<P>
<P>
 <P> <H3> 
related: </H3>
<P>
 _ _ _ 
<a href=r38_0250.html#r38_0266>allbranch</a>switch 
<P>
 _ _ _ 
<a href=r38_0250.html#r38_0268>arbvars</a> switch 
<P>
 _ _ _ 
<a href=r38_0001.html#r38_0005>assumptions</a> variable 
<P>
 _ _ _ 
<a href=r38_0250.html#r38_0292>fullroots</a> switch 
<P>
 _ _ _ 
<a href=r38_0001.html#r38_0016>requirements</a> variable 
<P>
 _ _ _ 
<a href=r38_0400.html#r38_0439>roots</a> operator 
<P>
 _ _ _ 
<a href=r38_0150.html#r38_0176>root_of</a> operator 
<P>
 _ _ _ 
<a href=r38_0300.html#r38_0336>trigform</a> switch 
<P>
 _ _ _ 
<a href=r38_0300.html#r38_0339>varopt</a> switch 
<P>
<P>
<P>

<a name=r38_0180>

<title>SORT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SORT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>sort</em> operator sorts the elements of a list according to 
an arbitrary comparison operator. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>sort</em>(&lt;lst&gt;,&lt;comp&gt;) 
<P>
<P>
<P>
&lt;lst&gt; is a 
<a href=r38_0050.html#r38_0053>list</a> of algebraic expressions. 
&lt;comp&gt; is a comparison operator which defines a partial 
ordering among the members of &lt;lst&gt;. &lt;comp&gt; may be 
one of the builtin comparison operators like 
<em>&lt;</em>(
<a href=r38_0100.html#r38_0115>lessp</a>), <em>&lt;=</em>(
<a href=r38_0100.html#r38_0114>leq</a>) 
etc., or &lt;comp&gt; may be the name of a comparison procedure. 
Such a procedure has two arguments, and it returns 

<a href=r38_0100.html#r38_0122>true</a> if the first argument 
ranges before the second one, and 0 or 
<a href=r38_0001.html#r38_0014>nil</a> otherwise. 
The result of <em>sort</em> is a new list which contains the 
elements of &lt;lst&gt; in a sequence corresponding to &lt;comp&gt;. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>
 procedure ce(a,b);

   if evenp a and not evenp b then 1 else 0;

for i:=1:10 collect random(50)$

sort(ws,&gt;=); 

  {41,38,33,30,28,25,20,17,8,5}


sort(ws,&lt;); 

  {5,8,17,20,25,28,30,33,38,41}


sort(ws,ce); 

  {8,20,28,30,38,5,17,25,33,41}


  procedure cd(a,b);

  if deg(a,x)&gt;deg(b,x) then 1 else

  if deg(a,x)&lt;deg(b,x) then 0 else

  if deg(a,y)&gt;deg(b,y) then 1 else 0;

sort({x^2,y^2,x*y},cd);

    2      2
  {x ,x*y,y }

</tt></pre><p><P>
<P>

<a name=r38_0181>

<title>STRUCTR</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>STRUCTR</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>structr</em> operator breaks its argument expression into named 
subexpressions. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>structr</em>(&lt;expression&gt; [,&lt;identifier&gt;[,&lt;identifier&gt; ...
]]) 
<P>
<P>
<P>
&lt;expression&gt; may be any valid REDUCE scalar expression. 
&lt;identifier&gt; may be any valid REDUCE <em>identifier</em>. The first 
identifier 
is the stem for subexpression names, the second is the name to be assigned 
to the structured expression. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
structr(sqrt(x**2 + 2*x) + sin(x**2*z)); 


  ANS1 + ANS2
      where
                       2
          ANS2 := SIN(X *Z)
                             1/2
          ANS1 := ((X + 2)*X)


ans3; 

  ANS3 


on fort; 

structr((x+1)**5 + tan(x*y*z),var,aa); 


  VAR1=TAN(X*Y*Z)
  AA=VAR1+X**5+5.*X**4+10.*X**3+10.X**2+5.*X+1

</tt></pre><p>The second argument to <em>structr</em> is optional. If it is not 
given, the 
default stem <em>ANS</em> is used by REDUCE to construct names for the 
subexpression. The names are only for display purposes: REDUCE does not 
store the names and their values unless the switch 
<a href=r38_0300.html#r38_0331>savestructr</a> is 
on. 
<P>
<P>
If a third argument is given, the structured expression as a whole is named by 
this argument, when 
<a href=r38_0250.html#r38_0289>fort</a> is on. The expression is not stored 
under this 
name. You can send these structured Fortran expressions to a file with the 
<em>out</em> command. 
<P>
<P>
<P>

<a name=r38_0182>

<title>SUB</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SUB</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>sub</em> operator substitutes a new expression for a kernel in an 
expression. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>sub</em>(&lt;kernel&gt;<em>=</em>&lt;expression&gt; 
	 {,&lt;kernel&gt;<em>=</em>&lt;expression&gt;}*, 
	 &lt;expression&gt;) or 
<P>
<P>
<em>sub</em>({&lt;kernel&gt;<em>=</em>&lt;expression&gt;*, 
	 &lt;kernel&gt;<em>=</em><em>expression</em>},&lt;expression&gt;) 
<P>
<P>
<P>
&lt;kernel&gt; must be a 
<a href=r38_0001.html#r38_0002>kernel</a>, &lt;expression&gt; can be any REDUCE 

scalar expression. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
sub(x=3,y=4,(x+y)**3); 

  343 


x; 

  X 


sub({cos=sin,sin=cos},cos a+sin b) 


  COS(B) + SIN(A)

</tt></pre><p>Note in the second example that operators can be replaced using th
e 
<em>sub</em> operator. 
<P>
<P>
<P>

<a name=r38_0183>

<title>SUM</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SUM</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>sum</em> returns 
the indefinite or definite summation of a given expression. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>sum</em>(&lt;expr&gt;,&lt;k&gt;[,&lt;lolim&gt; [,&lt;uplim&gt; ]]) 
<P>
<P>
<P>
<P>
where &lt;expr&gt; is the expression to be added, &lt;k&gt; is the 
control variable (a 
<a href=r38_0001.html#r38_0002>kernel</a>), and &lt;lolim&gt; and &lt;uplim&gt; 

are the optional lower and upper limits. If &lt;uplim&gt; is 
not supplied the upper limit is taken as &lt;k&gt;. The Gosper 
algorithm is used. If there is no closed form solution, the operator 
returns the input unchanged. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
sum(4n**3,n); 

   2    2
  n  *(n   + 2*n + 1)


sum(2a+2k*r,k,0,n-1);

  n*(2*a + n*r - r)

</tt></pre><p>
<a name=r38_0184>

<title>WS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>WS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>ws</em> operator alone returns the last result; <em>ws</em> with a 
number argument returns the results of the REDUCE statement executed after 
that numbered prompt. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>ws</em>or <em>ws</em>(&lt;number&gt;) 
<P>
<P>
<P>
&lt;number&gt; must be an integer between 1 and the current REDUCE prompt number
. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt></tt></pre><p>(In the following examples, unlike most others, the nu
mbered 
prompt is shown.)<p><pre><tt> 

1: df(sin y,y); 

  COS(Y) 


2: ws^2; 

        2
  COS(Y)  


3: df(ws 1,y); 

  -SIN(Y)

</tt></pre><p> 
<P>
<P>
<em>ws</em>and <em>ws</em><em>(</em>&lt;number&gt;<em>)</em> can be used anywher
e the 
expression they stand for can be used. Calling a number for which no 
result was produced, such as a switch setting, will give an error message. 
<P>
<P>
The current workspace always contains the results of the last REDUCE 
command that produced an expression, even if several input statements 
that do not produce expressions have intervened. For example, if you do 
a differentiation, producing a result expression, then change several 
switches, the operator <em>ws;</em> returns the results of the differentiation. 

The current workspace (<em>ws</em>) can also be used inside files, though the 
numbered workspace contains only the <em>in</em> command that input the file. 
<P>
<P>
There are three history lists kept in your REDUCE session. The first 
stores raw input, suitable for the statement editor. The second stores 
parsed input, ready to execute and accessible by 
<a href=r38_0200.html#r38_0232>input</a>. The 
third stores results, when they are produced by statements, which are 
accessible by the <em>ws</em>&lt; n&gt; operator. If your session is very 
long, storage space begins to fill up with these expressions, so it is a 
good idea to end the session once in a while, saving needed expressions to 
files with the 
<a href=r38_0100.html#r38_0133>saveas</a> and 
<a href=r38_0200.html#r38_0233>out</a> commands. 
<P>
<P>
An error message is given if a reference number has not yet been used. 
<P>
<P>
<P>

<a name=r38_0185>

<title>Algebraic Operators</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Algebraic Operators</b><menu>
<li><a href=r38_0100.html#r38_0137>APPEND operator</a><P>
<li><a href=r38_0100.html#r38_0138>ARBINT operator</a><P>
<li><a href=r38_0100.html#r38_0139>ARBCOMPLEX operator</a><P>
<li><a href=r38_0100.html#r38_0140>ARGLENGTH operator</a><P>
<li><a href=r38_0100.html#r38_0141>COEFF operator</a><P>
<li><a href=r38_0100.html#r38_0142>COEFFN operator</a><P>
<li><a href=r38_0100.html#r38_0143>CONJ operator</a><P>
<li><a href=r38_0100.html#r38_0144>CONTINUED_FRACTION operator</a><P>
<li><a href=r38_0100.html#r38_0145>DECOMPOSE operator</a><P>
<li><a href=r38_0100.html#r38_0146>DEG operator</a><P>
<li><a href=r38_0100.html#r38_0147>DEN operator</a><P>
<li><a href=r38_0100.html#r38_0148>DF operator</a><P>
<li><a href=r38_0100.html#r38_0149>EXPAND\_CASES operator</a><P>
<li><a href=r38_0150.html#r38_0150>EXPREAD operator</a><P>
<li><a href=r38_0150.html#r38_0151>FACTORIZE operator</a><P>
<li><a href=r38_0150.html#r38_0152>HYPOT operator</a><P>
<li><a href=r38_0150.html#r38_0153>IMPART operator</a><P>
<li><a href=r38_0150.html#r38_0154>INT operator</a><P>
<li><a href=r38_0150.html#r38_0155>INTERPOL operator</a><P>
<li><a href=r38_0150.html#r38_0156>LCOF operator</a><P>
<li><a href=r38_0150.html#r38_0157>LENGTH operator</a><P>
<li><a href=r38_0150.html#r38_0158>LHS operator</a><P>
<li><a href=r38_0150.html#r38_0159>LIMIT operator</a><P>
<li><a href=r38_0150.html#r38_0160>LPOWER operator</a><P>
<li><a href=r38_0150.html#r38_0161>LTERM operator</a><P>
<li><a href=r38_0150.html#r38_0162>MAINVAR operator</a><P>
<li><a href=r38_0150.html#r38_0163>MAP operator</a><P>
<li><a href=r38_0150.html#r38_0164>MKID command</a><P>
<li><a href=r38_0150.html#r38_0165>NPRIMITIVE operator</a><P>
<li><a href=r38_0150.html#r38_0166>NUM operator</a><P>
<li><a href=r38_0150.html#r38_0167>ODESOLVE operator</a><P>
<li><a href=r38_0150.html#r38_0168>ONE\_OF type</a><P>
<li><a href=r38_0150.html#r38_0169>PART operator</a><P>
<li><a href=r38_0150.html#r38_0170>PF operator</a><P>
<li><a href=r38_0150.html#r38_0171>PROD operator</a><P>
<li><a href=r38_0150.html#r38_0172>REDUCT operator</a><P>
<li><a href=r38_0150.html#r38_0173>REPART operator</a><P>
<li><a href=r38_0150.html#r38_0174>RESULTANT operator</a><P>
<li><a href=r38_0150.html#r38_0175>RHS operator</a><P>
<li><a href=r38_0150.html#r38_0176>ROOT\_OF operator</a><P>
<li><a href=r38_0150.html#r38_0177>SELECT operator</a><P>
<li><a href=r38_0150.html#r38_0178>SHOWRULES operator</a><P>
<li><a href=r38_0150.html#r38_0179>SOLVE operator</a><P>
<li><a href=r38_0150.html#r38_0180>SORT operator</a><P>
<li><a href=r38_0150.html#r38_0181>STRUCTR operator</a><P>
<li><a href=r38_0150.html#r38_0182>SUB operator</a><P>
<li><a href=r38_0150.html#r38_0183>SUM operator</a><P>
<li><a href=r38_0150.html#r38_0184>WS operator</a><P>
</menu>
<a name=r38_0186>

<title>ALGEBRAIC</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ALGEBRAIC</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
 <P>
<P>
The <em>algebraic</em> command changes REDUCE's mode of operation to 
algebraic. When <em>algebraic</em> is used as an operator (with an 
argument inside parentheses) that argument is evaluated in algebraic 
mode, but REDUCE's mode is not changed. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
algebraic; 

symbolic; 

  NIL 


algebraic(x**2); 

   2
  X  


x**2; 

    ***** The symbol X has no value.

</tt></pre><p>REDUCE's symbolic mode does not know about most algebraic commands
. 
Error messages in this mode may also depend on the particular Lisp 
used for the REDUCE implementation. 
<P>
<P>
<P>

<a name=r38_0187>

<title>ANTISYMMETRIC</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ANTISYMMETRIC</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
When an operator is declared <em>antisymmetric</em>, its arguments are 
reordered to conform to the internal ordering of the system. If an odd 
number of argument interchanges are required to do this ordering, 
the sign of the expression is changed. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>antisymmetric</em>&lt;identifier&gt;{<em>,</em>&lt;identifier&gt;}* 
<P>
<P>
<P>
&lt;identifier&gt; is an identifier that has been declared as an operator. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
operator m,n; 

antisymmetric m,n; 

m(x,n(1,2)); 

  - M( - N(2,1),X) 


operator p; 

antisymmetric p; 

p(a,b,c); 

  P(A,B,C) 


p(b,a,c); 

  - P(A,B,C)

</tt></pre><p>If &lt;identifier&gt; has not been declared an operator, the flag 

<em>antisymmetric</em> is still attached to it. When &lt;identifier&gt; is 
subsequently used as an operator, the message <em>Declare</em> &lt;identifier
&gt; 
 <em>operator? (Y or N)</em> is printed. If the user replies <em>y</em>, the 
antisymmetric property of the operator is used. 
<P>
<P>
Note in the first example, identifiers are customarily ordered 
alphabetically, while numbers are ordered from largest to smallest. 
The operators may have any desired number of arguments (less than 128). 
<P>
<P>
<P>

<a name=r38_0188>

<title>ARRAY</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ARRAY</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
The <em>array</em> declaration declares a list of identifiers to be of type 
<em>array</em>, and sets all their entries to 0. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>array</em>&lt;identifier&gt;(&lt;dimensions&gt;) 
 {<em>,</em>&lt;identifier&gt;(&lt;dimensions&gt;)}* 
<P>
<P>
<P>
&lt;identifier&gt; may be any valid REDUCE identifier. If the identifier 
was already an array, a warning message is given that the array has been 
redefined. &lt;dimensions&gt; are of form 
 &lt;integer&gt;{,&lt;integer&gt;}*. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
array a(2,5),b(3,3,3),c(200); 

array a(3,5); 

  *** ARRAY A REDEFINED 


a(3,4); 

  0 


length a; 

  {4,6}

</tt></pre><p>Arrays are always global, even if defined inside a procedure or bl
ock 
statement. Their status as an array remains until the variable is 
reset by 
<a href=r38_0150.html#r38_0189>clear</a>. Arrays may not have the same names as 
operators, 
procedures or scalar variables. 
<P>
<P>
Array elements are referred to by the usual notation: <em>a(i,j)</em> 
returns the jth element of the ith row. The 
<a href=r38_0050.html#r38_0065>assign</a>ment operator 
<em>:=</em> is used to put values into the array. Arrays as a whole 
cannot be subject to assignment by 
<a href=r38_0150.html#r38_0199>let</a> or <em>:=</em> ; the 
assignment operator <em>:=</em> is only valid for individual elements. 
<P>
<P>
When you use 
<a href=r38_0150.html#r38_0199>let</a> on an array element, the contents of that
 
element become the argument to <em>let</em>. Thus, if the element 
contains a number or some other expression that is not a valid argument 
for this command, you get an error message. If the element contains an 
identifier, the identifier has the substitution rule attached to it 
globally. The same behavior occurs with 
<a href=r38_0150.html#r38_0189>clear</a>. If the array 
element contains an identifier or simple_expression, it is cleared. Do 
&lt;not&gt; use <em>clear</em> to try to set an array element to 0. Because 
of the side effects of either <em>let</em> or <em>clear</em>, it is unwise 
to apply either of these to array elements. 
<P>
<P>
Array indices always start with 0, so that the declaration <em>array a(5)</em> 
sets aside 6 units of space, indexed from 0 through 5, and initializes 
them to 0. The 
<a href=r38_0150.html#r38_0157>length</a> command returns a list of the true num
ber of 
elements in each dimension. 
<P>
<P>
<P>

<a name=r38_0189>

<title>CLEAR</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>CLEAR</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
The <em>clear</em> command is used to remove assignments or remove substitution 

rules from any expression. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>clear</em>&lt;identifier&gt;{,&lt;identifier&gt;}+ or 
<P>
<P>
&lt;let-type statement&gt; <em>clear</em> &lt;identifier&gt; 
<P>
<P>
<P>
&lt;identifier&gt; can be any <em>scalar</em>, 
<a href=r38_0300.html#r38_0345>matrix</a>, 
or 
<a href=r38_0150.html#r38_0188>array</a> variable or 

<a href=r38_0050.html#r38_0055>procedure</a> name. &lt;let-type statement&gt; ca
n be any general 
or specific 
<a href=r38_0150.html#r38_0199>let</a> statement (see below in Comments). 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
array a(2,3); 

a(2,2) := 15; 

  A(2,2) := 15 


clear a; 

a(2,2); 

  Declare A operator? (Y or N) 


let x = y + z; 

sin(x); 

  SIN(Y + Z) 


clear x; 

sin(x); 

  SIN(X) 


let x**5 = 7; 

clear x; 

x**5; 

  7 


clear x**5; 

x**5; 

   5
  X

</tt></pre><p>Although it is not a good idea, operators of the same name but tak
ing 
different numbers of arguments can be defined. Using a <em>clear</em> statement 

on any of these operators clears every one with the same name, even if the 
number of arguments is different. 
<P>
<P>
The <em>clear</em> command is used to ``forget&quot; matrices, arrays, operators
 
and scalar variables, returning their identifiers to the pristine state 
to be used for other purposes. When <em>clear</em> is applied to array 
elements, the contents of the array element becomes the argument for 
<em>clear</em>. Thus, you get an error message if the element contains a 
number, or some other expression that is not a legal argument to 
<em>clear</em>. If the element contains an identifier, it is cleared. 
When clear is applied to matrix elements, an error message is returned 
if the element evaluates to a number, otherwise there is no effect. Do 
 not try to use <em>clear</em> to set array or matrix elements to 0. 
You will not be pleased with the results. 
<P>
<P>
If you are trying to clear power or product substitution rules made with 
either 
<a href=r38_0150.html#r38_0199>let</a> or 
<a href=r38_0150.html#r38_0195>forall</a>...<em>let</em>, you must 
reproduce the rule, exactly as you typed it with the same arguments, up to 
but not including the equal sign, using the word <em>clear</em> instead of 
the word <em>let</em>. This is shown in the last example. Any other type of 
<em>let</em> or <em>forall</em>...<em>let</em> substitution can be cleared 
with just the variable or operator name. 
<a href=r38_0200.html#r38_0205>match</a> behaves the same as 

<a href=r38_0150.html#r38_0199>let</a> in this situation. There is a more compli
cated example under 

<a href=r38_0150.html#r38_0195>forall</a>. 
<P>
<P>
<P>
<P>

<a name=r38_0190>

<title>CLEARRULES</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>CLEARRULES</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>clearrules</em>&lt;list&gt;{,&lt;list&gt;}+ 
<P>
<P>
<P>
The operator <em>clearrules</em> is used to remove previously defined 

<a href=r38_0050.html#r38_0060>rule</a> lists from the system. &lt;list&gt; can 
be an explicit rule 
list, or evaluate to a rule list. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
trig1 := {cos(~x)*cos(~y) =&gt; (cos(x+y)+cos(x-y))/2,
          cos(~x)*sin(~y) =&gt; (sin(x+y)-sin(x-y))/2,
          sin(~x)*sin(~y) =&gt; (cos(x-y)-cos(x+y))/2,
          cos(~x)^2       =&gt; (1+cos(2*x))/2,
          sin(~x)^2       =&gt; (1-cos(2*x))/2}$ 

let trig1;
cos(a)*cos(b); 

  COS(A - B) + COS(A + B)
  ----------------------- 
             2


clearrules trig1;
cos(a)*cos(b); 

  COS(A)*COS(B)

</tt></pre><p>
<a name=r38_0191>

<title>DEFINE</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>DEFINE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
The command <em>define</em> allows you to supply a new name for an identifier 
or replace it by any valid REDUCE expression. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>define</em>&lt;identifier&gt;<em>=</em>&lt;substitution&gt; 
 {<em>,</em>&lt;identifier&gt;<em>=</em>&lt;substitution&gt;}* 
<P>
<P>
<P>
&lt;identifier&gt; is any valid REDUCE identifier, &lt;substitution&gt; can be a
 
number, an identifier, an operator, a reserved word, or an expression. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>

define is= :=, xx=y+z; 


a is 10; 

  A := 10 



xx**2; 

   2             2
  Y   + 2*Y*Z + Z  



xx := 10; 

  Y + Z := 10

</tt></pre><p>The renaming is done at the input level, and therefore takes prece
dence 
over any other replacement or substitution declared for the same identifier. 
It remains in effect until the end of the REDUCE session. Be careful with 
it, since you cannot easily undo it without ending the session. 
<P>
<P>
<P>

<a name=r38_0192>

<title>DEPEND</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>DEPEND</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
 <P>
<P>
<em>depend</em>declares that its first argument depends on the rest of its 
arguments. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>depend</em>&lt;kernel&gt;{<em>,</em>&lt;kernel&gt;}+ 
<P>
<P>
<P>
&lt;kernel&gt; must be a legal variable name or a prefix operator (see 

<a href=r38_0001.html#r38_0002>kernel</a>). 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>

depend y,x; 


df(y**2,x); 

  2*DF(Y,X)*Y 



depend z,cos(x),y; 


df(sin(z),cos(x)); 

  COS(Z)*DF(Z,COS(X)) 



df(z**2,x); 

  2*DF(Z,X)*Z 



nodepend z,y; 


df(z**2,x); 

  2*DF(Z,X)*Z 



cc := df(y**2,x); 

  CC := 2*DF(Y,X)*Y 



y := tan x; 

  Y := TAN(X); 



cc; 

                  2
  2*TAN(X)*(TAN(X)   + 1)

</tt></pre><p>Dependencies can be removed by using the declaration 
<a href=r38_0200.html#r38_0204>nodepend</a>. 
The differentiation operator uses this information, as shown in the 
examples above. Linear operators also use knowledge of dependencies 
(see 
<a href=r38_0200.html#r38_0200>linear</a>). Note that dependencies can be nested
: Having 
declared y to depend on x, and z 
to depend on y, we 
see that the chain rule was applied to the derivative of a function of 
z with respect to x. If the explicit function of the 
dependency is later entered into the system, terms with <em>DF(Y,X)</em>, 
for example, are expanded when they are displayed again, as shown in the 
last example. The boolean operator 
<a href=r38_0100.html#r38_0113>freeof</a> allows you to 
check the dependency between two algebraic objects. 
<P>
<P>
<P>

<a name=r38_0193>

<title>EVEN</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>EVEN</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>even</em>&lt;identifier&gt;{,&lt;identifier&gt;}* 
<P>
<P>
<P>
This declaration is used to declare an operator even in its first 
argument. Expressions involving an operator declared in this manner are 
transformed if the first argument contains a minus sign. Any other 
arguments are not affected. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>
        even f; 

        f(-a) 

  F(A) 


        f(-a,-b) 

  F(A,-B)

</tt></pre><p><P>
<P>

<a name=r38_0194>

<title>FACTOR_declaration</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>FACTOR</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
 <P>
<P>
When a kernel is declared by <em>factor</em>, all terms involving fixed 
powers of that kernel are printed as a product of the fixed powers and 
the rest of the terms. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>factor</em>&lt;kernel&gt; {<em>,</em>&lt;kernel&gt;}* 
<P>
<P>
<P>
&lt;kernel&gt; must be a 
<a href=r38_0001.html#r38_0002>kernel</a> or a 
<a href=r38_0050.html#r38_0053>list</a> of 
<em>kernel</em>s. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
a := (x + y + z)**2; 

        2                    2            2
  A := X  + 2*X*Y + 2*X*Z + Y  + 2*Y*Z + Z  


factor y; 

a; 

   2                  2            2
  Y  + 2*Y*(X + Z) + X  + 2*X*Z + Z  


factor sin(x); 

c := df(sin(x)**4*x**2*z,x); 

               4               3         2
  C := 2*SIN(X) *X*Z + 4*SIN(X) *COS(X)*X *Z 


remfac sin(x); 

c; 

          3
  2*SIN(X) *X*Z*(2*COS(X)*X + SIN(X))

</tt></pre><p>Use the <em>factor</em> declaration to display variables of intere
st so that 
you can see their powers more clearly, as shown in the example. Remove 
this special treatment with the declaration 
<a href=r38_0200.html#r38_0217>remfac</a>. The 
<em>factor</em> declaration is only effective when the switch 
<a href=r38_0300.html#r38_0319>pri</a> 
is on. 
<P>
<P>
The <em>factor</em> declaration is not a factoring command; to factor 
expressions use the 
<a href=r38_0250.html#r38_0287>factor</a> switch or the 
<a href=r38_0150.html#r38_0151>factorize</a> command. 
<P>
<P>
The <em>factor</em> declaration is helpful in such cases as Taylor polynomials 
where the explicit powers of the variable are expected at the top level, not 
buried in various factored forms. 
<P>
<P>
Note that <em>factor</em> does not affect the order of its arguments. You 
should also use 
<a href=r38_0200.html#r38_0212>order</a> if this is important. 
<P>
<P>
<P>

<a name=r38_0195>

<title>FORALL</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>FORALL</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
 <P>
<P>
The <em>forall</em> or (preferably) <em>for all</em> command is used as a 
modifier for 
<a href=r38_0150.html#r38_0199>let</a> statements, indicating the universal appl
icability 
of the rule, with possible qualifications. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>for all</em>&lt;identifier&gt;{,&lt;identifier&gt;}* <em>let</em> 
&lt;let statement&gt; 
<P>
<P>
or 
<P>
<P>
<em>for all</em>&lt;identifier&gt;{,&lt;identifier&gt;}* 
 <em>such that</em> &lt;condition&gt; <em>let</em> &lt;let statement&gt; 
<P>
<P>
<P>
&lt;identifier&gt; may be any valid REDUCE identifier, &lt;let statement&gt; 
can be an operator, a product or power, or a group or block statement. 
&lt;condition&gt; must be a logical or comparison operator returning true or 
false. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
for all x let f(x) = sin(x**2);
 

  Declare F operator ? (Y or N) 


y 

f(a); 

       2
  SIN(A ) 


operator pos; 

for all x such that x&gt;=0 let pos(x) = sqrt(x + 1); 

pos(5); 

  SQRT(6) 


pos(-5); 

  POS(-5) 


clear pos; 

pos(5); 

  Declare POS operator ? (Y or N) 


for all a such that numberp a let x**a = 1; 

x**4; 

  1 


clear x**a; 

  *** X**A not found 


for all a  clear x**a; 

x**4; 

  1 


for all a such that numberp a clear x**a; 

x**4; 

   4
  X

</tt></pre><p>Substitution rules defined by <em>for all</em> or <em>for
all</em>...<em>such that</em> commands that involve products or powers are 
cleared by reproducing the command, with exactly the same variable names 
used, up to but not including the equal sign, with 
<a href=r38_0150.html#r38_0189>clear</a> 
replacing <em>let</em>, as shown in the last example. Other substitutions 
involving variables or operator names can be cleared with just the name, 
like any other variable. 
<P>
<P>
The 
<a href=r38_0200.html#r38_0205>match</a> command can also be used in product and
 power substitutions. 
The syntax of its use and clearing is exactly like <em>let</em>. A <em>match
</em> 
substitution only replaces the term if it is exactly like the pattern, for 
example <em>match x**5 = 1</em> replaces only terms of <em>x**5</em> and not 
terms of higher powers. 
<P>
<P>
It is easier to declare your potential operator before defining the 
<em>for all</em> rule, since the system will ask you to declare it an 
operator anyway. Names of declared arrays or matrices or scalar 
variables are invalid as operator names, to avoid ambiguity. Either 
<em>for all</em>...<em>let</em> statements or procedures are often used to defin
e 
operators. One difference is that procedures implement ``call by value&quot; 
meaning that assignments involving their formal parameters do not change 
the calling variables that replace them. If you use assignment statements 
on the formal parameters in a <em>for all</em>...<em>let</em> statement, the 
effects are seen in the calling variables. Be careful not to redefine a 
system operator unless you mean it: the statement <em>for all x let
sin(x)=0;</em> has exactly that effect, and the usual definition for sin(x) has 

been lost for the remainder of the REDUCE session. <P>
<P>

<P>
<P>

<a name=r38_0196>

<title>INFIX</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>INFIX</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
 <P>
<P>
<em>infix</em>declares identifiers to be infix operators. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>infix</em>&lt;identifier&gt;{,&lt;identifier&gt;}* 
<P>
<P>
<P>
&lt;identifier&gt; can be any valid REDUCE identifier, which has not already 
been declared an operator, array or matrix, and is not reserved by the 
system. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
infix aa; 

for all x,y let aa(x,y) = cos(x)*cos(y) - sin(x)*sin(y); 

x aa y; 

  COS(X)*COS(Y) - SIN(X)*SIN(Y) 


pi/3 aa pi/2; 

    SQRT(3)
  - ------- 
       2


aa(pi,pi); 

  1

</tt></pre><p>A 
<a href=r38_0150.html#r38_0199>let</a> statement must be used to attach function
ality to 
the operator. Note that the operator is defined in prefix form in 
the <em>let</em> statement. 
After its definition, the operator may be used in either prefix or infix 
mode. The above operator aa finds the cosine of the sum 
of two angles by the formula 
<P>
<P>
cos(x+y) = cos(x)*cos(y) - sin(x)*sin(y). 
<P>
<P>
Precedence may be attached to infix operators with the 

<a href=r38_0200.html#r38_0213>precedence</a> declaration. 
<P>
<P>
User-defined infix operators may be used in prefix form. If they are used 
in infix form, a space must be left on each side of the operator to avoid 
ambiguity. Infix operators are always binary. 
<P>
<P>
<P>

<a name=r38_0197>

<title>INTEGER</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>INTEGER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
The <em>integer</em> declaration must be made immediately after a 

<a href=r38_0001.html#r38_0040>begin</a> (or other variable declaration such as 
<a href=r38_0200.html#r38_0216>real</a> 
and 
<a href=r38_0200.html#r38_0218>scalar</a>) and declares local integer variables.
 They are 
initialized to 0. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>integer</em>&lt;identifier&gt;{,&lt;identifier&gt;}* 
<P>
<P>
<P>
&lt;identifier&gt; may be any valid REDUCE identifier, except 
<em>t</em> or <em>nil</em>. 
<P>
<P>
Integer variables remain local, and do not share values with variables of 
the same name outside the 
<a href=r38_0001.html#r38_0040>begin</a>...<em>end</em> block. When the 
block is finished, the variables are removed. You may use the words 

<a href=r38_0200.html#r38_0216>real</a> or 
<a href=r38_0200.html#r38_0218>scalar</a> in the place of <em>integer</em>. 
<em>integer</em> does not indicate typechecking by the 
current REDUCE; it is only for your own information. Declaration 
statements must immediately follow the <em>begin</em>, without a semicolon 
between <em>begin</em> and the first variable declaration. 
<P>
<P>
Any variables used inside <em>begin</em>...<em>end</em> blocks that were not 
declared <em>scalar</em>, <em>real</em> or <em>integer</em> are global, and any 

change made to them inside the block affects their global value. Any 

<a href=r38_0150.html#r38_0188>array</a> or 
<a href=r38_0300.html#r38_0345>matrix</a> declared inside a block is always glob
al. 
<P>
<P>
<P>

<a name=r38_0198>

<title>KORDER</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>KORDER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
 <P>
<P>
The <em>korder</em> declaration changes the internal canonical ordering of 
kernels. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>korder</em>&lt;kernel&gt;{<em>,</em>&lt;kernel&gt;}* 
<P>
<P>
<P>
&lt;kernel&gt; must be a REDUCE 
<a href=r38_0001.html#r38_0002>kernel</a> or a 
<a href=r38_0050.html#r38_0053>list</a> of 
<em>kernel</em>s. 
<P>
<P>
The declaration <em>korder</em> changes the internal ordering, but not the print
 
ordering, so the effects cannot be seen on output. However, in some 
calculations, the order of the variables can have significant effects on the 
time and space demands of a calculation. If you are doing a demanding 
calculation with several kernels, you can experiment with changing the 
canonical ordering to improve behavior. 
<P>
<P>
The first kernel in the argument list is given the highest priority, the 
second gets the next highest, and so on. Kernels not named in a 
<em>korder</em> ordering otherwise. A new <em>korder</em> declaration replaces 
the previous one. To return to canonical ordering, use the command 
<em>korder nil</em>. 
<P>
<P>
To change the print ordering, use the declaration 
<a href=r38_0200.html#r38_0212>order</a>. 
<P>
<P>
<P>

<a name=r38_0199>

<title>LET</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LET</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
 <P>
<P>
The <em>let</em> command defines general or specific substitution rules. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>let</em>&lt;identifier&gt; <em>=</em> &lt;expression&gt;{,&lt;identifier&gt;
 
<em>=</em> &lt;expression&gt;}* 
<P>
<P>
<P>
&lt;identifier&gt; can be any valid REDUCE identifier except an array, and in 
some cases can be an expression; &lt;expression&gt; can be any valid REDUCE 
expression. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
let a = sin(x); 

b := a; 

  B := SIN X; 


let c = a; 

exp(a); 

   SIN(X)
  E       


a := x**2; 

        2
  A := X  


exp(a); 

    2
   X
  E   


exp(b); 

   SIN(X)
  E       


exp(c); 

    2
   X
  E   


let m + n = p; 

(m + n)**5; 

   5
  P  


operator h; 

let h(u,v) = u - v; 

h(u,v); 

  U - V 


h(x,y); 

  H(X,Y) 


array q(10); 

let q(1) = 15; 

  ***** Substitution for 0 not allowed

</tt></pre><p>The <em>let</em> command is also used to activate a <em>rule sets
</em>. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>let</em>&lt;list&gt;{,&lt;list&gt;}+ 
<P>
<P>
<P>
&lt;list&gt; can be an explicit 
<a href=r38_0050.html#r38_0060>rule</a> <em>list</em>, or evaluate 
to a rule list. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
trig1 := {cos(~x)*cos(~y) =&gt; (cos(x+y)+cos(x-y))/2,
          cos(~x)*sin(~y) =&gt; (sin(x+y)-sin(x-y))/2,
          sin(~x)*sin(~y) =&gt; (cos(x-y)-cos(x+y))/2,
          cos(~x)^2       =&gt; (1+cos(2*x))/2,
          sin(~x)^2       =&gt; (1-cos(2*x))/2}$ 

let trig1;
cos(a)*cos(b); 

  COS(A - B) + COS(A + B)
  ------------------------
             2

</tt></pre><p>A <em>let</em> command returns no value, though the substitution r
ule is 
entered. Assignment rules made by 
<a href=r38_0050.html#r38_0065>assign</a> and <em>let</em> 
rules are at the 
same level, and cancel each other. There is a difference in their 
operation, however, as shown in the first example: a <em>let</em> assignment 
tracks the changes in what it is assigned to, while a <em>:=</em> assignment 
is fixed at the value it originally had. 
<P>
<P>
The use of expressions as left-hand sides of <em>let</em> statements is a 
little complicated. The rules of operation are: 
<P>
<P>
 _ _ _ (i) 
Expressions of the form A*B = C do not change A, B or C, but set A*B to C. 
<P>
<P>
 _ _ _ (ii) 
Expressions of the form A+B = C substitute C - B for A, but do not change 
B or C. 
<P>
<P>
 _ _ _ (iii) 
Expressions of the form A-B = C substitute B + C for A, but do not change 
B or C. 
<P>
<P>
 _ _ _ (iv) 
Expressions of the form A/B = C substitute B*C for A, but do not change B or 
C. 
<P>
<P>
 _ _ _ (v) 
Expressions of the form A**N = C substitute C for A**N in every expression of 
a power of A to N or greater. An asymptotic command such as A**N = 0 sets 
all terms involving A to powers greater than or equal to N to 0. Finite 
fields may be generated by requiring modular arithmetic (the 
<a href=r38_0300.html#r38_0305>modular</a> 
switch) and defining the primitive polynomial via a <em>let</em> statement. 
<P>
<P>
<P>
<em>let</em>substitutions involving expressions are cleared by using 
the 
<a href=r38_0150.html#r38_0189>clear</a> command with exactly the same expressio
n. 
<P>
<P>
Note when a simple <em>let</em> statement is used to assign functionality to an 

operator, it is valid only for the exact identifiers used. For the use of the 
<em>let</em> command to attach more general functionality to an operator, 
see 
<a href=r38_0150.html#r38_0195>forall</a>. 
<P>
<P>
Arrays as a whole cannot be arguments to <em>let</em> statements, but 
matrices as a whole can be legal arguments, provided both arguments are 
matrices. However, it is important to note that the two matrices are then 
linked. Any change to an element of one matrix changes the corresponding 
value in the other. Unless you want this behavior, you should not use 
<em>let</em> for matrices. The assignment operator 
<a href=r38_0050.html#r38_0065>assign</a> can be used 
for non-tracking assignments, avoiding the side effects. Matrices are 
redimensioned as needed in <em>let</em> statements. 
<P>
<P>
When array or matrix elements are used as the left-hand side of <em>let</em> 
statements, the contents of that element is used as the argument. When the 
contents is a number or some other expression that is not a valid left-hand 
side for <em>let</em>, you get an error message. If the contents is an 
identifier or simple expression, the <em>let</em> rule is globally attached 
to that identifier, and is in effect not only inside the array or matrix, 
but everywhere. Because of such unwanted side effects, you should not 
use <em>let</em> with array or matrix elements. The assignment operator 
<em>:=</em> can be used to put values into array or matrix elements without 
the side effects. 
<P>
<P>
Local variables declared inside <em>begin</em>...<em>end</em> blocks cannot 
be used as the left-hand side of <em>let</em> statements. However, 

<a href=r38_0001.html#r38_0040>begin</a>...<em>end</em> blocks themselves can be
 used as the 
right-hand side of <em>let</em> statements. The construction: 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>for all</em>&lt;vars&gt; 
 <em>let</em>&lt;operator&gt;(&lt;vars&gt;)<em>=</em>&lt;block&gt; 
<P>
<P>
<P>
is an alternative to the 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>procedure</em>&lt;name&gt;(&lt;vars&gt;)<em>;</em>&lt;block&gt; 
<P>
<P>
<P>
construction. One important difference between the two constructions is that 
the &lt;vars&gt; as formal parameters to a procedure have their global values 
protected against change by the procedure, while the &lt;vars&gt; of a 
<em>let</em> statement are changed globally by its actions. 
<P>
<P>
Be careful in using a construction such as <em>let x = x + 1</em> except inside 

a controlled loop statement. The process of resubstitution continues until 
a stack overflow message is given. 
<P>
<P>
The <em>let</em> statement may be used to make global changes to variables from 

inside procedures. If <em>x</em> is a formal parameter to a procedure, the 
command <em>let x = </em>... makes the change to the calling variable. 
For example, if a procedure was defined by 
<p><pre><tt>
        procedure f(x,y);
        let x = 15;
</tt></pre><p><P>
<P>
and the procedure was called as 
<p><pre><tt>
        f(a,b);
</tt></pre><p><P>
<P>
<em>a</em>would have its value changed to 15. Be careful when using <em>let</em>
 
statements inside procedures to avoid unwanted side effects. 
<P>
<P>
It is also important to be careful when replacing <em>let</em> statements with 
other <em>let</em> statements. The overlapping of these substitutions can be 
unpredictable. Ordinarily the latest-entered rule is the first to be applied. 
Sometimes the previous rule is superseded completely; other times it stays 
around as a special case. The order of entering a set of related <em>let</em> 
expressions is very important to their eventual behavior. The best 
approach is to assume that the rules will be applied in an arbitrary order. 
<P>
<P>
<P>
