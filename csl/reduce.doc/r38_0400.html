
<a name=r38_0400>

<title>Tracing Groebner bases</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Tracing Groebner bases</b><menu>
<li><a href=r38_0350.html#r38_0396>groebprot switch</a><P>
<li><a href=r38_0350.html#r38_0397>groebprotfile variable</a><P>
<li><a href=r38_0350.html#r38_0398>groebnert operator</a><P>
<li><a href=r38_0350.html#r38_0399>preducet operator</a><P>
</menu>
<a name=r38_0401>

<title>Module</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MODULE</b><P>
<P>
 
Given a polynomial ring, e.g. R=Z[x,y,...] and an integer n&gt;1. 
The vectors with n elements of R form a free MODULE under 
elementwise addition and multiplication with elements of R. 
<P>
<P>
For a submodule given by a finite basis a Groebner basis 
can be computed, and the facilities of the GROEBNER package 
are available except the operators 
<a href=r38_0350.html#r38_0391>groebnerf</a> 
and <em>groesolve</em>. The vectors are encoded using auxiliary 
variables which represent the unit vectors in the module. 
These are declared in the share variable 
<a href=r38_0400.html#r38_0402>gmodule</a>. 
<P>
<P>

<a name=r38_0402>

<title>gmodule</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GMODULE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
The vectors of a free 
<a href=r38_0400.html#r38_0401>module</a> over a polynomial ring R 
are encoded as linear combinations with unit vectors of 
M which are represented by auxiliary variables. These 
must be collected in the variable <em>gmodule</em> before 
any call to an operator of the Groebner package. 
<P>
<P>
<p><pre><tt>
   torder({x,y,v1,v2,v3})$
   gmodule := {v1,v2,v3}$
   g:=groebner({x^2*v1 + y*v2,x*y*v1 - v3,2y*v1 + y*v3});
</tt></pre><p>compute the Groebner basis of the submodule 
<P>
<P>
<p><pre><tt>
      ([x^2,y,0],[xy,0,-1],[0,2y,y])
</tt></pre><p>The members of the list <em>gmodule</em> are automatically 
appended to the end of the variable list, if they are not 
yet members there. They take part in the actual term ordering. 
<P>
<P>

<a name=r38_0403>

<title>Groebner Bases for Modules</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Groebner Bases for Modules</b><menu>
<li><a href=r38_0400.html#r38_0401>Module concept</a><P>
<li><a href=r38_0400.html#r38_0402>gmodule variable</a><P>
</menu>
<a name=r38_0404>

<title>gsort</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GSORT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>gsort</em>(&lt;p&gt;) 
<P>
<P>
<P>
where &lt;p&gt; is a polynomial or a list of polynomials. 
<P>
<P>
The polynomials are reordered and sorted corresponding to 
the current 
<a href=r38_0350.html#r38_0353>term order</a>. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>

  torder lex;
  
  gsort(x**2+2x*y+y**2,{y,x}); 

  y**2+2y*x+x**2

</tt></pre><p><P>
<P>

<a name=r38_0405>

<title>gsplit</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GSPLIT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>gsplit</em>(&lt;p&gt;[,&lt;vars&gt;]); 
<P>
<P>
<P>
where &lt;p&gt; is a polynomial or a list of polynomials. 
<P>
<P>
The polynomial is reordered corresponding to the 
the current 
<a href=r38_0350.html#r38_0353>term order</a> and then 
separated into leading term and reductum. Result is 
a list with the leading term as first and the reductum 
as second element. 
 <P> <H3> 
examples: </H3>
<p><pre><tt>

  torder lex;
  
  gsplit(x**2+2x*y+y**2,{y,x}); 

  {y**2,2y*x+x**2}

</tt></pre><p><P>
<P>

<a name=r38_0406>

<title>gspoly</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GSPOLY</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>gspoly</em>(&lt;p1&gt;,&lt;p2&gt;); 
<P>
<P>
<P>
<P>
where &lt;p1&gt; and &lt;p2&gt; are polynomials. 
<P>
<P>
The <em>subtraction</em> polynomial of p1 and p2 is computed 
corresponding to the method of the Buchberger algorithm for 
computing <em>groebner bases</em>: p1 and p2 are multiplied 
with terms such that when subtracting them the leading terms 
cancel each other. 
<P>
<P>

<a name=r38_0407>

<title>Computing with distributive polynomials</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Computing with distributive polynomials</b><menu>
<li><a href=r38_0400.html#r38_0404>gsort operator</a><P>
<li><a href=r38_0400.html#r38_0405>gsplit operator</a><P>
<li><a href=r38_0400.html#r38_0406>gspoly operator</a><P>
</menu>
<a name=r38_0408>

<title>Groebner package</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Groebner package</b><menu>
<li><a href=r38_0350.html#r38_0351>Groebner bases introduction</a><P>
<li><a href=r38_0350.html#r38_0352>Ideal Parameters concept</a><P>
<li><a href=r38_0350.html#r38_0366>Term order</a><P>
<li><a href=r38_0350.html#r38_0390>Basic Groebner operators</a><P>
<li><a href=r38_0350.html#r38_0395>Factorizing Groebner bases</a><P>
<li><a href=r38_0400.html#r38_0400>Tracing Groebner bases</a><P>
<li><a href=r38_0400.html#r38_0403>Groebner Bases for Modules</a><P>
<li><a href=r38_0400.html#r38_0407>Computing with distributive polynomials</a>
<P>
</menu>
<a name=r38_0409>

<title>HEPHYS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>HEPHYS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>introduction</b><P>
<P>
 
The High-energy Physics package is historic for REDUCE, since REDUCE 
originated as a program to aid in computations with Dirac expressions. 
The commutation algebra of the gamma matrices is independent of their 
representation, and is a natural subject for symbolic mathematics. Dirac 
theory is applied to beta decay and the computation of 
cross-sections and scattering. The high-energy physics operators are 
available in the REDUCE main program, rather than as a module which must 
be loaded. 
<P>
<P>

<a name=r38_0410>

<title>HE_dot</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>.</b> _ _ _ <b>HE-DOT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The . operator is used to denote the scalar product of two Lorentz 
four-vectors. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
&lt;vector&gt; <em>.</em> &lt;vector&gt; 
<P>
<P>
<P>
&lt;vector&gt; must be an identifier declared to be of type <em>vector</em> to h
ave 
the scalar product definition. When applied to arguments that are not 
vectors, the 
<a href=r38_0001.html#r38_0043>cons</a> operator is used, 
whose symbol is also ``dot.'' 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
vector aa,bb,cc; 

let aa.bb = 0; 

aa.bb; 

  0 


aa.cc; 

  AA.CC 


q := aa.cc; 

  Q := AA.CC 


q; 

  AA.CC

</tt></pre><p>Since vectors are special high-energy physics entities that do not
 contain 
values, the . product will not return a true scalar product. You can 
assign a scalar identifier to the result of a . operation, or assign a . 
operation to have the value of the scalar you supply, as shown above. Note 
that the result of a . operation is a scalar, not a vector. 
<P>
<P>
The metric tensor g(u,v) can be represented by <em>u.v</em>. If contraction 
over the indices is required, <em>u</em> and <em>v</em> should be declared to 
be of type 
<a href=r38_0400.html#r38_0413>index</a>. 
<P>
<P>
The dot operator has the highest precedence of the infix operators, so 
expressions involving . and other operators have the scalar product 
evaluated first before other operations are done. 
<P>
<P>
<P>

<a name=r38_0411>

<title>EPS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>EPS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The <em>eps</em> operator denotes the completely antisymmetric tensor of 
order 4 and its contraction with Lorentz four-vectors, as used in 
high-energy physics calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>eps</em>(&lt;vector-expr&gt;,&lt;vector-expr&gt;,&lt;vector-expr&gt;, 
&lt;vector-expr&gt;) 
<P>
<P>
<P>
&lt;vector-expr&gt; must be a valid vector expression, and may be an index. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
vector g0,g1,g2,g3; 

eps(g1,g0,g2,g3); 

  - EPS(G0,G1,G2,G3); 


eps(g1,g2,g0,g3); 

  EPS(G0,G1,G2,G3); 


eps(g1,g2,g3,g1); 

  0

</tt></pre><p>Vector identifiers are ordered alphabetically by REDUCE. When an o
dd number 
of transpositions is required to restore the canonical order to the four 
arguments of <em>eps</em>, the term is ordered and carries a minus sign. When an
 
even number of transpositions is required, the term is returned ordered and 
positive. When one of the arguments is repeated, the value 0 is returned. 
A contraction of the form 
eps(_i j mu nu p_mu q_nu) 
is represented by <em>eps(i,j,p,q)</em> when <em>i</em> and <em>j</em> have been
 
declared to be of type 
<a href=r38_0400.html#r38_0413>index</a>. 
<P>
<P>
<P>

<a name=r38_0412>

<title>G</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>G</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
<em>g</em> is an n-ary operator used to denote a product of gamma matrices 
contracted with Lorentz four-vectors, in high-energy physics. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>g</em>(&lt;identifier&gt;,&lt;vector-expr&gt; 
{,&lt;vector-expr&gt;}*) 
<P>
<P>
<P>
&lt;identifier&gt; is a scalar identifier representing a fermion line 
identifier, &lt;vector-expr&gt; can be any valid vector expression, 
representing a vector or a gamma matrix. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
vector aa,bb,cc; 

vector a; 

g(line1,aa,bb); 

  AA.BB 


g(line2,aa,a); 

  0 


g(id,aa,bb,cc); 

  0 


g(li1,aa,bb) + k; 

  AA.BB + K 


let aa.bb = m*k; 

g(ln1,aa)*g(ln1,bb); 

  K*M 


g(ln1,aa)*g(ln2,bb); 

  0

</tt></pre><p>The vector <em>A</em> is reserved in arguments of <em>g</em> to de
note the 
special gamma matrix gamma_5. It must be declared to 
be a vector before you use it. 
<P>
<P>
Gamma matrix expressions are associated with fermion lines in a Feynman 
diagram. If more than one line occurs in an expression, the gamma 
matrices involved are separate (operating in independent spin space), as 
shown in the last two example lines above. A product of gamma matrices 
associated with a single line can be entered either as a single <em>g</em> 
command with several vector arguments, or as products of separate <em>g</em> 
commands each with a single argument. 
<P>
<P>
While the product of vectors is not defined, the product, sum and 
difference of several gamma expressions are defined, as is the product of 
a gamma expression with a scalar. If an expression involving gamma 
matrices includes a scalar, the scalar is treated as if it were the 
product of itself with a unit 4 x 4 matrix. 
<P>
<P>
Dirac expressions are evaluated by computing the trace of the expression 
using the commutation algebra of gamma matrices. The algorithms used are 
described in articles by J. S. R. Chisholm in &lt;Il Nuovo Cimento X,&gt; Vol. 
30, p. 426, 1963, and J. Kahane, &lt;Journal of Mathematical Physics&gt;, 
Vol. 9, p. 1732, 1968. The trace is then divided by 4 to distinguish 
between the trace of a scalar and the trace of an expression that is the 
product of a scalar with a unit 4 x 4 matrix. 
<P>
<P>
Trace calculations may be prevented over any line identifier by declaring it 
to be 
<a href=r38_0400.html#r38_0416>nospur</a>. If it is later desired to evaluate th
ese traces, 
the declaration can be undone with the 
<a href=r38_0400.html#r38_0418>spur</a> declaration. 
<P>
<P>
The notation of Bjorken and Drell, &lt;Relativistic Quantum Mechanics,&gt; 
1964, is assumed in all operations involving gamma matrices. For an 
example of the use of <em>g</em> in a calculation, see the &lt;REDUCE 
User's Manual&gt;. 
<P>
<P>
<P>

<a name=r38_0413>

<title>INDEX</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>INDEX</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
The declaration <em>index</em> flags a four-vector as an index for subsequent 
high-energy physics calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>index</em>&lt;vector-id&gt;{,&lt;vector-id&gt;}* 
<P>
<P>
<P>
&lt;vector-id&gt; must have been declared of type <em>vector</em>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
vector aa,bb,cc; 

index uu; 

let aa.bb = 0; 

(aa.uu)*(bb.uu); 

  0 


(aa.uu)*(cc.uu); 

  AA.CC

</tt></pre><p>Index variables are used to represent contraction over components 
of 
vectors when scalar products are taken by the . operator, as well as 
indicating contraction for the 
<a href=r38_0400.html#r38_0411>eps</a> operator or metric tensor. 
<P>
<P>
The special status of a vector as an index can be revoked with the 
declaration 
<a href=r38_0400.html#r38_0417>remind</a>. The object remains a vector, however.
 
<P>
<P>
<P>

<a name=r38_0414>

<title>MASS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MASS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
The <em>mass</em> command associates a scalar variable as a mass with 
the corresponding vector variable, in high-energy physics calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>mass</em>&lt;vector-var&gt;<em>=</em>&lt;scalar-var&gt; 
{,&lt;vector-var&gt;<em>=</em>&lt;scalar-var&gt;}* 
<P>
<P>
<P>
&lt;vector-var&gt; can be a declared vector variable; <em>mass</em> will declare
 
it to be of type <em>vector</em> if it is not. This may override an existing 
matrix variable by that name. &lt;scalar-var&gt; must be a scalar variable. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
vector bb,cc; 

mass cc=m; 

mshell cc; 

cc.cc; 

   2
  M

</tt></pre><p>Once a mass has been attached to a vector with a <em>mass</em> dec
laration, 
the 
<a href=r38_0400.html#r38_0415>mshell</a> declaration puts the associated partic
le ``on the mass 
shell.'' Subsequent scalar (.) products of the vector with itself will be 
replaced by the square of the mass expression. 
<P>
<P>
<P>

<a name=r38_0415>

<title>MSHELL</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MSHELL</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
The <em>mshell</em> command puts particles on the mass shell in high-energy 
physics calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>mshell</em>&lt;vector-var&gt;{,&lt;vector-var&gt;}* 
<P>
<P>
<P>
&lt;vector-var&gt; must have had a mass attached to it by a 
<a href=r38_0400.html#r38_0414>mass</a> 
declaration. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
vector v1,v2; 

mass v1=m,v2=q; 

mshell v1; 

v1.v1; 

   2
  M  


v2.v2; 

  V2.V2 


mshell v2; 

v1.v1*v2.v2; 

   2  2
  M *Q

</tt></pre><p>Even though a mass is attached to a vector variable representing a
 
particle, the replacement does not take place until the <em>mshell</em> 
declaration is given for that vector variable. 
<P>
<P>
<P>

<a name=r38_0416>

<title>NOSPUR</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NOSPUR</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
The <em>nospur</em> declaration prevents the trace calculation over the given 
line identifiers in high-energy physics calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>nospur</em>&lt;line-id&gt;{,&lt;line-id&gt;}* 
<P>
<P>
<P>
&lt;line-id&gt; is a scalar identifier that will be used as a line identifier. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
vector a1,b1,c1; 

g(line1,a1,b1)*g(line2,b1,c1); 

  A1.B1*B1.C1 


nospur line2; 

g(line1,a1,b1)*g(line2,b1,c1); 

  A1.B1*G(LINE2,B1,C1)

</tt></pre><p>Nospur declarations can be removed by making the declaration 
<a href=r38_0400.html#r38_0418>spur</a>. 
<P>
<P>
<P>

<a name=r38_0417>

<title>REMIND</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>REMIND</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
The <em>remind</em> declaration removes the special status of its arguments 
as indices, which was set in the 
<a href=r38_0400.html#r38_0413>index</a> declaration, in 
high-energy physics calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>remind</em>&lt;identifier&gt;{,&lt;identifier&gt;}* 
<P>
<P>
<P>
&lt;identifier&gt; must have been declared to be of type 
<a href=r38_0400.html#r38_0413>index</a>. 
<P>
<P>

<a name=r38_0418>

<title>SPUR</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SPUR</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
The <em>spur</em> declaration removes the special exemption from trace 
calculations that was declared by 
<a href=r38_0400.html#r38_0416>nospur</a>, in high-energy physics 
calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>spur</em>&lt;line-id&gt;{,&lt;line-id&gt;}* 
<P>
<P>
<P>
&lt;line-id&gt; must be a line-identifier that has previously been declared 
<em>nospur</em>. 
<P>
<P>

<a name=r38_0419>

<title>VECDIM</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>VECDIM</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>command</b><P>
<P>
 
The command <em>vecdim</em> changes the vector dimension from 4 to an arbitrary 

integer or symbol. Used in high-energy physics calculations. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>vecdim</em>&lt;dimension&gt; 
<P>
<P>
<P>
&lt;dimension&gt; must be either an integer or a valid scalar identifier that 
does not have a floating-point value. 
<P>
<P>
The 
<a href=r38_0400.html#r38_0411>eps</a> operator and the gamma_5 
symbol (<em>A</em>) are not properly defined in anything except four 
dimensions and will print an error message if you use them that way. The 
other high-energy physics operators should work without problem. 
<P>
<P>
<P>

<a name=r38_0420>

<title>VECTOR</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>VECTOR</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>declaration</b><P>
<P>
 
The <em>vector</em> declaration declares that its arguments are of type <em>vect
or</em>. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>vector</em>&lt;identifier&gt;{,&lt;identifier&gt;}* 
<P>
<P>
<P>
&lt;identifier&gt; must be a valid REDUCE identifier. It may have already been 
used for a matrix, array, operator or scalar variable. After an identifier 
has been declared to be a vector, it may not be used as a scalar variable. 
<P>
<P>
Vectors are special entities for high-energy physics calculations. You 
cannot put values into their coordinates; they do not have coordinates. 
They are legal arguments for the high-energy physics operators 

<a href=r38_0400.html#r38_0411>eps</a>, 
<a href=r38_0400.html#r38_0412>g</a> and <em>.</em> (dot). Vector variables are 

used to represent gamma matrices and gamma matrices contracted with Lorentz 
4-vectors, since there are no Dirac variables per se in the system. 
Vectors do follow the usual vector rules for arithmetic operations: 
<em>+</em> and <em>-</em> operate upon two or more vectors, producing a 
vector; <em>*</em> and <em>/</em> cannot be used between vectors; the 
scalar product is represented by the . operator; and the product of a 
scalar and vector expression is well defined, and is a vector. 
<P>
<P>
You can represent components of vectors by including representations of unit 
vectors in your system. For instance, letting <em>E0</em> represent the unit 
vector (1,0,0,0), the command 
<P>
<P>
<em>V1.E0 := 0;</em>would set up the substitution of zero for the first componen
t of the vector 
<em>V1</em>. 
<P>
<P>
Identifiers that are declared by the <em>index</em> and <em>mass</em> declaratio
ns are 
automatically declared to be vectors. 
<P>
<P>
The following errors can occur in calculations using the high energy 
physics package: 
<P>
<P>
<em>A represents only gamma5 in vector expressions</em>You have tried to use A i
n some way other than gamma5 in a 
high-energy physics expression. 
<P>
<P>
<P>
<em>Gamma5 not allowed unless vecdim is 4</em>You have used gamma_5 in a high-en
ergy physics 
computation involving a vector dimension other than 4. 
<P>
<P>
<P>
&lt;ID&gt; <em>has no mass</em> 
<P>
<P>
One of the arguments to 
<a href=r38_0400.html#r38_0415>mshell</a> has had no mass assigned to it, in 
high-energy physics calculations. 
<P>
<P>
<P>
<em>Missing arguments for G operator</em>A line symbol is missing in a gamma mat
rix expression in high-energy physics 
calculations. 
<P>
<P>
<P>
<em>Unmatched index</em>&lt;list&gt; 
<P>
<P>
The parser has found unmatched indices during the evaluation of a 
gamma matrix expression in high-energy physics calculations. 
<P>
<P>
<P>
<P>
<P>

<a name=r38_0421>

<title>High Energy Physics</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>High Energy Physics</b><menu>
<li><a href=r38_0400.html#r38_0409>HEPHYS introduction</a><P>
<li><a href=r38_0400.html#r38_0410>HE-dot operator</a><P>
<li><a href=r38_0400.html#r38_0411>EPS operator</a><P>
<li><a href=r38_0400.html#r38_0412>G operator</a><P>
<li><a href=r38_0400.html#r38_0413>INDEX declaration</a><P>
<li><a href=r38_0400.html#r38_0414>MASS command</a><P>
<li><a href=r38_0400.html#r38_0415>MSHELL command</a><P>
<li><a href=r38_0400.html#r38_0416>NOSPUR declaration</a><P>
<li><a href=r38_0400.html#r38_0417>REMIND declaration</a><P>
<li><a href=r38_0400.html#r38_0418>SPUR declaration</a><P>
<li><a href=r38_0400.html#r38_0419>VECDIM command</a><P>
<li><a href=r38_0400.html#r38_0420>VECTOR declaration</a><P>
</menu>
<a name=r38_0422>

<title>Numeric_Package</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUMERIC PACKAGE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>introduction</b><P>
<P>
 
The numeric package supplies algorithms based on approximation 
techniques of numerical mathematics. The algorithms use 
the 
<a href=r38_0300.html#r38_0330>rounded</a> mode arithmetic of REDUCE, including 

the variable precision feature which is exploited in some 
algorithms in an adaptive manner in order to reach the 
desired accuracy. 
<P>
<P>

<a name=r38_0423>

<title>Interval</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>INTERVAL</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>type</b><P>
<P>
 
Intervals are generally coded as lower bound and 
upper bound connected by the operator <em>..</em>, usually 
associated to a variable in an 
equation. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
&lt;var&gt; = (&lt;low&gt; .. &lt;high&gt;) 
<P>
<P>
<P>
where &lt;var&gt; is a 
<a href=r38_0001.html#r38_0002>kernel</a> and &lt;low&gt;, &lt;high&gt; are 
numbers or expression which evaluate to numbers with &lt;low&gt;&lt;=&lt;high
&gt;. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt></tt></pre><p>means that the variable x is taken in the range from 2
.5 up to 
3.5. 
<P>
<P>

<a name=r38_0424>

<title>numeric_accuracy</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUMERIC ACCURACY</b><P>
<P>
 
The keyword parameters <em>accuracy=a</em> and <em>iterations=i</em>, 
where <em>a</em>and <em>i</em> must be positive integer numbers, control the 
iterative algorithms: the iteration is continued until 
the local error is below 10**-a; if that is impossible 
within <em>i</em> steps, the iteration is terminated with an 
error message. The values reached so far are then returned 
as the result. 
<P>
<P>

<a name=r38_0425>

<title>TRNUMERIC</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>TRNUMERIC</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
Normally the algorithms produce only a minimum of printed 
output during their operation. In cases of an unsuccessful 
or unexpected long operation a <em>trace of the iteration</em> can be 
printed by setting <em>trnumeric</em> <em>on</em>. 
<P>
<P>

<a name=r38_0426>

<title>num_min</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUM_MIN</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The Fletcher Reeves version of the <em>steepest descent</em> 
algorithms is used to find the <em>minimum</em> of a 
function of one or more variables. The 
function must have continuous partial derivatives with respect to all 
variables. The starting point of the search can be 
specified; if not, random values are taken instead. 
The steepest descent algorithms in general find only local 
minima. 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>num_min</em>(&lt;exp&gt;, 
 &lt;var&gt;[=&lt;val&gt;] [,&lt;var&gt;[=&lt;val&gt;] ... 
 [,accuracy=&lt;a&gt;] [,iterations=&lt;i&gt;]) 
<P>
<P>
or 
<P>
<P>
<em>num_min</em>(exp, { 
 &lt;var&gt;[=&lt;val&gt;] [,&lt;var&gt;[=&lt;val&gt;] ...] } 
 [,accuracy=&lt;a&gt;] [,iterations=&lt;i&gt;]) 
<P>
<P>
<P>
where &lt;exp&gt; is a function expression, 
&lt;var&gt; are the variables in &lt;exp&gt; and 
&lt;val&gt; are the (optional) start values. 
For &lt;a&gt; and &lt;i&gt; see 
<a href=r38_0400.html#r38_0424>numeric accuracy</a>. 
<P>
<P>
<em>Num_min</em>tries to find the next local minimum along the descending 
path starting at the given point. The result is a 
<a href=r38_0050.html#r38_0053>list</a> 
with the minimum function value as first element followed by a list 
of 
<a href=r38_0001.html#r38_0045>equation</a><em>s</em>, where the variables are e
quated to the coordinates 
of the result point. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
num_min(sin(x)+x/5, x)

  {4.9489585606,{X=29.643767785}}


num_min(sin(x)+x/5, x=0)

  { - 1.3342267466,{X= - 1.7721582671}}

</tt></pre><p>
<a name=r38_0427>

<title>num_solve</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUM_SOLVE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
An adaptively damped Newton iteration is used to find 
an approximative root of a function (function vector) or the 
solution of an 
<a href=r38_0001.html#r38_0045>equation</a> (equation system). The expressions 
must have continuous derivatives for all variables. 
A starting point for the iteration can be given. If not given 
random values are taken instead. When the number of 
forms is not equal to the number of variables, the 
Newton method cannot be applied. Then the minimum 
of the sum of absolute squares is located instead. 
<P>
<P>
With 
<a href=r38_0250.html#r38_0274>complex</a> on, solutions with imaginary parts ca
n be 
found, if either the expression(s) or the starting point 
contain a nonzero imaginary part. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>num_solve</em>(&lt;exp&gt;, &lt;var&gt;[=&lt;val&gt;][,accuracy=&lt;a&gt;][,
iterations=&lt;i&gt;]) 
<P>
<P>
or 
<P>
<P>
<em>num_solve</em>({&lt;exp&gt;,...,&lt;exp&gt;}, &lt;var&gt;[=&lt;val&gt;],...,
&lt;var&gt;[=&lt;val&gt;] 
 [,accuracy=&lt;a&gt;][,iterations=&lt;i&gt;]) 
<P>
<P>
or 
<P>
<P>
<em>num_solve</em>({&lt;exp&gt;,...,&lt;exp&gt;}, {&lt;var&gt;[=&lt;val&gt;],...
,&lt;var&gt;[=&lt;val&gt;]} 
 [,accuracy=&lt;a&gt;][,iterations=&lt;i&gt;]) 
 <P>
<P>
<P>
<P>
where &lt;exp&gt; are function expressions, 
 &lt;var&gt; are the variables, 
 &lt;val&gt; are optional start values. 
For &lt;a&gt; and &lt;i&gt; see 
<a href=r38_0400.html#r38_0424>numeric accuracy</a>. 
 <P>
<P>
<em>num_solve</em>tries to find a zero/solution of the expression(s). 
Result is a list of equations, where the variables are 
equated to the coordinates of the result point. 
 <P>
<P>
The <em>Jacobian matrix</em> is stored as side effect the shared 
variable <em>jacobian</em>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
num_solve({sin x=cos y, x + y = 1},{x=1,y=2});


  {X= - 1.8561957251,Y=2.856195584}


jacobian;

      [COS(X)  SIN(Y)]
      [              ]
      [  1       1   ]

</tt></pre><p>
<a name=r38_0428>

<title>num_int</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUM_INT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
For the numerical evaluation of univariate integrals 
over a finite interval the following strategy is used: 
If 
<a href=r38_0150.html#r38_0154>int</a> finds a formal antiderivative 
 which is bounded in the integration interval, this 
 is evaluated and the end points and the difference 
 is returned. 
Otherwise a 
<a href=r38_0400.html#r38_0431>Chebyshev fit</a> is computed, 
 starting with order 20, eventually up to order 80. 
 If that is recognized as sufficiently convergent 
 it is used for computing the integral by directly 
 integrating the coefficient sequence. 
If none of these methods is successful, an 
 adaptive multilevel quadrature algorithm is used. 
<P>
<P>
For multivariate integrals only the adaptive quadrature is used. 
This algorithm tolerates isolated singularities. 
The value <em>iterations</em> here limits the number of 
local interval intersection levels. 
&lt;a&gt; is a measure for the relative total discretization 
error (comparison of order 1 and order 2 approximations). 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>num_int</em>(&lt;exp&gt;,&lt;var&gt;=(&lt;l&gt; .. &lt;u&gt;) 
 [,&lt;var&gt;=(&lt;l&gt; .. &lt;u&gt;),...] 
 [,accuracy=&lt;a&gt;][,iterations=&lt;i&gt;]) 
<P>
<P>
<P>
where &lt;exp&gt; is the function to be integrated, 
&lt;var&gt; are the integration variables, 
&lt;l&gt; are the lower bounds, 
&lt;u&gt; are the upper bounds. 
 <P>
<P>
Result is the value of the integral. 
 <P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
num_int(sin x,x=(0 .. 3.1415926));

  2.0000010334

</tt></pre><p>
<a name=r38_0429>

<title>num_odesolve</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUM_ODESOLVE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The <em>Runge-Kutta</em> method of order 3 finds an approximate graph for 
the solution of real <em>ODE initial value problem</em>. 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>num_odesolve</em>(&lt;exp&gt;,&lt;depvar&gt;=&lt;start&gt;, 
 &lt;indep&gt;=(&lt;from&gt; .. &lt;to&gt;) 
 [,accuracy=&lt;a&gt;][,iterations=&lt;i&gt;]) 
<P>
<P>
or 
<P>
<P>
<em>num_odesolve</em>({&lt;exp&gt;,&lt;exp&gt;,...}, 
 { &lt;depvar&gt;=&lt;start&gt;,&lt;depvar&gt;=&lt;start&gt;,...} 
 &lt;indep&gt;=(&lt;from&gt; .. &lt;to&gt;) 
 [,accuracy=&lt;a&gt;][,iterations=&lt;i&gt;]) 
<P>
<P>
<P>
<P>
where 
&lt;depvar&gt; and &lt;start&gt; specify the dependent variable(s) 
and the starting point value (vector), 
&lt;indep&gt;, &lt;from&gt; and &lt;to&gt; specify the independent variable 
and the integration interval (starting point and end point), 
&lt;exp&gt; are equations or expressions which 
contain the first derivative of the independent variable 
with respect to the dependent variable. 
 <P>
<P>
The ODEs are converted to an explicit form, which then is 
used for a Runge Kutta iteration over the given range. The 
number of steps is controlled by the value of &lt;i&gt; 
(default: 20). If the steps are too coarse to reach the desired 
accuracy in the neighborhood of the starting point, the number is 
increased automatically. 
 <P>
<P>
Result is a list of pairs, each representing a point of the 
approximate solution of the ODE problem. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
depend(y,x);

num_odesolve(df(y,x)=y,y=1,x=(0 .. 1), iterations=5);


  ,{0.2,1.2214},{0.4,1.49181796},{0.6,1.8221064563},
    {0.8,2.2255208258},{1.0,2.7182511366}}

</tt></pre><p>In most cases you must declare the dependency relation 
between the variables explicitly using 
<a href=r38_0150.html#r38_0192>depend</a>; 
otherwise the formal derivative might be converted to zero. 
<P>
<P>
The operator 
<a href=r38_0150.html#r38_0179>solve</a> is used to convert the form into 
an explicit ODE. If that process fails or if it has no unique result, 
the evaluation is stopped with an error message. 
<P>
<P>

<a name=r38_0430>

<title>bounds</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>BOUNDS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
<P>
<P>
Upper and lower bounds of a real valued function over an 

<a href=r38_0400.html#r38_0423>interval</a> or a rectangular multivariate domain
 are computed 
by the operator <em>bounds</em>. The algorithmic basis is the computation 
with inequalities: starting from the interval(s) of the 
variables, the bounds are propagated in the expression 
using the rules for inequality computation. Some knowledge 
about the behavior of special functions like ABS, SIN, COS, EXP, LOG, 
fractional exponentials etc. is integrated and can be evaluated 
if the operator <em>bounds</em> is called with rounded mode on 
(otherwise only algebraic evaluation rules are available). 
 <P>
<P>
If <em>bounds</em> finds a singularity within an interval, the evaluation 
is stopped with an error message indicating the problem part 
of the expression. 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>bounds</em>(&lt;exp&gt;,&lt;var&gt;=(&lt;l&gt; .. &lt;u&gt;) 
 [,&lt;var&gt;=(&lt;l&gt; .. &lt;u&gt;) ...]) 
<P>
<P>
or 
<P>
<P>
<em>bounds</em>(&lt;exp&gt;,{&lt;var&gt;=(&lt;l&gt; .. &lt;u&gt;) 
 [,&lt;var&gt;=(&lt;l&gt; .. &lt;u&gt;) ...]}) 
<P>
<P>
<P>
<P>
where &lt;exp&gt; is the function to be investigated, 
&lt;var&gt; are the variables of &lt;exp&gt;, 
&lt;l&gt; and &lt;u&gt; specify the area as set of 
<a href=r38_0400.html#r38_0423>interval</a><em>s</em>. 
<P>
<P>
<em>bounds</em>computes upper and lower bounds for the expression in the 
given area. An 
<a href=r38_0400.html#r38_0423>interval</a> is returned. 
 <P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
bounds(sin x,x=(1 .. 2));

  -1 .. 1


on rounded;

bounds(sin x,x=(1 .. 2));

  0.84147098481 .. 1


bounds(x**2+x,x=(-0.5 .. 0.5));

  - 0.25 .. 0.75

</tt></pre><p>
<a name=r38_0431>

<title>Chebyshev_fit</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>CHEBYSHEV FIT</b><P>
<P>
 
 <P>
<P>
The operator family <em>Chebyshev_...</em> implements approximation 
and evaluation of functions by the Chebyshev method. 
Let <em>T(n,a,b,x)</em> be the Chebyshev polynomial of order <em>n</em> 
transformed to the interval <em>(a,b)</em>. 
Then a function <em>f(x)</em> can be 
approximated in <em>(a,b)</em> by a series 
<P>
<P>
<p><pre><tt>
  for i := 0:n sum c(i)*T(i,a,b,x)
</tt></pre><p>The operator <em>chebyshev_fit</em> computes this approximation an
d 
returns a list, which has as first element the sum expressed 
as a polynomial and as second element the sequence 
of Chebyshev coefficients. 
<em>Chebyshev_df</em> and <em>Chebyshev_int</em> transform a Chebyshev 
coefficient list into the coefficients of the corresponding 
derivative or integral respectively. For evaluating a Chebyshev 
approximation at a given point in the basic interval the 
operator <em>Chebyshev_eval</em> can be used. 
<em>Chebyshev_eval</em> is based on a recurrence relation which is 
in general more stable than a direct evaluation of the 
complete polynomial. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>chebyshev_fit</em>(&lt;fcn&gt;,&lt;var&gt;=(&lt;lo&gt; .. &lt;hi&gt;),&lt;n
&gt;) 
<P>
<P>
<em>chebyshev_eval</em>(&lt;coeffs&gt;,&lt;var&gt;=(&lt;lo&gt; .. &lt;hi&gt;), 
 &lt;var&gt;=&lt;pt&gt;) 
<P>
<P>
<em>chebyshev_df</em>(&lt;coeffs&gt;,&lt;var&gt;=(&lt;lo&gt; .. &lt;hi&gt;)) 
<P>
<P>
<em>chebyshev_int</em>(&lt;coeffs&gt;,&lt;var&gt;=(&lt;lo&gt; .. &lt;hi&gt;)) 
<P>
<P>
<P>
where &lt;fcn&gt; is an algebraic expression (the target function), 
&lt;var&gt; is the variable of &lt;fcn&gt;, 
&lt;lo&gt; and &lt;hi&gt; are 
numerical real values which describe an 
<a href=r38_0400.html#r38_0423>interval</a> &lt;lo&gt; &lt;&lt;hi&gt;, 
the integer &lt;n&gt; is the approximation order (set to 20 if missing), 
&lt;pt&gt; is a number in the interval and &lt;coeffs&gt; is 
a series of Chebyshev coefficients. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>

on rounded;


w:=chebyshev_fit(sin x/x,x=(1 .. 3),5);


                 3            2
  w := {0.03824*x   - 0.2398*x   + 0.06514*x + 0.9778,
        {0.8991,-0.4066,-0.005198,0.009464,-0.00009511}}                    


chebyshev_eval(second w, x=(1 .. 3), x=2.1);


  0.4111

</tt></pre><p>
<a name=r38_0432>

<title>num_fit</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NUM_FIT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>num_fit</em> finds for a set of 
points the linear combination of a given set of 
functions (function basis) which approximates the 
points best under the objective of the <em>least squares</em> 
criterion (minimum of the sum of the squares of the deviation). 
The solution is found as zero of the 
gradient vector of the sum of squared errors. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>num_fit</em>(&lt;vals&gt;,&lt;basis&gt;,&lt;var&gt;=&lt;pts&gt;) 
<P>
<P>
<P>
where &lt;vals&gt; is a list of numeric values, 
&lt;var&gt; is a variable used for the approximation, 
&lt;pts&gt; is a list of coordinate values which correspond to 
&lt;var&gt;, 
&lt;basis&gt; is a set of functions varying in <em>var</em> which is used 
 for the approximation. 
 <P>
<P>
The result is a list containing as first element the 
function which approximates the given values, and as 
second element a list of coefficients which were used 
to build this function from the basis. 
 <P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
 
pts:=for i:=1 step 1 until 5 collect i$

vals:=for i:=1 step 1 until 5 collect

            for j:=1:i product j$

num_fit(vals,{1,x,x**2},x=pts);

                     2
      {14.571428571*X   - 61.428571429*X + 54.6,{54.6,
           - 61.428571429,14.571428571}}

</tt></pre><p>
<a name=r38_0433>

<title>Numeric Package</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Numeric Package</b><menu>
<li><a href=r38_0400.html#r38_0422>Numeric Package introduction</a><P>
<li><a href=r38_0400.html#r38_0423>Interval type</a><P>
<li><a href=r38_0400.html#r38_0424>numeric accuracy concept</a><P>
<li><a href=r38_0400.html#r38_0425>TRNUMERIC switch</a><P>
<li><a href=r38_0400.html#r38_0426>num_min operator</a><P>
<li><a href=r38_0400.html#r38_0427>num_solve operator</a><P>
<li><a href=r38_0400.html#r38_0428>num_int operator</a><P>
<li><a href=r38_0400.html#r38_0429>num_odesolve operator</a><P>
<li><a href=r38_0400.html#r38_0430>bounds operator</a><P>
<li><a href=r38_0400.html#r38_0431>Chebyshev fit concept</a><P>
<li><a href=r38_0400.html#r38_0432>num_fit operator</a><P>
</menu>
<a name=r38_0434>

<title>Roots_Package</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ROOTS PACKAGE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>introduction</b><P>
<P>
 
 <P>
<P>
The root finding package is designed so that it can 
be used to find some or all of the roots of univariate 
polynomials with real or complex coefficients, to the accuracy 
specified by the user. 
<P>
<P>
Not all operators of <em>roots package</em> are described here. For using 
the operators 
<P>
<P>
<em>isolater</em>(intervals isolating real roots) 
<P>
<P>
<em>rlrootno</em>(number of real roots in an interval) 
<P>
<P>
<em>rootsat-prec</em>(roots at system precision) 
<P>
<P>
<em>rootval</em>(result in equation form) 
<P>
<P>
<em>firstroot</em>(computing only one root) 
<P>
<P>
<em>getroot</em>(selecting roots from a collection) 
<P>
<P>
please consult the full documentation of the package. 
<P>
<P>

<a name=r38_0435>

<title>MKPOLY</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MKPOLY</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
Given a roots list as returned by 
<a href=r38_0400.html#r38_0439>roots</a>, 
the operator <em>mkpoly</em> constructs a 
polynomial which has these numbers as roots. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>mkpoly</em>&lt;rl&gt; 
<P>
<P>
<P>
where &lt;rl&gt; is a 
<a href=r38_0050.html#r38_0053>list</a> with equations, which 
all have the same 
<a href=r38_0001.html#r38_0002>kernel</a> on their left-hand sides 
and numbers as right-hand sides. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
mkpoly{x=1,x=-2,x=i,x=-i};

  x**4 + x**3 - x**2 + x - 2

</tt></pre><p>Note that this polynomial is unique only up to a numeric 
factor. 
<P>
<P>

<a name=r38_0436>

<title>NEARESTROOT</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>NEARESTROOT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>nearestroot</em> finds one root of a polynomial 
with an iteration using a given starting point. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>nearestroot</em>(&lt;p&gt;,&lt;pt&gt;) 
<P>
<P>
<P>
where &lt;p&gt; is a univariate polynomial 
and &lt;pt&gt; is a number. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
nearestroot(x^2+2,2);

  {x=1.41421*i}

</tt></pre><p>The minimal accuracy of the result values is controlled by 

<a href=r38_0400.html#r38_0438>rootacc</a>. 
<P>
<P>

<a name=r38_0437>

<title>REALROOTS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>REALROOTS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>realroots</em> finds that real roots of a polynomial 
to an accuracy that is sufficient to separate them and which is 
a minimum of 6 decimal places. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>realroots</em>(&lt;p&gt;) or 
<P>
<P>
<em>realroots</em>(&lt;p&gt;,&lt;from&gt;,&lt;to&gt;) 
<P>
<P>
<P>
where &lt;p&gt; is a univariate polynomial. 
The optional parameters &lt;from&gt; and &lt;to&gt; classify 
an interval: if given, exactly the real roots in this 
interval will be returned. &lt;from&gt; and &lt;to&gt; 
can also take the values <em>infinity</em> or <em>-infinity</em>. 
If omitted all real roots will be returned. 
Result is a 
<a href=r38_0050.html#r38_0053>list</a> 
of equations which represent the roots of the polynomial at the 
given accuracy. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
realroots(x^5-2);

  {x=1.1487}


realroots(x^3-104*x^2+403*x-300,2,infinity);


  {x=3.0,x=100.0}


realroots(x^3-104*x^2+403*x-300,-infinity,2);


  {x=1}

</tt></pre><p>The minimal accuracy of the result values is controlled by 

<a href=r38_0400.html#r38_0438>rootacc</a>. 
<P>
<P>

<a name=r38_0438>

<title>ROOTACC</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ROOTACC</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>rootacc</em> allows you to set the accuracy 
up to which the roots package computes its results. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>rootacc</em>(&lt;n&gt;) 
<P>
<P>
<P>
Here &lt;n&gt; is an integer value. The internal accuracy of 
the <em>roots</em> package is adjusted to a value of 
<em>max(6,n)</em>. The default value is <em>6</em>. 
<P>
<P>

<a name=r38_0439>

<title>ROOTS</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ROOTS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>roots</em> 
is the main top level function of the roots package. 
It will find all roots, real and complex, of the polynomial p 
to an accuracy that is sufficient to separate them and which is 
a minimum of 6 decimal places. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>roots</em>(&lt;p&gt;) 
<P>
<P>
<P>
where &lt;p&gt; is a univariate polynomial. Result is a 
<a href=r38_0050.html#r38_0053>list</a> 
of equations which represent the roots of the polynomial at the 
given accuracy. In addition, <em>roots</em> stores 
separate lists of real roots and complex roots in the global 
variables 
<a href=r38_0400.html#r38_0442>rootsreal</a> and 
<a href=r38_0400.html#r38_0441>rootscomplex</a>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
roots(x^5-2);

  {x=-0.929316 + 0.675188*i,
    x=-0.929316 - 0.675188*i,
    x=0.354967 + 1.09248*i,
    x=0.354967 - 1.09248*i, 
    x=1.1487}

</tt></pre><p>The minimal accuracy of the result values is controlled by 

<a href=r38_0400.html#r38_0438>rootacc</a>. 
<P>
<P>

<a name=r38_0440>

<title>ROOT_VAL</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ROOT\_VAL</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
The operator <em>root_val</em> computes the roots of a 
univariate polynomial at system precision 
(or greater if required for root separation) and presents 
its result as a list of numbers. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>roots</em>(&lt;p&gt;) 
<P>
<P>
<P>
where &lt;p&gt; is a univariate polynomial. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
root_val(x^5-2);

  {-0.929316490603 + 0.6751879524*i,
   -0.929316490603 - 0.6751879524*i,
   0.354967313105 + 1.09247705578*i,
   0.354967313105 - 1.09247705578*i,
   1.148698355}

</tt></pre><p>
<a name=r38_0441>

<title>ROOTSCOMPLEX</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ROOTSCOMPLEX</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
 <P>
<P>
When the operator 
<a href=r38_0400.html#r38_0439>roots</a> is called the complex 
roots are collected in the global variable <em>rootscomplex</em> 
as 
<a href=r38_0050.html#r38_0053>list</a>. 
<P>
<P>

<a name=r38_0442>

<title>ROOTSREAL</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>ROOTSREAL</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
 <P>
<P>
When the operator 
<a href=r38_0400.html#r38_0439>roots</a> is called the real 
roots are collected in the global variable <em>rootreal</em> 
as 
<a href=r38_0050.html#r38_0053>list</a>. 
<P>
<P>

<a name=r38_0443>

<title>Roots Package</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Roots Package</b><menu>
<li><a href=r38_0400.html#r38_0434>Roots Package introduction</a><P>
<li><a href=r38_0400.html#r38_0435>MKPOLY operator</a><P>
<li><a href=r38_0400.html#r38_0436>NEARESTROOT operator</a><P>
<li><a href=r38_0400.html#r38_0437>REALROOTS operator</a><P>
<li><a href=r38_0400.html#r38_0438>ROOTACC operator</a><P>
<li><a href=r38_0400.html#r38_0439>ROOTS operator</a><P>
<li><a href=r38_0400.html#r38_0440>ROOT\_VAL operator</a><P>
<li><a href=r38_0400.html#r38_0441>ROOTSCOMPLEX variable</a><P>
<li><a href=r38_0400.html#r38_0442>ROOTSREAL variable</a><P>
</menu>
<a name=r38_0444>

<title>Special_Function_Package</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SPECIAL FUNCTION PACKAGE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>introduction</b>
<P>
<P>
 
The REDUCE <em>Special Function Package</em> supplies extended 
algebraic and numeric support for a wide class of objects. 
This package was released together with REDUCE 3.5 (October 1993) 
for the first time, a major update is released with REDUCE 3.6. 
<P>
<P>
The functions included in this package are in most cases (unless otherwise 
stated) defined and named like in the book by Abramowitz and Stegun: 
Handbook of Mathematical Functions, Dover Publications. 
<P>
<P>
The aim is to collect as much information on the special functions 
and simplification capabilities as possible, 
i.e. algebraic simplifications and numeric (rounded mode) code, limits 
of the functions together 
with the definitions of the functions, which are in most cases a power 
series, a (definite) integral and/or a differential equation. 
<P>
<P>
What can be found: Some famous constants, a variety of Bessel functions, 
special polynomials, 
the Gamma function, the (Riemann) Zeta function, Elliptic Functions, Elliptic 
Integrals, 3J symbols (Clebsch-Gordan coefficients) and integral functions. 
<P>
<P>
What is missing: Mathieu functions, LerchPhi, etc.. 
The information about the special functions which solve certain 
differential equation is very limited. 
In several cases numerical approximation is restricted to real 
arguments or is missing completely. 
<P>
<P>
The implementation of this package uses REDUCE rule sets to a large extent, 
which guarantees a high 'readability' of the functions definitions in the 
source file directory. It makes extensions to the special 
functions code easy in most cases too. To look at these rules 
it may be convenient to use the showrules operator e.g. 
<P>
<P>

<a href=r38_0150.html#r38_0178>showrules</a>Besseli; 
<P>
<P>
. 
<P>
<P>
Some evaluations are improved if the special function package is loaded, 
e.g. some (infinite) sums and products leading to expressions including 
special functions are known in this case. 
<P>
<P>
Note: The special function package has to be loaded explicitly by calling 
<p><pre><tt>
   load_package specfn;
</tt></pre><p><P>
<P>
The functions 
<a href=r38_0500.html#r38_0530>MeijerG</a> and 
<a href=r38_0500.html#r38_0529>hypergeometric</a> require 
additionally 
<p><pre><tt>
   load_package specfn2;
</tt></pre><p><P>
<P>

<a name=r38_0445>

<title>Constants</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>CONSTANTS</b><P>
<P>
 
 <P>
<P>
There are a few constants known to the special function package, namely 
<P>
<P>
 _ _ _ <em>Euler's constant </em>(which can be computed as -
<a href=r38_0450.html#r38_0494>Psi</a>(1)) and 
<P>
 _ _ _ <em>Khinchin's constant</em> (which is defined in Khinchin's book 
 ``Continued Fractions'') and 
<P>
 _ _ _ <em>Golden_Ratio</em> (which can be computed as (1 + sqrt 5)/2) and 
<P>
 _ _ _ <em>Catalan's constant</em> (which is known as an infinite sum of recipro
cal 
powers) 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
on rounded;
Euler_Gamma; 

  0.577215664902 


Khinchin; 

  2.68545200107 


Catalan 

  0.915965594177 


Golden_Ratio 

  1.61803398875

</tt></pre><p>
<a name=r38_0446>

<title>BERNOULLI</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>BERNOULLI</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The <em>bernoulli</em> operator returns the nth Bernoulli number. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>Bernoulli</em>(&lt;integer&gt;) 
<P>
<P>
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
bernoulli 20; 

  - 174611 / 330 


bernoulli 17; 

  0

</tt></pre><p>All Bernoulli numbers with odd indices except for 1 are zero. 
<P>
<P>
<P>

<a name=r38_0447>

<title>BERNOULLIP</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>BERNOULLIP</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The <em>BernoulliP</em> operator returns the nth Bernoulli Polynomial 
evaluated at x. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>BernoulliP</em>(&lt;integer&gt;,&lt;expression&gt;) 
<P>
<P>
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
BernoulliP(3,z); 

        2
  z*(2*z   - 3*z + 1)/2



BernoulliP(10,3); 

  338585 / 66

</tt></pre><p>The value of the nth Bernoulli Polynomial at 0 is the nth Bernoull
i number. 
<P>
<P>
<P>

<a name=r38_0448>

<title>EULER</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>EULER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The <em>EULER</em> operator returns the nth Euler number. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>Euler</em>(&lt;integer&gt;) 
<P>
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
Euler 20; 

  370371188237525 


Euler 0; 

  1

</tt></pre><p>The <em>Euler</em> numbers are evaluated by a recursive algorithm 
which 
makes it hard to compute Euler numbers above say 200. 
<P>
<P>
Euler numbers appear in the coefficients of the power series 
representation of 1/cos(z). 
<P>
<P>
<P>

<a name=r38_0449>

<title>EULERP</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>EULERP</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The <em>EulerP</em> operator returns the nth Euler Polynomial. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>EulerP</em>(&lt;integer&gt;,&lt;expression&gt;) 
<P>
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
EulerP(2,xx); 

  xx*(xx - 1) 


EulerP(10,3); 

  2046

</tt></pre><p>The Euler numbers are the values of the Euler Polynomials at 1/2 
multiplied by 2**n. 
<P>
<P>
<P>
