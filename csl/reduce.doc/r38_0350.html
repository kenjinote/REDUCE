
<a name=r38_0350>

<title>Matrix Operations</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Matrix Operations</b><menu>
<li><a href=r38_0300.html#r38_0341>COFACTOR operator</a><P>
<li><a href=r38_0300.html#r38_0342>DET operator</a><P>
<li><a href=r38_0300.html#r38_0343>MAT operator</a><P>
<li><a href=r38_0300.html#r38_0344>MATEIGEN operator</a><P>
<li><a href=r38_0300.html#r38_0345>MATRIX declaration</a><P>
<li><a href=r38_0300.html#r38_0346>NULLSPACE operator</a><P>
<li><a href=r38_0300.html#r38_0347>RANK operator</a><P>
<li><a href=r38_0300.html#r38_0348>TP operator</a><P>
<li><a href=r38_0300.html#r38_0349>TRACE operator</a><P>
</menu>
<a name=r38_0351>

<title>Groebner_bases</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBNER BASES</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>introduction</b><P>
<P>
 
The GROEBNER package calculates <em>Groebner bases</em> using the 
 <em>Buchberger algorithm</em> and provides related algorithms 
for arithmetic with ideal bases, such as ideal quotients, 
Hilbert polynomials ( <em>Hollmann algorithm</em>), 
basis conversion ( 
 <em>Faugere-Gianni-Lazard-Mora algorithm</em>), independent 
variable set ( <em>Kredel-Weispfenning algorithm</em>). 
<P>
<P>
Some routines of the Groebner package are used by 
<a href=r38_0150.html#r38_0179>solve</a> - in 
that context the package is loaded automatically. However, if you 
want to use the package by explicit calls you must load it by 
<p><pre><tt>
    load_package groebner;
</tt></pre><p><P>
<P>
For the common parameter setting of most operators in this package 
see 
<a href=r38_0350.html#r38_0352>ideal parameters</a>. 
<P>
<P>

<a name=r38_0352>

<title>Ideal_Parameters</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>IDEAL PARAMETERS</b><P>
<P>
 
 <P>
<P>
Most operators of the <em>Groebner</em> package compute expressions in a 
polynomial ring which given as &lt;R&gt;[&lt;var&gt;,&lt;var&gt;,...] where 
&lt;R&gt; is the current REDUCE coefficient domain. All algebraically 
exact domains of REDUCE are supported. The package can operate over rings 
and fields. The operation mode is distinguished automatically. In 
general the ring mode is a bit faster than the field mode. The factoring 
variant can be applied only over domains which allow you factoring of 
multivariate polynomials. 
<P>
<P>
The variable sequence &lt;var&gt; is either declared explicitly as argument 
in form of a 
<a href=r38_0050.html#r38_0053>list</a> in 
<a href=r38_0350.html#r38_0354>torder</a>, or it is extracted 
automatically from the expressions. In the second case the current REDUCE 
system order is used (see 
<a href=r38_0150.html#r38_0198>korder</a>) for arranging the variables. 
If some kernels should play the role of formal parameters (the ground 
domain &lt;R&gt; then is the polynomial ring over these), the variable 
sequences must be given explicitly. 
<P>
<P>
All REDUCE 
<a href=r38_0001.html#r38_0002>kernel</a>s can be used as variables. But please 
note, 
that all variables are considered as independent. E.g. when using 
<em>sin(a)</em> and <em>cos(a)</em> as variables, the basic relation 
<em>sin(a)^2+cos(a)^2-1=0</em> must be explicitly added to an equation set 
because the Groebner operators don't include such knowledge automatically. 
<P>
<P>
The terms (monomials) in polynomials are arranged according to the current 

<a href=r38_0350.html#r38_0353>term order</a>. Note that the algebraic propertie
s of the computed 
results only are valid as long as neither the ordering nor the variable 
sequence changes. 
<P>
<P>
The input expressions &lt;exp&gt; can be polynomials &lt;p&gt;, rational 
functions &lt;n&gt;/&lt;d&gt; or equations &lt;lh&gt;=&lt;rh&gt; built from 
polynomials or rational functions. Apart from the <em>tracing</em> 
algorithms 
<a href=r38_0350.html#r38_0398>groebnert</a> and 
<a href=r38_0350.html#r38_0399>preducet</a>, where the equations 
have a specific meaning, equations are converted to simple expressions by 
taking the difference of the left-hand and right-hand sides 
&lt;lh&gt;-&lt;rh&gt;=&gt;&lt;p&gt;. Rational functions are converted to 
polynomials by converting the expression to a common denominator form 
first, and then using the numerator only &lt;n&gt;=&gt;&lt;p&gt;. So eventual 
zeros of the denominators are ignored. 
<P>
<P>
A basis on input or output of an algorithm is coded as 
<a href=r38_0050.html#r38_0053>list</a> of 
expressions {&lt;exp&gt;,&lt;exp&gt;,...} . 
<P>
<P>

<a name=r38_0353>

<title>Term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>TERM ORDER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>introduction</b><P>
<P>
 
 <P>
<P>
For all <em>Groebner</em> operations the polynomials are 
represented in distributive form: a sum of terms (monomials). 
The terms are ordered corresponding to the actual <em>term order</em> 
which is set by the 
<a href=r38_0350.html#r38_0354>torder</a> operator, and to the 
actual variable sequence which is either given as explicit 
parameter or by the system 
<a href=r38_0001.html#r38_0002>kernel</a> order. 
<P>
<P>

<a name=r38_0354>

<title>torder</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>TORDER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The operator <em>torder</em> sets the actual variable sequence and term order. 
<P>
<P>
1. simple term order: 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>torder</em>(&lt;vl&gt;, &lt;m&gt;) 
<P>
<P>
<P>
where &lt;vl&gt; is a 
<a href=r38_0050.html#r38_0053>list</a> of variables (
<a href=r38_0001.html#r38_0002>kernel</a>s) and 
&lt;m&gt; is the name of a simple 
<a href=r38_0350.html#r38_0353>term order</a> mode 

<a href=r38_0350.html#r38_0356>lex term order</a>, 
<a href=r38_0350.html#r38_0357>gradlex term order</a>, 

<a href=r38_0350.html#r38_0358>revgradlex term order</a> or another implemented 
parameterless mode. 
<P>
<P>
2. stepped term order: 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>torder</em>(&lt;vl&gt;,&lt;m&gt;,&lt;n&gt;) 
<P>
<P>
<P>
<P>
where &lt;m&gt; is the name of a two step term order, one of 

<a href=r38_0350.html#r38_0359>gradlexgradlex term order</a>, 
<a href=r38_0350.html#r38_0360>gradlexrevgradlex term order</a>, 

<a href=r38_0350.html#r38_0361>lexgradlex term order</a> or 
<a href=r38_0350.html#r38_0362>lexrevgradlex term order</a>, and 
&lt;n&gt; is a positive integer. 
<P>
<P>
3. weighted term order 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>torder</em>(&lt;vl&gt;, <em>weighted</em>, &lt;n&gt;,&lt;n&gt;,...); 
<P>
<P>
<P>
where the &lt;n&gt; are positive integers, see 
<a href=r38_0350.html#r38_0363>weighted term order</a>. 
<P>
<P>
4. matrix term order 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>torder</em>(&lt;vl&gt;, <em>matrix</em>, &lt;m&gt;); 
<P>
<P>
<P>
where &lt;m&gt; is a matrix with integer elements, see 

<a href=r38_0350.html#r38_0355>torder_compile</a>. 
<P>
<P>
5. compiled term order 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>torder</em>(&lt;vl&gt;, <em>co</em>); 
<P>
<P>
<P>
where &lt;co&gt; is the name of a routine generated by 

<a href=r38_0350.html#r38_0355>torder_compile</a>. 
<P>
<P>
<em>torder</em>sets the variable sequence and the term order mode. If the 
an empty list is used as variable sequence, the automatic variable extraction 
is activated. The defaults are the empty variable list an the 

<a href=r38_0350.html#r38_0356>lex term order</a>. 
The previous setting is returned as a list. 
<P>
<P>
Alternatively to the above syntax the arguments of <em>torder</em> may be 
collected in a 
<a href=r38_0050.html#r38_0053>list</a> and passed as one argument to 
<em>torder</em>. 
<P>
<P>

<a name=r38_0355>

<title>torder_compile</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>TORDER_COMPILE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
A matrix can be converted into 
a compilable LISP program for faster execution by using 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>torder_compile</em>(&lt;name&gt;,&lt;mat&gt;) 
<P>
<P>
<P>
where &lt;name&gt; is an identifier for the new term order and &lt;mat&gt; 
is an integer matrix to be used as 
<a href=r38_0350.html#r38_0365>matrix term order</a>. Afterwards 
the term order can be activated by using &lt;name&gt; in a 
<a href=r38_0350.html#r38_0354>torder</a> 
expression. The resulting program is compiled if the switch 
<a href=r38_0250.html#r38_0273>comp</a> 
is on, or if the <em>torder_compile</em> expression is part of a compiled 
module. 
<P>
<P>

<a name=r38_0356>

<title>lex_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LEX TERM ORDER</b><P>
<P>
 
 <P>
<P>
The terms are ordered lexicographically: two terms t1 t2 
are compared for their degrees 
along the fixed variable sequence: t1 is higher than t2 
if the first different degree is higher in t1. 
This order has the <em>elimination property</em> 
for <em>groebner basis</em> calculations. 
If the ideal has a univariate polynomial in the last 
variable the groebner basis will contain 
such polynomial. <em>Lex</em> is best 
suited for solving of polynomial equation systems. 
<P>
<P>

<a name=r38_0357>

<title>gradlex_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GRADLEX TERM ORDER</b><P>
<P>
 
 <P>
<P>
The terms are ordered first with their total 
degree, and if the total degree is identical 
the comparison is 
<a href=r38_0350.html#r38_0356>lex term order</a>. 
With <em>groebner</em> basis calculations this term order 
produces polynomials of lowest degree. 
<P>
<P>

<a name=r38_0358>

<title>revgradlex_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>REVGRADLEX TERM ORDER</b><P>
<P>
 
 <P>
<P>
The terms are ordered first with their total 
degree (degree sum), and if the total degree is identical 
the comparison is the inverse of 
<a href=r38_0350.html#r38_0356>lex term order</a>. 
With 
<a href=r38_0350.html#r38_0368>groebner</a> and 
<a href=r38_0350.html#r38_0391>groebnerf</a> 
calculations this term order 
is similar to 
<a href=r38_0350.html#r38_0357>gradlex term order</a>; it is known 
as most efficient ordering with respect to computing time. 
<P>
<P>

<a name=r38_0359>

<title>gradlexgradlex_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GRADLEXGRADLEX TERM ORDER</b><P>
<P>
 
 <P>
<P>
The terms are separated into two groups where the 
second parameter of the 
<a href=r38_0350.html#r38_0354>torder</a> call determines 
the length of the first group. For a comparison first 
the total degrees of both variable groups are compared. 
If both are equal 

<a href=r38_0350.html#r38_0357>gradlex term order</a> comparison is applied to t
he first 
group, and if that does not decide 
<a href=r38_0350.html#r38_0357>gradlex term order</a> 
is applied for the second group. This order has the elimination 
property for the variable groups. It can be used e.g. for 
separating variables from parameters. 
<P>
<P>

<a name=r38_0360>

<title>gradlexrevgradlex_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GRADLEXREVGRADLEX TERM ORDER</b><P>
<P>
 
 <P>
<P>
Similar to 
<a href=r38_0350.html#r38_0359>gradlexgradlex term order</a>, but using 

<a href=r38_0350.html#r38_0358>revgradlex term order</a> for the second group. 
<P>
<P>

<a name=r38_0361>

<title>lexgradlex_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LEXGRADLEX TERM ORDER</b><P>
<P>
 
 <P>
<P>
Similar to 
<a href=r38_0350.html#r38_0359>gradlexgradlex term order</a>, but using 

<a href=r38_0350.html#r38_0356>lex term order</a> for the first group. 
<P>
<P>

<a name=r38_0362>

<title>lexrevgradlex_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>LEXREVGRADLEX TERM ORDER</b><P>
<P>
 
 <P>
<P>
Similar to 
<a href=r38_0350.html#r38_0359>gradlexgradlex term order</a>, but using 

<a href=r38_0350.html#r38_0356>lex term order</a> for the first group 

<a href=r38_0350.html#r38_0358>revgradlex term order</a> for the second group. 
<P>
<P>

<a name=r38_0363>

<title>weighted_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>WEIGHTED TERM ORDER</b><P>
<P>
 
 <P>
<P>
establishes a graduated ordering 
similar to 
<a href=r38_0350.html#r38_0357>gradlex term order</a>, where the exponents first
 are 
multiplied by the given weights. If there are less weight values than 
variables, the weight list is extended by ones. If the weighted degree 
comparison is not decidable, the 

<a href=r38_0350.html#r38_0356>lex term order</a> is used. 
<P>
<P>

<a name=r38_0364>

<title>graded_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GRADED TERM ORDER</b><P>
<P>
 
 <P>
<P>
establishes a cascaded term ordering: first a graduated ordering 
similar to 
<a href=r38_0350.html#r38_0357>gradlex term order</a> is used, where the exponen
ts first are 
multiplied by the given weights. If there are less weight values than 
variables, the weight list is extended by ones. If the weighted degree 
comparison is not decidable, the term ordering described in the following 
parameters of the 
<a href=r38_0350.html#r38_0354>torder</a> command is used. 
<P>
<P>

<a name=r38_0365>

<title>matrix_term_order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>MATRIX TERM ORDER</b><P>
<P>
 
 <P>
<P>
Any arbitrary term order mode can be installed by a matrix with 
integer elements where the row length corresponds to the variable 
number. The matrix must have at least as many rows as columns. 
It must have full rank, and the top nonzero element of each column 
must be positive. 
<P>
<P>
The matrix <em>term order mode</em> 
defines a term order where the exponent vectors of the monomials are 
first multiplied by the matrix and the resulting vectors are compared 
lexicographically. 
<P>
<P>
If the switch 
<a href=r38_0250.html#r38_0273>comp</a> is on, the matrix is converted into 
a compiled LISP program for faster execution. A matrix can also be 
compiled explicitly, see 
<a href=r38_0350.html#r38_0355>torder_compile</a>. 
<P>
<P>

<a name=r38_0366>

<title>Term order</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Term order</b><menu>
<li><a href=r38_0350.html#r38_0353>Term order introduction</a><P>
<li><a href=r38_0350.html#r38_0354>torder operator</a><P>
<li><a href=r38_0350.html#r38_0355>torder_compile operator</a><P>
<li><a href=r38_0350.html#r38_0356>lex term order concept</a><P>
<li><a href=r38_0350.html#r38_0357>gradlex term order concept</a><P>
<li><a href=r38_0350.html#r38_0358>revgradlex term order concept</a><P>
<li><a href=r38_0350.html#r38_0359>gradlexgradlex term order concept</a><P>
<li><a href=r38_0350.html#r38_0360>gradlexrevgradlex term order concept</a><P>
<li><a href=r38_0350.html#r38_0361>lexgradlex term order concept</a><P>
<li><a href=r38_0350.html#r38_0362>lexrevgradlex term order concept</a><P>
<li><a href=r38_0350.html#r38_0363>weighted term order concept</a><P>
<li><a href=r38_0350.html#r38_0364>graded term order concept</a><P>
<li><a href=r38_0350.html#r38_0365>matrix term order concept</a><P>
</menu>
<a name=r38_0367>

<title>gvars</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GVARS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>gvars</em>({&lt;exp&gt;,&lt;exp&gt;,... }) 
<P>
<P>
<P>
<P>
where &lt;exp&gt; are expressions or 
<a href=r38_0001.html#r38_0045>equation</a>s. 
<P>
<P>
<em>gvars</em>extracts from the expressions the 
<a href=r38_0001.html#r38_0002>kernel</a><em>s</em> 
which can 
play the role of variables for a 
<a href=r38_0350.html#r38_0368>groebner</a> or 
<a href=r38_0350.html#r38_0391>groebnerf</a> 
calculation. 
<P>
<P>

<a name=r38_0368>

<title>groebner</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBNER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>groebner</em>({<em>exp</em>, ...}) 
<P>
<P>
<P>
<P>
where {<em>exp</em>, ... } is a list of 
expressions or equations. 
<P>
<P>
The operator <em>groebner</em> implements the Buchberger algorithm 
for computing Groebner bases for a given set of 
expressions with respect to the given set of variables in the order 
given. As a side effect, the sequence of variables is stored as a REDUCE list 
in the shared variable 
<a href=r38_0350.html#r38_0371>gvarslast</a> - this is important in cases 
where the algorithm rearranges the variable sequence because 
<a href=r38_0350.html#r38_0370>groebopt</a> 
is <em>on</em>. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<p><pre><tt>
   groebner({x**2+y**2-1,x-y}) 

  {X - Y,2*Y**2 -1}

</tt></pre><p> <P> <H3> 
related: </H3>
<P>
 _ _ _ 
<a href=r38_0350.html#r38_0391>groebnerf</a>operator 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0371>gvarslast</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0370>groebopt</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0372>groebprereduce</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0373>groebfullreduction</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0374>gltbasis</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0375>gltb</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0376>glterms</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0377>groebstat</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0378>trgroeb</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0379>trgroebs</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0396>groebprot</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0397>groebprotfile</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0398>groebnert</a> operator 
<P>
<P>
<P>

<a name=r38_0369>

<title>groebner_walk</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBNER\_WALK</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
The operator <em>groebner_walk</em> computes a <em>lex</em> basis 
from a given <em>graded</em> (or <em>weighted</em>) one. 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>groebner_walk</em>(&lt;g&gt;) 
<P>
<P>
<P>
where &lt;g&gt; is a <em>graded</em> basis (or <em>weighted</em> basis 
with a weight vector with one repeated element) of the polynomial ideal. 
<em>Groebner_walk</em> computes a sequence of monomial bases, each 
time lifting the full system to a complete basis. <em>Groebner_walk</em> 
should be called only in cases, where a normal <em>kex</em> computation 
would take too much computer time. 
<P>
<P>
The operator 
<a href=r38_0350.html#r38_0354>torder</a> has to be called before in order to 
define the variable sequence and the term order mode of &lt;g&gt;. 
<P>
<P>
The variable 
<a href=r38_0350.html#r38_0371>gvarslast</a> is not set. 
<P>
<P>
Do not call <em>groebner_walk</em> with <em>on</em> 
<a href=r38_0350.html#r38_0370>groebopt</a>. 
<P>
<P>
<em>Groebner_walk</em>includes some overhead (such as e. g. 
computation with division). On the other hand, sometimes 
<em>groebner_walk</em> is faster than a direct <em>lex</em> computation. 
<P>
<P>

<a name=r38_0370>

<title>groebopt</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBOPT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
If <em>groebopt</em> is set ON, the sequence of variables is optimized 
with respect to execution speed of <em>groebner</em> calculations; 
note that the final list of variables is available in 
<a href=r38_0350.html#r38_0371>gvarslast</a>. 
By default <em>groebopt</em> is off, conserving the original variable 
sequence. 
<P>
<P>
An explicitly declared dependency using the 
<a href=r38_0150.html#r38_0192>depend</a> 
declaration supersedes the variable optimization. 
 <P> <H3> 
examples: </H3>
<p><pre><tt></tt></pre><p><P>
<P>
guarantees that a will be placed in front of x and y. 
<P>
<P>

<a name=r38_0371>

<title>gvarslast</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GVARSLAST</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
After a 
<a href=r38_0350.html#r38_0368>groebner</a> or 
<a href=r38_0350.html#r38_0391>groebnerf</a> calculation 
the actual variable sequence is stored in the variable 
<em>gvarslast</em>. If 
<a href=r38_0350.html#r38_0370>groebopt</a> is <em>on</em> 
<em>gvarslast</em> shows the variable sequence after reordering. 
<P>
<P>

<a name=r38_0372>

<title>groebprereduce</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBPREREDUCE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
If <em>groebprereduce</em> set ON, 
<a href=r38_0350.html#r38_0368>groebner</a> 
and 
<a href=r38_0350.html#r38_0391>groebnerf</a> try to simplify the 
input expressions: if the head term of an input expression is a 
multiple of the head term of another expression, it can be reduced; 
these reductions are done cyclicly as long as possible in order to 
shorten the main part of the algorithm. 
<P>
<P>
By default <em>groebprereduce</em> is off. 
<P>
<P>

<a name=r38_0373>

<title>groebfullreduction</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBFULLREDUCTION</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
If <em>groebfullreduction</em> set off, the polynomial reduction steps during 

<a href=r38_0350.html#r38_0368>groebner</a> and 
<a href=r38_0350.html#r38_0391>groebnerf</a> are limited to the pure head 
term reduction; subsequent terms are reduced otherwise. 
<P>
<P>
By default <em>groebfullreduction</em> is on. 
<P>
<P>

<a name=r38_0374>

<title>gltbasis</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GLTBASIS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
If <em>gltbasis</em> set on, the leading terms of the result basis 
of a 
<a href=r38_0350.html#r38_0368>groebner</a> or 
<a href=r38_0350.html#r38_0391>groebnerf</a> calculation are 
extracted. They are collected as a basis of monomials, which is 
available as value of the global variable 
<a href=r38_0350.html#r38_0375>gltb</a>. 
<P>
<P>

<a name=r38_0375>

<title>gltb</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GLTB</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
See 
<a href=r38_0350.html#r38_0374>gltbasis</a> 
<P>
<P>

<a name=r38_0376>

<title>glterms</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GLTERMS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
If the expressions in a 
<a href=r38_0350.html#r38_0368>groebner</a> or 
<a href=r38_0350.html#r38_0391>groebnerf</a> 
call contain parameters (symbols 
which are not member of the variable list), the share variable 
<em>glterms</em> is set to a list of expression which during the 
calculation were assumed to be nonzero. The calculated bases 
are valid only under the assumption that all these expressions do 
not vanish. 
<P>
<P>

<a name=r38_0377>

<title>groebstat</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBSTAT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
if <em>groebstat</em> is on, a summary of the 

<a href=r38_0350.html#r38_0368>groebner</a> or 
<a href=r38_0350.html#r38_0391>groebnerf</a> computation is printed 
at the end 
including the computing time, the number of intermediate 
H polynomials and the counters for the criteria hits. 
<P>
<P>

<a name=r38_0378>

<title>trgroeb</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>TRGROEB</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
if <em>trgroeb</em> is on, intermediate H polynomials are 
printed during a 
<a href=r38_0350.html#r38_0368>groebner</a> 
or 
<a href=r38_0350.html#r38_0391>groebnerf</a> calculation. 
<P>
<P>

<a name=r38_0379>

<title>trgroebs</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>TRGROEBS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
if <em>trgroebs</em> is on, intermediate H and S polynomials are 
printed during a 
<a href=r38_0350.html#r38_0368>groebner</a> or 
<a href=r38_0350.html#r38_0391>groebnerf</a> calculation. 
<P>
<P>

<a name=r38_0380>

<title>gzerodim_</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GZERODIM?</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>gzerodim!?</em>(&lt;basis&gt;) 
<P>
<P>
<P>
<P>
where &lt;bas&gt; is a Groebner basis in the current 

<a href=r38_0350.html#r38_0353>term order</a> with the actual setting 
(see 
<a href=r38_0350.html#r38_0352>ideal parameters</a>). 
<P>
<P>
<em>gzerodim!?</em>tests whether the ideal spanned by the given basis 
has dimension zero. If yes, the number of zeros is returned, 

<a href=r38_0001.html#r38_0014>nil</a> otherwise. 
<P>
<P>

<a name=r38_0381>

<title>gdimension</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GDIMENSION</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>gdimension</em>(&lt;bas&gt;) 
<P>
<P>
<P>
<P>
where &lt;bas&gt; is a 
<a href=r38_0350.html#r38_0381>groebner</a> basis in the current 
term order (see 
<a href=r38_0350.html#r38_0352>ideal parameters</a>). 
<em>gdimension</em> computes the dimension of the ideal 
spanned by the given basis and returns the dimension as an integer 
number. The Kredel-Weispfenning algorithm is used: the dimension 
is the length of the longest independent variable set, 
see 
<a href=r38_0350.html#r38_0382>gindependent_sets</a> 
<P>
<P>

<a name=r38_0382>

<title>gindependent_sets</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GINDEPENDENT\_SETS</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>gindependent_sets</em>(&lt;bas&gt;) 
<P>
<P>
<P>
<P>
where &lt;bas&gt; is a 
<a href=r38_0350.html#r38_0382>groebner</a> basis in any <em>term order</em> 
(which must be the current <em>term order</em>) with the specified 
variables (see 
<a href=r38_0350.html#r38_0352>ideal parameters</a>). 
<P>
<P>
<em>Gindependent_sets</em>computes the maximal 
left independent variable sets of the ideal, that are 
the variable sets which play the role of free parameters in the 
current ideal basis. Each set is a list which is a subset of the 
variable list. The result is a list of these sets. For an 
ideal with dimension zero the list is empty. 
The Kredel-Weispfenning algorithm is used. 
<P>
<P>

<a name=r38_0383>

<title>dd_groebner</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>DD_GROEBNER</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
For a homogeneous system of polynomials under 

<a href=r38_0350.html#r38_0364>graded term order</a>, 
<a href=r38_0350.html#r38_0357>gradlex term order</a>, 

<a href=r38_0350.html#r38_0358>revgradlex term order</a> <P>
<P>
or 
<a href=r38_0350.html#r38_0363>weighted term order</a> 
a Groebner Base can be computed with limiting the grade 
of the intermediate S polynomials: 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>dd_groebner</em>(&lt;d1&gt;,&lt;d2&gt;,&lt;plist&gt;) 
<P>
<P>
<P>
where &lt;d1&gt; is a non negative integer and &lt;d2&gt; is an integer 
or ``infinity&quot;. A pair of polynomials is considered 
only if the grade of the lcm of their head terms is between 
&lt;d1&gt; and &lt;d2&gt;. 
For the term orders <em>graded</em> or <em>weighted</em> the (first) weight 
vector is used for the grade computation. Otherwise the total 
degree of a term is used. 
<P>
<P>

<a name=r38_0384>

<title>glexconvert</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GLEXCONVERT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
<em>glexconvert</em>(&lt;bas&gt;[,&lt;vars&gt;][,MAXDEG=&lt;mx&gt;] 
[,NEWVARS=&lt;nv&gt;]) 
<P>
<P>
<P>
<P>
where &lt;bas&gt; is a 
<a href=r38_0350.html#r38_0382>groebner</a> basis 
in the current term order, &lt;mx&gt; (optional) is a positive 
integer and &lt;nvl&gt; (optional) is a list of variables 
(see 
<a href=r38_0350.html#r38_0352>ideal parameters</a>). 
<P>
<P>
The operator <em>glexconvert</em> converts the basis 
of a zero-dimensional ideal (finite number 
of isolated solutions) from arbitrary ordering into a basis under 

<a href=r38_0350.html#r38_0356>lex term order</a>. 
<P>
<P>
The parameter &lt;newvars&gt; defines the new variable sequence. 
If omitted, the 
original variable sequence is used. If only a subset of variables is 
specified here, the partial ideal basis is evaluated. 
<P>
<P>
If &lt;newvars&gt; is a list with one element, the minimal 
 <em>univariate polynomial</em> is computed. 
<P>
<P>
&lt;maxdeg&gt; is an upper limit for the degrees. The algorithm stops with 
an error message, if this limit is reached. 
<P>
<P>
A warning occurs, if the ideal is not zero dimensional. 
<P>
<P>
During the call the <em>term order</em> of the input basis must 
be active. 
<P>
<P>
<P>

<a name=r38_0385>

<title>greduce</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GREDUCE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>greduce</em>(exp, {exp1, exp2, ... , expm}) 
<P>
<P>
<P>
<P>
where exp is an expression, and {exp1, exp2, ... , expm} is 
a list of expressions or equations. 
<P>
<P>
<em>greduce</em>is functionally equivalent with a call to 

<a href=r38_0350.html#r38_0382>groebner</a> and then a call to 
<a href=r38_0350.html#r38_0386>preduce</a>. 
<P>
<P>

<a name=r38_0386>

<title>preduce</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>PREDUCE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>preduce</em>(&lt;p&gt;, {&lt;exp&gt;, ... }) 
<P>
<P>
<P>
<P>
where &lt;p&gt; is an expression, and {&lt;exp&gt;, ... } is 
a list of expressions or equations. 
<P>
<P>
<em>Preduce</em>computes the remainder of <em>exp</em> 
modulo the given set of polynomials resp. equations. 
This result is unique (canonical) only if the given set 
is a <em>groebner</em> basis under the current 
<a href=r38_0350.html#r38_0353>term order</a> 
<P>
<P>
see also: 
<a href=r38_0350.html#r38_0399>preducet</a> operator. 
<P>
<P>

<a name=r38_0387>

<title>idealquotient</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>IDEALQUOTIENT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>idealquotient</em>({&lt;exp&gt;, ...}, &lt;d&gt;) 
<P>
<P>
<P>
<P>
where {&lt;exp&gt;,...} is a list of 
expressions or equations, &lt;d&gt; is a single expression or equation. 
<P>
<P>
<em>Idealquotient</em>computes the ideal quotient: 
ideal spanned by the expressions {&lt;exp&gt;,...} 
divided by the single polynomial/expression &lt;f&gt;. The result 
is the 
<a href=r38_0350.html#r38_0382>groebner</a> basis of the quotient ideal. 
<P>
<P>

<a name=r38_0388>

<title>hilbertpolynomial</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>HILBERTPOLYNOMIAL</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P>
<P>
 <P> <H3> 
syntax: </H3>
hilbertpolynomial(&lt;bas&gt;) 
<P>
<P>
<P>
<P>
where &lt;bas&gt; is a 
<a href=r38_0350.html#r38_0382>groebner</a> basis in the 
current 
<a href=r38_0350.html#r38_0353>term order</a>. 
<P>
<P>
The degree of the <em>Hilbert polynomial</em> is the 
dimension of the ideal spanned by the basis. For an 
ideal of dimension zero the Hilbert polynomial is a 
constant which is the number of common zeros of the 
ideal (including eventual multiplicities). 
The <em>Hollmann algorithm</em> is used. 
<P>
<P>

<a name=r38_0389>

<title>saturation</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>SATURATION</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>saturation</em>({&lt;exp&gt;, ...}, &lt;p&gt;) 
<P>
<P>
<P>
<P>
where {&lt;exp&gt;,...} is a list of 
expressions or equations, &lt;p&gt; is a single polynomial. 
<P>
<P>
<em>Saturation</em>computes the quotient of the polynomial &lt;p&gt; 
and a power (with unknown but finite exponent) of the ideal built from 
{&lt;exp&gt;, ...}. The result is the computed quotient. <em>Saturation</em> 
calls 
<a href=r38_0350.html#r38_0387>idealquotient</a> several times until the result 
does not change 
any more. 
<P>
<P>

<a name=r38_0390>

<title>Basic Groebner operators</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Basic Groebner operators</b><menu>
<li><a href=r38_0350.html#r38_0367>gvars operator</a><P>
<li><a href=r38_0350.html#r38_0382>groebner operator</a><P>
<li><a href=r38_0350.html#r38_0369>groebner\_walk operator</a><P>
<li><a href=r38_0350.html#r38_0370>groebopt switch</a><P>
<li><a href=r38_0350.html#r38_0371>gvarslast variable</a><P>
<li><a href=r38_0350.html#r38_0372>groebprereduce switch</a><P>
<li><a href=r38_0350.html#r38_0373>groebfullreduction switch</a><P>
<li><a href=r38_0350.html#r38_0374>gltbasis switch</a><P>
<li><a href=r38_0350.html#r38_0375>gltb variable</a><P>
<li><a href=r38_0350.html#r38_0376>glterms variable</a><P>
<li><a href=r38_0350.html#r38_0377>groebstat switch</a><P>
<li><a href=r38_0350.html#r38_0378>trgroeb switch</a><P>
<li><a href=r38_0350.html#r38_0379>trgroebs switch</a><P>
<li><a href=r38_0350.html#r38_0380>gzerodim? operator</a><P>
<li><a href=r38_0350.html#r38_0381>gdimension operator</a><P>
<li><a href=r38_0350.html#r38_0382>gindependent\_sets operator</a><P>
<li><a href=r38_0350.html#r38_0383>dd_groebner operator</a><P>
<li><a href=r38_0350.html#r38_0384>glexconvert operator</a><P>
<li><a href=r38_0350.html#r38_0385>greduce operator</a><P>
<li><a href=r38_0350.html#r38_0386>preduce operator</a><P>
<li><a href=r38_0350.html#r38_0387>idealquotient operator</a><P>
<li><a href=r38_0350.html#r38_0388>hilbertpolynomial operator</a><P>
<li><a href=r38_0350.html#r38_0389>saturation operator</a><P>
</menu>
<a name=r38_0391>

<title>groebnerf</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBNERF</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>groebnerf</em>({&lt;exp&gt;, ...}[,{},{&lt;nz&gt;, ... }]); 
<P>
<P>
<P>
<P>
where {&lt;exp&gt;, ... } is a list of expressions or 
equations, and {&lt;nz&gt;,... } is 
an optional list of polynomials to be considered as non zero 
for this calculation. An empty list must be passed as second argument 
if the non-zero list is specified. 
<P>
<P>
<em>groebnerf</em>tries to separate polynomials into individual factors and 
to branch the computation in a recursive manner (factorization tree). 
The result is a list of partial Groebner bases. 
Multiplicities (one factor with a higher power, the same partial basis 
twice) are deleted as early as possible in order to speed up the 
calculation. 
<P>
<P>
The third parameter of <em>groebnerf</em> declares some polynomials 
nonzero. If any of these is found in a branch of the calculation 
the branch is canceled. 
<P>
<P>
 <P> <H3> 
example: </H3>
<p><pre><tt>
groebnerf({ 3*x**2*y+2*x*y+y+9*x**2+5*x = 3,  
            2*x**3*y-x*y-y+6*x**3-2*x**2-3*x = -3, 
            x**3*y+x**2*y+3*x**3+2*x**2 }, {y,x});

       {{Y - 3,X},

                      2
    {2*Y + 2*X - 1,2*X  - 5*X - 5}}
</tt></pre><p> <P> <H3> 
related: </H3>
<P>
 _ _ _ 
<a href=r38_0350.html#r38_0393>groebresmax</a>variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0392>groebmonfac</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0394>groebrestriction</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0382>groebner</a> operator 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0371>gvarslast</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0370>groebopt</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0372>groebprereduce</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0373>groebfullreduction</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0374>gltbasis</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0375>gltb</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0376>glterms</a> variable 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0377>groebstat</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0378>trgroeb</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0379>trgroebs</a> switch 
<P>
 _ _ _  
<a href=r38_0350.html#r38_0398>groebnert</a> operator 
<P>
<P>
<P>

<a name=r38_0392>

<title>groebmonfac</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBMONFAC</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
The variable <em>groebmonfac</em> is connected to 
the handling of monomial factors. A monomial factor is a product 
of variable powers as a factor, e.g. x**2*y in x**3*y - 
2*x**2*y**2. A monomial factor represents a solution of the type 
 x = 0 or y = 0 with a certain multiplicity. With 

<a href=r38_0350.html#r38_0391>groebnerf</a> the multiplicity of monomial factor
s is lowered 
to the value of the shared variable <em>groebmonfac</em> 
which by default is 1 (= monomial factors remain present, but their 
multiplicity is brought down). With 
<em>groebmonfac</em>:= 0 
the monomial factors are suppressed completely. 
<P>
<P>

<a name=r38_0393>

<title>groebresmax</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBRESMAX</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
The variable <em>groebresmax</em> 
controls during 
<a href=r38_0350.html#r38_0391>groebnerf</a> calculations 
the number of partial results. Its default value is 300. If 
more partial results are calculated, the calculation is 
terminated. 
<P>
<P>

<a name=r38_0394>

<title>groebrestriction</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBRESTRICTION</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
During 
<a href=r38_0350.html#r38_0391>groebnerf</a> calculations 
irrelevant branches can be excluded 
by setting the variable <em>groebrestriction</em>. The 
following restrictions are implemented: 
 <P> <H3> 
syntax: </H3>
 <P>
<P>
<em>groebrestriction</em>:= <em>nonnegative</em> 
<P>
<P>
<em>groebrestriction</em>:= <em>positive</em> 
<P>
<P>
<em>groebrestriction</em>:= <em>zeropoint</em> 
<P>
<P>
<P>
With <em>nonnegative</em> branches are excluded where one 
polynomial has no nonnegative real zeros; with <em>positive</em> 
the restriction is sharpened to positive zeros only. 
The restriction <em>zeropoint</em> excludes all branches 
which do not have the origin (0,0,...0) in their solution 
set. 
<P>
<P>

<a name=r38_0395>

<title>Factorizing Groebner bases</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>
<b>Factorizing Groebner bases</b><menu>
<li><a href=r38_0350.html#r38_0391>groebnerf operator</a><P>
<li><a href=r38_0350.html#r38_0392>groebmonfac variable</a><P>
<li><a href=r38_0350.html#r38_0393>groebresmax variable</a><P>
<li><a href=r38_0350.html#r38_0394>groebrestriction variable</a><P>
</menu>
<a name=r38_0396>

<title>groebprot</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBPROT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>switch</b><P>
<P>
 
If <em>groebprot</em> is <em>ON</em> the computation steps during 

<a href=r38_0350.html#r38_0386>preduce</a>, 
<a href=r38_0350.html#r38_0385>greduce</a> and 
<a href=r38_0350.html#r38_0382>groebner</a> 
are collected in a list which is assigned to the variable 

<a href=r38_0350.html#r38_0397>groebprotfile</a>. 
<P>
<P>

<a name=r38_0397>

<title>groebprotfile</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBPROTFILE</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>variable</b><P>
<P>
 
See 
<a href=r38_0350.html#r38_0396>groebprot</a> switch. 
<P>
<P>

<a name=r38_0398>

<title>groebnert</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>GROEBNERT</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>groebnert</em>({&lt;v&gt;=&lt;exp&gt;,...}) 
<P>
<P>
<P>
<P>
where &lt;v&gt; are 
<a href=r38_0001.html#r38_0002>kernel</a><em>s</em> (simple or indexed variables
), 
&lt;exp&gt; are polynomials. 
<P>
<P>
<em>groebnert</em>is functionally equivalent to a 
<a href=r38_0350.html#r38_0382>groebner</a> 
call for {&lt;exp&gt;,...}, but the result is a set of 
equations where the left-hand sides are the basis elements while 
the right-hand sides are the same values expressed as combinations 
of the input formulas, expressed in terms of the names &lt;v&gt; 
 <P> <H3> 
example: </H3>
<p><pre><tt>
    groebnert({p1=2*x**2+4*y**2-100,p2=2*x-y+1});

   GB1 := {2*X - Y + 1=P2,

           2
        9*Y  - 2*Y - 199= - 2*X*P2 - Y*P2 + 2*P1 + P2}
</tt></pre><p><P>
<P>

<a name=r38_0399>

<title>preducet</title></a>
<p align="centre"><img src="redlogo.gif" width=621 height=60 border=0 alt="REDUC
E"></p>
<b><a href=r38_idx.html>INDEX</a></b><p><p>



<b>PREDUCET</b> _ _ _  _ _ _  _ _ _  _ _ _ <b>operator</b><P>
<P>
 
 <P> <H3> 
syntax: </H3>
<P>
<P>
<em>preduce</em>(&lt;p&gt;,{&lt;v&gt;=&lt;exp&gt;...}) 
<P>
<P>
<P>
where &lt;p&gt; is an expression, &lt;v&gt; are kernels 
(simple or indexed variables), 
<em>exp</em> are polynomials. 
<P>
<P>
<em>preducet</em>computes the remainder of &lt;p&gt; modulo {&lt;exp&gt;,...} 
similar to 
<a href=r38_0350.html#r38_0386>preduce</a>, but the result is an equation 
which expresses the remainder as combination of the polynomials. 
 <P> <H3> 
example: </H3>
<p><pre><tt>
                             
   GB2 := {G1=2*X - Y + 1,G2=9*Y**2  - 2*Y - 199}
   preducet(q=x**2,gb2);

 - 16*Y + 208= - 18*X*G1 - 9*Y*G1 + 36*Q + 9*G1 - G2
</tt></pre><p><P>
<P>
